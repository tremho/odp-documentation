<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>UEFI Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="mdbook-admonish.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">UEFI Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-evolution-of-uefi-into-patina-with-rust-and-odp"><a class="header" href="#the-evolution-of-uefi-into-patina-with-rust-and-odp">The Evolution of UEFI into Patina with Rust and ODP</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Firmware and UEFI firmware in particular has long been written in C. Firmware operates in a unique environment to other
system software. It is written to bootstrap a system often at the host CPU reset vector and as part of a chain of
trust established by a hardware rooted immutable root of trust. Modern PC firmware is extraordinarily complex with
little room for error.</p>
<h3 id="firmware-evolution"><a class="header" href="#firmware-evolution">Firmware Evolution</a></h3>
<p>From a functional perspective, firmware must initialize the operating environment of a device. To do so involves
integrating vendor code for dedicated microcontrollers, security engines, individual peripherals, SOC initialization,
and so on. Individual firmware blobs may be located on a number of non-volatile media with very limited capacity. The
firmware must perform its functional tasks successfully or risk difficult to diagnose errors in higher levels of the
software stack that may impede overall device usability and debuggability.</p>
<p>These properties have led to slow but incremental expansion of host firmware advancements over time.</p>
<p><img src="./media/uefi_evolution.png" alt="Host FW Evolution" /></p>
<h3 id="importance-of-security-in-firmware"><a class="header" href="#importance-of-security-in-firmware">Importance of Security in Firmware</a></h3>
<p>From a security perspective, firmware is an important component in the overall system Trusted Computing Base (TCB).
Fundamental security features taken for granted in later system software such as kernels and hypervisors are often
based on secure establishment in a lower layer of firmware. At the root is a concept of "trust".</p>
<p>While operating systems are attractive targets due to their ubiquity across devices and scale, attackers are
are increasingly viewing firmware as an attack surface in response to increasingly effective security measures
being applied in modern operating systems. While significant research has been devoted across the entire boot process,
UEFI firmware on the host CPU presents a unique opportunity to gain more visibility into early code execution details
and intercept the boot process before essential activities take place such as application of important security register
locks, cache/memory/DMA protections, isolated memory regions, etc. The result is code executed in this timeframe must
carry forward proper verification and measurement of future code while also ensuring it does not introduce a
vulnerability in its own execution.</p>
<h3 id="performance-reliability-in-firmware"><a class="header" href="#performance-reliability-in-firmware">Performance Reliability in Firmware</a></h3>
<p>From a performance perspective, firmware code is often expected to execute exceedingly fast. The ultimate goal is for
an end user to not even be aware such code is present. In a consumer device scenario, a user expects to press a power
button and immediately receive confirmation their system is working properly. In a server scenario, fleet uptime is
paramount. Poorly written firmware can lead to long boot times that impact virtual machine responsiveness and workload
scaling or, even worse, Denial of Service if the system fails to boot entirely. In an embedded scenario, government
regulations may require firmware to execute fast enough to show a backup camera within a fixed amount of time.</p>
<p>All of this is to illustrate that firmware must perform important work in a diverse set of hardware states with code
that is as small as possible and do so quickly and securely. In order to transition implementation spanning millions of
lines of code written in a language developed over 50 years ago requires a unique and compelling alternative.</p>
<h2 id="rust-and-firmware"><a class="header" href="#rust-and-firmware">Rust and Firmware</a></h2>
<p>For these reasons, modern PC firmware necessitates a powerful language that can support low-level programming with
maximum performance, reliability, and safety. While C has provided the flexibility needed to implement relatively
efficient firmware code, it has failed to prevent recurring problems around memory safety.</p>
<h3 id="stringent-safety"><a class="header" href="#stringent-safety">Stringent Safety</a></h3>
<p>Common pitfalls in C such as null pointer dereferences, buffer and stack overflows, and pointer mismanagement continue
to be at the root of high impact firmware vulnerabilities. These issues are especially impactful if they compromise
the system TCB. Rust is compelling for UEFI firmware development because it is designed around strong memory safety
without the usual overhead of a garbage collector. In addition, it enforces stringent type safety and concurrency rules
that prevent the types of issues that often lead to subtle bugs in low-level software development.</p>
<p>Languages aside, UEFI firmware has greatly fallen behind other system software in its adoption of basic memory
vulnerability mitigation techniques. For example, data execution protection, heap and stack guards, stack cookies,
and null pointer dereference detection is not present in the vast majority of UEFI firmware today. More advanced
(but long time) techniques such as Address Space Layout Randomization (ASLR), forward-edge control flow integrity
technologies such as x86 Control Flow Enforcement (CET) Indirect Branch Tracking (IBT) or Arm Branch Target
Identification (BTI) instructions, structured exception handling, and similar technologies are completely absent in
most UEFI firmware today. This of course exacerbates errors commonly made as a result of poor language safety.</p>
<p>Given firmware code also runs in contexts with high privilege level such as System Management Mode (SMM) in x86,
implementation errors can be elevated by attackers to gain further control over the system and subvert other
protections.</p>
<h3 id="developer-productivity"><a class="header" href="#developer-productivity">Developer Productivity</a></h3>
<p>The Rust ecosystem brings more than just safety. As a modern language firmware development can now participate
in concepts and communities typically closed to firmware developers. For example:</p>
<ul>
<li>
<p>Higher level multi-paradigm programming concepts such as those borrowed from functional programming in addition to
productive polymorphism features such as generics and traits.</p>
</li>
<li>
<p>Safety guarantees that prevent errors and reduce the need for a myriad of static analysis tools with flexibility to
still work around restrictions when needed in an organized and well understood way (unsafe code).</p>
</li>
</ul>
<h3 id="modern-tooling"><a class="header" href="#modern-tooling">Modern Tooling</a></h3>
<p>Rust includes a modern toolchain that is well integrated with the language and ecosystem. This standardizes tooling
fragmented across vendors today and lends more time to firmware development. Examples of tools and community support:</p>
<ul>
<li>
<p>An official package management system with useful tools such as first-class formatters and linters that reduce
project-specific implementations and focus discussion on functional code changes.</p>
</li>
<li>
<p>High quality reusable bundles of code in the form of crates that increase development velocity and engagement with
other domain experts.</p>
</li>
<li>
<p>Useful compilation messages and excellent documentation that can assist during code development.</p>
</li>
</ul>
<p>Rust's interoperability with C code is also useful. This enables a phased adoption pathway where codebases can start
incorporating Rust while still relying upon its extensive pre-existing code. At the same time, Rust has been conscious
of low-level needs and can precisely structure data for C compatibility.</p>
<h2 id="uefi-rust-in-odp"><a class="header" href="#uefi-rust-in-odp">UEFI Rust in ODP</a></h2>
<p>UEFI code in ODP plans to participate within the open Rust development community by:</p>
<ol>
<li>Engaging with the broader Rust community to learn best practices and share low-level system programming knowledge.</li>
<li>Leveraging and contributing back to popular crates and publishing new crates that may be useful to other projects.
<ul>
<li>A general design strategy is to solve common problems in a generic crate that can be shared and then integrate it
back into firmware.</li>
</ul>
</li>
<li>Collaborating with other firmware vendors and the UEFI Forum to share knowledge and best practices and
incorporate elements of memory safety languages like Rust into industry standard specifications where appropriate.
Some specifications have interfaces defined around concepts and practices common in unsafe lanuages that could
be improved for safety and reliability.</li>
</ol>
<p>Looking forward, we're continuing to expand the coverage of our firmware code written in Rust. We are excited to
continue learning more about Rust in collaboration with the community and our partners.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-for-patina"><a class="header" href="#setting-up-for-patina">Setting up for Patina</a></h1>
<p>Patina is based upon the foundations of UEFI, and as such, much of the tooling used to build boot firmware
continues to leverage the existing proven tools from Tianocore, such as the <code>stuart_build</code> set of commands, and many other parts familiar within the EDK II framework.</p>
<p>The steps to setting up the tooling can be found documented in the Readme of the <a href="https://github.com/OpenDevicePartnership/patina-qemu">patina-qemu</a> repository, but what is not immediately clear from that discussion is the role that different repositories play.  This is a bit of a marathon, so we'll walk through it here.</p>
<h3 id="the-repositories-involved"><a class="header" href="#the-repositories-involved">The repositories involved</a></h3>
<p>The full umbrella of ODP material encompassses multiple repositories, because ODP covers several diverse aspects of firmware development that speak to different audiences.  Simililarly, the Patina subsection of ODP itself is maintained in multiple repositories, which ones are utilized by a developer will depend upon the goals and scope of a particular project.</p>
<p>The most common Patina-related repositories are as follows</p>
<ul>
<li>
<p><strong>patina</strong> - This maintains a library of crates that implement UEFI-like code in Rust. This defines all of the reusable
'Patina SDK' components that may be pulled into other workflows (such as <em>patina-dxe-core-qemu</em>) to create customized <code>.efi</code> images.</p>
</li>
<li>
<p><strong>patina-dxe-core-qemu</strong> - This repository holds the code responsible for pulling in reusable Rust DXE Core components from the Patina SDK, combining these with locally defined custom components, and building the resulting <code>.efi</code> image that may be loaded into the QEMU emulator.</p>
</li>
<li>
<p><strong>patina-qemu</strong> - This repository supplies a platform wrapper that loads the <code>.efi</code> firmware into QEMU using EDK build tools (<code>stuart_build</code>) from the <code>.efi</code> file indicated at build time.</p>
</li>
<li>
<p><strong>patina-fw-patcher</strong> - This repository simplifies the iterative turnaround for incremental builds in a workflow, once one has been established, able to forego the full <code>stuart_build</code> process for each code update.</p>
</li>
<li>
<p><strong>patina-mtrr</strong> - This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</p>
</li>
<li>
<p><strong>patina-paging</strong> - Common paging support for various architectures such as ARM64 and X64</p>
</li>
</ul>
<p>In this discussion we will be focused on the steps required to build Patina into a QEMU emulator.  We will be primarily concerned
with the <strong>patina-dxe-core-qemu</strong> and <strong>patina-quemu</strong> repositories for this.</p>
<h2 id="preparing-the-workspace-environment"><a class="header" href="#preparing-the-workspace-environment">Preparing the workspace environment</a></h2>
<p>Much of the steps shown here are restructured from the <a href="https://github.com/OpenDevicePartnership/patina-qemu?tab=readme-ov-file#first-time-tool-setup-instructions-for-this-repository">patina-qemu README</a>, but contains a few additional clarifications.</p>
<p>The end result will be a set of Patina rust-based firmware running as a QEMU hosted emulated platform.  Once this is established, we can work with the firmware ourselves and/or we can target an actual platform board instead of the emulator.  But let's not get ahead of ourselves just yet.  First we need to get things into place.</p>
<h2 id="qemu-q35-package"><a class="header" href="#qemu-q35-package">Qemu Q35 package</a></h2>
<p>In these steps, we will be building an emulated platform based on the Intel Q35 chipset. This will demonstrate the Patina UEFI firmware development for x86/64.  The patina-qemu repository also has support for an ARM architecture. Refer there for more information.</p>
<h2 id="preparing-for-stuart"><a class="header" href="#preparing-for-stuart">Preparing for "Stuart"</a></h2>
<p>The EDK II build tool, <code>Stuart</code>, is duplicated in the patina-qemu repository and further leveraged by specific platform build scripts.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>But before we go there, we need to make sure we have Python installed.
For Windows, download the <a href="https://www.python.org/downloads/windows/">official Python installer</a></p>
<p>(For Linux or MacOS, consult available sources for installing Python for your platform).</p>
<p>The installer should install both <code>python</code> and <code>py</code> (python launcher).  Test your installation with</p>
<pre><code>py -0
</code></pre>
<p>This should list the available python versions, and</p>
<pre><code>python --version
</code></pre>
<p>should verify your default python version is available.</p>
<h3 id="patina-qemu"><a class="header" href="#patina-qemu">patina-qemu</a></h3>
<p>Now to get on with building the "Stuart" tools:</p>
<p>Start by cloning the patina-quemu repository to your workspace.</p>
<pre><code>git clone git@github.com:OpenDevicePartnership/patina-qemu.git
</code></pre>
<p>and then we are going to establish a virtual python environment in this space and use it to build the tools.</p>
<p>(Windows)</p>
<pre><code>cd edk2
py -m venv .venv
.venv\Scripts\activate.bat
pip install -r pip-requirements.txt --upgrade
stuart_setup -c .pytool/CISettings.py
</code></pre>
<h2 id="patina-qemu-1"><a class="header" href="#patina-qemu-1">Patina-qemu</a></h2>
<p>Now we are equipped to build from the patina-qemu repository.
Start by cloning the patina-quemu repository to your workspace.</p>
<pre><code>git clone git@github.com:OpenDevicePartnership/patina-qemu.git
</code></pre>
<h3 id="shorten-the-path"><a class="header" href="#shorten-the-path">Shorten the path</a></h3>
<p>On Windows, the build commands reference pathnames that when combined can exceed the maximum allowed path length, so to prevent issues here, we will redirect where we work so that our paths are shorter.</p>
<p>Do this from within the patina-quemu repository root directory:</p>
<pre><code>cd
&lt;this will show you the full path of the repository root, where you are&gt;
subst z: &lt;full path shown above&gt;

cd z:\
z:
</code></pre>
<p>now you should be able to treat your Z:\ location the same as your repository root, but the resulting path names will be shorter.</p>
<h3 id="preparing-and-building"><a class="header" href="#preparing-and-building">Preparing and Building</a></h3>
<p>(from within your new Z:\ location)</p>
<pre><code># Create a Python virtual environment for this workspace
py -e -m venv patina.venv 
# and then activate it
.\patina.venv\Scripts\activate.bat
</code></pre>
<p>Note that there is <code>activate.bat</code> (for cmd) and <code>Activate.ps1</code> (for PowerShell).  Use the one that matches your console shell.</p>
<p>Now install the python dependencies:</p>
<pre><code>pip install --upgrade -r pip-requirements.txt
</code></pre>
<p>Then use the Stuart tools to setup and build:</p>
<pre><code>stuart_setup -c Platforms\QemuQ35Pkg\PlatformBuild.py
stuart_upgrade -c Platforms\QemuQ35Pkg\PlatformBuild.py

</code></pre>
<h3 id="first-and-subsequent-setup"><a class="header" href="#first-and-subsequent-setup">First and subsequent setup</a></h3>
<p>The steps above will create a virtual python environment and install the stuart tools into it.
You should only need to do these steps the one time for your workspace.
On subsequent visits, simply activate the virtual environment again (<code>.\patina.venv\Scripts\activate.bat</code>)
and then proceed with the build and/or run steps.</p>
<p>To build and install into QEMU, include the --FlashRom argument:</p>
<pre><code>stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --FlashRom
</code></pre>
<p>building will take several minutes.  At the end of this you should see a QEMU window that shows a brief splash graphic and then a shell prompt and output showing success.</p>
<p>You will also see a long train of runtime debug output to the console window.  This will exceed the scroll-back buffer of the window so you won't be able to see the first portion of it.  The tail end of this runtime log will likely contain a number of TRACE level warnings at this stage.  We can ignore this output at this time.</p>
<p>To build without running on QEMU, leave off the <code>--FlashRom</code> flag.</p>
<h3 id="what-did-we-just-build"><a class="header" href="#what-did-we-just-build">What did we just build?</a></h3>
<p>The Patina DXE Core was successfully installed into your QEMU emulator!  But the actual Rust code for that is contained within a prebuilt .efi binary.  Next we will look at the steps you will need to take to update that .efi binary so that <em>your</em> firmware development can be set into place.</p>
<p>Now that the QEMU tooling is ready, let's look at getting a customized Patina core and your own component code onto it with the next steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina-dxe-core-qemu-code"><a class="header" href="#patina-dxe-core-qemu-code">Patina-dxe-core-qemu Code</a></h1>
<p>The <a href="https://github.com/OpenDevicePartnership/patina-dxe-core-qemu">"patina-dxe-core-qemu" repository</a> contains the tooling and build steps needed to combine elements of the patina SDK (maintained in the 'patina' repository) with locally provided component code.</p>
<p>Let's review the component parts of UEFI again at this point:</p>
<p><img src="./media/PI_Boot_Phases.jpg" alt="UEFI Diagram" /></p>
<p>All of these sections can be found covered in the Patina implementation.
The DXE Core (colloquially pronounced "Dixie") is the Driver Execution Environment and where most of the key development for components is centered.<br />
There is also of course the Runtime Services (RT) that continue beyond boot of the OS.
And there are all the parts in between, including security management, transient system load (TSL) handling, logging, boot device selection, and so forth.
There are some key differences between a conventional UEFI implmentation and Patina.
One such difference is there is no traditional EFI Dispatcher.  Instead, the DXE Core is built monolithically using dependency injection for the drivers that are bound to a prescribed function.</p>
<p>Read more about the construction and differences of the Patina code base in the <a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Patina Documentation</a></p>
<h2 id="how-does-this-come-together"><a class="header" href="#how-does-this-come-together">How does this come together?</a></h2>
<p>Within the patina-dxe-core-qemu repository there is a primary file at <code>bin\q35_dxe_core.rs</code> that controls the monolithic construction of the core and its various components. Inpecting this file, we see a key function, <code>Core::defualt()</code> that is the launching point for a number of <code>.with_component()</code> and <code>.with_config()</code> calls chained together to construct the complement of our firmware image.</p>
<p>Patina uses a Dependency-Injection scheme to map components and their configurations into the dispatch mechanism, and this is where the registration comes together.</p>
<h2 id="reviewing-and-finalizing-the-setup"><a class="header" href="#reviewing-and-finalizing-the-setup">Reviewing and finalizing the setup</a></h2>
<p>Before we start constructing our own component, let's take a moment to be sure we are set up properly and understand the steps of the process:</p>
<ol>
<li>We will be making our coding additions within our local patina-dxe-core-qemu repository space, and build it there.</li>
<li>When the code is ready, we will switch to our Z:\ location (which is our alias for the patina-qemu repository root) and build and run the stuart_build process that will construct our emulator image and execute it in QEMU.</li>
</ol>
<h3 id="finalizing-setup"><a class="header" href="#finalizing-setup">Finalizing setup</a></h3>
<p>For the binding in step 2 to work, we need to tell the patina-qemu tools where the <code>.efi</code> target file is, so that it can load it into the emulator.  Let's find out where this is.</p>
<p>from your local patina-dxe-core-qemu root, type <code>cargo make q35</code> this should produce a build with no errors.  Now look in the location <code>target\x86_64-unknown-uefi\debug\</code> and you should see a <code>qemu_q35_dxe_core.efi</code> file created there.
Note the full path to this file, i.e. <code>&lt;your-path-to-repository-root&gt;\target\x86_64-unknown-uefi\debug\qemu_q35_dxe_core.efi</code></p>
<p>Go to your patina-qemu local directory and edit the file <code>Platforms\QemuQ35Pkg\QemuQ35Pkg.fdf</code>.  Around about line 644 you will see a section that looks like this:</p>
<pre><code>FILE DXE_CORE = 23C9322F-2AF2-476A-BC4C-26BC88266C71 {
!if $(TARGET) == RELEASE
  SECTION PE32 = $(DXE_CORE_BINARY_PATH)/release/qemu_q35_dxe_core.efi
!else
  SECTION PE32 = $(DXE_CORE_BINARY_PATH)/debug/qemu_q35_dxe_core.efi
!endif
  SECTION UI = "DxeCore"
}
</code></pre>
<p>This implies that the DXE_CORE_BINARY_PATH environment variable can be used to redirect where the <code>.efi</code> file comes from.<br />
As of this writing, however, the repository code does not behave this way.  Instead, we must change this to a literal path that points to our location.</p>
<p>Change this section to look like this:</p>
<pre><code>FILE DXE_CORE = 23C9322F-2AF2-476A-BC4C-26BC88266C71 {
SECTION PE32 = &lt;your-path-to-repository-root&gt;\target\x86_64-unknown-uefi\debug\qemu_q35_dxe_core.efi
SECTION UI = "DxeCore"
}
</code></pre>
<p>So that it will point to the output where your <code>.efi</code> is being constructed.  Note that we are explicitly referring to the debug (default) build here.  Adjust this path as needed for release builds or other targets.</p>
<h3 id="redirecting-log-output"><a class="header" href="#redirecting-log-output">Redirecting log output</a></h3>
<p>You may recall that when we did our first test run using the default <code>.efi</code> location that the runtime debug log output was output to the console and was too lengthy to see the top portion of. We can redirect the output to go to a file instead, which will allow us to see everything as well as keeping it in a place we can review after each run.</p>
<p>Edit the file <code>Platforms\QemuQ35Pkg\Plugins\QemuRunner.py</code> and look for a line that says  <code>args = "-debugcon stdio"</code> (about line 66) and change this to read <code>args = "-debugcon file:debug.log"</code>.  This will redirect log output to a file "debug.log" in your Z:\ location when run.</p>
<p>Now, still at the Z:\ prompt (activated), type</p>
<pre><code>stuart_build -c Platforms\QemuQ35Pkg/PlatformBuild.py --FlashRom
</code></pre>
<p>Again, this will take several minutes and cover a few phases with lots of console output.
Finally, the QEMU window will appear, display it's splash graphic, identifying text, and shell prompt.</p>
<p>You will find your Z:\debug.log file now populated and containing the run output.</p>
<p>Verify this is from your local build by checking this log.
You should see the log line</p>
<pre><code>INFO - DXE Core Platform Binary v0.3.2
</code></pre>
<p>around about line 900 - 910 or so
<em>note version number may be different</em></p>
<p>This log line is emitted from the <code>bin/q35_dxe_core.rs</code> file of the patina-dxe-core-qemu sources, which is the launch point for the components.</p>
<p>We will create and install our own component in the next exercise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-component"><a class="header" href="#creating-a-component">Creating a component</a></h1>
<p>By this point, we have set up our development workspace between the patina-dxe-core-qemu and the patina-qemu repositories and have them wired together so that the image loaded and run in the QEMU emulator is that which was built from the patina-dxe-core-qemu sources.</p>
<p>Now let's create our own component that we can add to this set.</p>
<p>In the <code>src</code> directory we find a <code>component</code> directory and some other small <code>.rs</code> files. The <code>component</code> directory is where we will be adding our new component.</p>
<h3 id="defining-the-component-code"><a class="header" href="#defining-the-component-code">Defining the component code</a></h3>
<p>Inside the <code>component</code> directory, create a new file named <code>test_component.rs</code> that contains this content:</p>
<pre><code>use log::info;
use patina_sdk::{component::params::Config, error::Result};

#[derive(Default, Clone, Copy)]
pub struct Name(pub &amp;'static str);

pub fn run_test_component(name: Config&lt;Name&gt;) -&gt; Result&lt;()&gt; {
    info!("============= Test Component ===============");
    info!("Hello, {}!", name.0);
    info!("=========================================");
    Ok(())
}
</code></pre>
<p>As you can see, this presents a classic 'hello world' style example, which is all we will need to get started.</p>
<p>It starts by importing (the <code>use</code> statements at the top) the logging support we will use for our message, the Config construct from the patina_sdk that we will use for our parameter, and the classic Rust <code>Result</code> construct.</p>
<p>The function signature for this implementation forms the basis for the dependency injection we will register in the next step.</p>
<h3 id="registering-the-component"><a class="header" href="#registering-the-component">Registering the component</a></h3>
<p>The file <code>bin/q35_dxe_core.rs</code> is the main binding and execution point for the manifest of components that will make up the image.</p>
<p>If we look at this file we will see a Core:default() function is called with a number of <code>with_config()</code> and <code>with_component()</code> calls, along with a few others, chained together. This sets up the components that will be included.
The chain concludes with <code>.start().unwrap()</code>.  We can add our component just prior to this, by inserting the lines</p>
<pre><code>.with_component(test_component::run_test_component)
.with_config(test_component::Name("World"))
</code></pre>
<p>just before the <code>.start()</code> call.</p>
<h3 id="importing-the-component"><a class="header" href="#importing-the-component">importing the component</a></h3>
<p>Of course, before this code can register our component, it must know about it.</p>
<p>We name it as one of the exported components by editing <code>src/q35/component.rs</code> and adding the line <code>pub mod test_component;</code> to this file.</p>
<p>We can then add our import to the list of 'use<code>statements near the top of the</code>bin/q35_dxe_core.rs` file with the line</p>
<pre><code>use qemu_resources:q35::component::test_component;
</code></pre>
<h3 id="removing-other-samples"><a class="header" href="#removing-other-samples">removing other samples</a></h3>
<p><em>(optional)</em>
You may have noticed in the debug.log dispatches to other "hello, world" sample components.  These come from the patina_samples section of the 'patina' repository.  Recall, the 'patina' repository is like a library of prebuilt-crates.  This sample code there is one of these crates, but we don't need to use it.  Let's either comment out or remove the <code>use patina_samples as sc</code> line from the list of <code>use</code> statements and these lines from the Core::default() chain:</p>
<pre><code>.with_config(sc::Name("World")) // Config knob for sc::log_hello
</code></pre>
<pre><code>        .with_component(sc::log_hello) // Example of a function component
        .with_component(sc::HelloStruct("World")) // Example of a struct component
        .with_component(sc::GreetingsEnum::Hello("World")) // Example of a struct component (enum)
        .with_component(sc::GreetingsEnum::Goodbye("World")) // Example of a struct component (enum)
</code></pre>
<p>As this will remove some of the clutter from our example build. We will leave the other components there, and verify that we've added our <code>test_component</code> references.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>We can now build with the command <code>cargo make q35</code></p>
<p>.</p>
<p>Once we have built without errors, switch to Z:\ and run
<code>stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --FlashRom</code></p>
<p>and check the debug.log after it runs.</p>
<p>Search for 'test component' and you should find this:</p>
<pre><code>INFO - DISPATCH_ATTEMPT BEGIN: Id = ["qemu_resources::q35::component::test_component::run_test_component"]
INFO - ============= Test Component ===============
INFO - Hello, World!
INFO - =========================================
INFO - DISPATCH_ATTEMPT END: Id = ["qemu_resources::q35::component::test_component::run_test_component"] Status = [Success]
</code></pre>
<p>Congratulations! you have built and run your first Patina Rust component and executed it as emulated firmware!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-patina-fw-patcher"><a class="header" href="#using-the-patina-fw-patcher">Using the Patina FW Patcher</a></h1>
<p>There is no need to rebuild everything with the Stuart build process each time you make a change in Rust.</p>
<p>The Patina-FW-Patcher is maintained in a repository of the same name: <a href="https://github.com/OpenDevicePartnership/patina-fw-patcher">patina-fw-patcher</a>.  The README there has instructions for use.</p>
<p>There are a couple of ways to efficiently update the firmware build, depending upon the circumstances.</p>
<p>(TODO practical examples)</p>
<p><a href="../../../library.html">Return to Library</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
