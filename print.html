<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ODP Documentation Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODP Documentation Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="open-device-partnership-documentation-guide"><a class="header" href="#open-device-partnership-documentation-guide">Open Device Partnership documentation guide</a></h1>
<p>The purpose of this document is to guide you through an understanding of ODP regardless of where you are starting from or where your interest may lie.</p>
<p>The overall ODP umbrella is quite large and encompassing, and can be tricky to navigate through, so we will try to simplify that journey a little as well as giving direction on which path along the journey might best fit your interest or involvmement.</p>
<p>This document will briefly review the value proposition of ODP and why it is the right technology for the future of firmware development, at the right time.</p>
<p>Then the different 'tracks' of ODP will be explained.  Here, you may find you are interested in only one of these tracks, or you may find you want to learn more about all of them.</p>
<p>Then, what is inside ODP and where to find it is detailed further - this is a good resource for those simply wishing to navigate the maze of contributed repositories that are available and which ones fit together for a given task.</p>
<p>Finally, for developers wishing to know more about how all of this comes together, a series of example implementation exercises are detailed. These can be explored in themselves or toward the end of the example's goal to create a complete virtual laptop that integrates the product of each of the individual exercises into a practical working end result.</p>
<p>You are in control of how you navigate through this guide, whether you proceed through it all one step at a time, or jump into the paths you find most compelling to your interest is entirely up to you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-odp"><a class="header" href="#why-odp">Why ODP?</a></h1>
<p>Modern computing devices are ubiquitous in our lives.  They are integral to multiple aspects of our lives, from our workplace, to our finances, our creative endeavors, and our personal lifestyles.</p>
<p>Computer technology seemingly lept from its cradle a half century ago and never slowed its pace. It is easy to take much of it for granted.</p>
<p>We marvel as the new applications show us increasingly amazing opportunities.  We also recognize and guard against the threats these applications pose to ourselves and society.</p>
<p>And in this heady environment, it is sometimes easy to forget that the "hidden parts" of these computers we use -- the lower-level hardware and firmware -- is often built upon languages and processes that, although having evolved to meet the demands of the time, are reaching the end of their practical sustainability for keeping up with the accelerating pace of the world around us.</p>
<p>What was originally just a "boot layer" and a few K of code for key hardware interfacing is now shouldering the responsibility of securing personal information and behavior patterns that a malicious intruder could use for nefarious purposes.  High-value proprietary algorithms and Artificial Intelligence models are now built into the firmware and must be locked down. An increasing number of "always ready" peripherals, such as the battery and charger, biometric identification mechanisms, network connections, and other concerns are being increasingly handled by independent MCUs that must coordinate with one another and with the host system in a responsive, increasingly complex, yet highly secure manner.</p>
<p>Trying to manage all of this with what has been the status-quo for these concerns in past decades, without memory-safe languages and with a loosely-federated collection of standards and patterns agreed upon by an ad-hoc consortium of vendors is increasingly dangerous and costly.</p>
<p>The Open Device Partnership offers an alternative and a way forward to a more sustainable future that, while still built upon the proven paradigms of the past, boldly rejects the patterns that are known to be costly and ineffective in favor of future-ready, portable, sustainable, and expandable alternatives.</p>
<p>Key to this is the adoption of the programming language Rust as the successor to C. This immediately brings confidence that the code will not be susceptible to programming-error related vulnerabilities that may lead to either costly performance behaviors or be maliciously exploited by opportunistic bad actors. Furthermore, it provides the confidence that code from outside of one's immediate provenance of control may be audited and trusted and ready to join into a firmware construction built upon industry standards.</p>
<p>In the pages ahead, we'll look a little more closely at the advantages of ODP one at a time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Reduce firmware attack surface significantly, and meet modern security expectations using proven tools and patterns.</p>
<h2 id="security-and-trustworthiness-from-the-ground-up"><a class="header" href="#security-and-trustworthiness-from-the-ground-up">Security and Trustworthiness from the Ground Up</a></h2>
<p>Rust is a modern, memory-safe language that mitigates entire classes of vulnerabilities endemic to C memory management, buffer overflows, use-after-free, and so forth by detecting and addressing these issues at compile time -- so there are few if any unpleasant surprises at runtime.</p>
<p>ODP is foundationally centered around Rust and not only embraces these philosophies, it defines patterns that further enhance the memory-safe paradigm, by preventing unauthorized access between ownership domains and guarding against possible malicious intrusions while implementing the proven industry-standard patterns proven in the industry.</p>
<p>Adoption of standards and patterns of DICE and EL2 Hypervisor supported architectures -- from a Rust-driven baseline - enables a hardware-rooted chain of trust across boot phases, aligning with NIST and platform security goals and requirements.</p>
<p>ODP makes component modularity and portability with a transparent provenance a practical and safe proposition by making it feasiable to audit and verify firmware behavior in specifically constrained ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modular-and-composable-firmware-architecture"><a class="header" href="#modular-and-composable-firmware-architecture">Modular and Composable Firmware Architecture</a></h1>
<p>ODP offers Modularity and agility not normally found in the firmware domain.</p>
<p>The buzz and the headlines generated by advances in the computer world typically belong to those
who have created magic at the application layer. As such, this portion of the development community has seen exponential advances in the tooling and languages at their disposal.  This has provided a high level of modulariy and with it, agility, that has become synonymous with the market responsiveness we see in the evolution of our favorite applications.</p>
<p>Firmware development, on the other hand, has generally been mired in the processes of the past, and has
not enjoyed this same level of modularity and agility.</p>
<h2 id="composable-and-portable-component-modules"><a class="header" href="#composable-and-portable-component-modules">Composable and portable component modules</a></h2>
<p>ODP changes that paradigm and raises the tide. It is inspired by modern software engineering practices: composability, dependency injection, testability.</p>
<p>Components (e.g., battery service, serial logging, boot policies) are decoupled and swappable, enabling faster iteration and better maintainability.</p>
<p>Because Rust enforces its memory and safety management guarantees at compile time, tooling such as that found in ODP Patina for example will build a DXE Core monolithically, without the need for an RTOS, and supports a composed modularity paradigm by design, streamlining certification and troubleshooting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-domain-coherence"><a class="header" href="#cross-domain-coherence">Cross-Domain Coherence</a></h1>
<p>ODP is not just a patch atop of old layers.  It is explicitly aligning system layers to reduce duplication, ambiguity, and failure points.</p>
<p>ODP is not just a firmware stack, but a vision that unites the embedded controller, main firmware, and even secure services under a coherent design and tooling approach.</p>
<h2 id="common-patterns-with-clearly-defined-lanes"><a class="header" href="#common-patterns-with-clearly-defined-lanes">Common patterns with clearly defined lanes</a></h2>
<p>Shared services and conventions allow clear division of responsibility between firmware, EC, and OS—while promoting reuse and coordination.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="improved-developer-experience"><a class="header" href="#improved-developer-experience">Improved Developer Experience</a></h1>
<p>ODP reduces developer friction and increases confidence, thus shortening the time to value for the development effort.</p>
<p>Developers can build and test components in isolation (e.g., battery, GPIO, boot timer), aided by QEMU emulation, mocks, and test harnesses.</p>
<p>With tools like patina-fw-patcher, even embedded iterations feel fast and accessible — no need to flash hardware with each development change.</p>
<p>The Rust ecosystem brings built-in unit testing, logging, dependency control (Cargo), and static analysis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sustainability-and-long-term-cost-reduction"><a class="header" href="#sustainability-and-long-term-cost-reduction">Sustainability and Long-Term Cost Reduction</a></h1>
<p>ODP can help cut tech debt at its root by investing in sustainable design by enabling leaner teams and cleaner codebases.</p>
<h2 id="build-right-and-reuse"><a class="header" href="#build-right-and-reuse">Build right and reuse</a></h2>
<p>Replacing legacy code with safer, testable, and reusable modules means lower maintenance costs over time.</p>
<h3 id="hal-separation"><a class="header" href="#hal-separation">HAL separation</a></h3>
<p>The ability to reuse and recompose across product lines (via ODP libraries) reduces the need to "reinvent the wheel" for each board/platform, as Hardware Abstraction Layers can be cleanly isolated from the business logic of a component design, and easily expanded upon for new features.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment-with-industry-trends-and-standards"><a class="header" href="#alignment-with-industry-trends-and-standards">Alignment with Industry Trends and Standards</a></h1>
<p>ODP is forward-facing from its original concept, and embodied in its design.  Adoption of ODP positions you at the forefront of secure, future-facing firmware innovation.</p>
<h3 id="perfectly-timed"><a class="header" href="#perfectly-timed">Perfectly Timed</a></h3>
<p>ODP taps into the growing ecosystem momentum around Rust and embedded standards. Rust adoption at Microsoft, Google, and the Linux kernel reflects a broader industry shift.</p>
<h3 id="open-source-and-collaborative"><a class="header" href="#open-source-and-collaborative">Open Source and Collaborative</a></h3>
<p>ODP Encourages upstream contributions and compliance with modern firmware interfaces (UEFI, ACPI, DICE).</p>
<p>An open collaboration model invites cross-vendor reuse and innovation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Welcome! If you're new to the Open Device Partnership, this is the right place to begin.</p>
<p>If you're also new to the world of Embedded Controllers and the software that drives them, don't worry—you're still in the right place.</p>
<div class="table-wrapper"><table><thead><tr><th> </th><th> </th></tr></thead><tbody>
<tr><td><img src="intro/./media/odp.png" alt="ODP Logo" /></td><td>The Open Device Partnership introduces concepts that are game-changing when it comes to enabling <strong>reuse</strong> and <strong>interchangeability</strong> of Embedded Controller components—especially those found in modern laptops. Just as importantly, it brings a <em>revolutionary focus on security and code safety from the ground up</em>.</td></tr>
</tbody></table>
</div>
<p>                                                            <img src="intro/./media/rust_logo.png" alt="ODP Logo" /></p>
<p>To support this, ODP is designed to use <strong>Rust</strong> as the implementation language.</p>
<p>If you're coming from a C or assembly background, you may feel some initial resistance to learning a new language and unfamiliar patterns. That’s understandable.</p>
<p>But let’s face it: while it's <em>certainly possible</em> to write memory-safe and secure code in C, it's also very easy to make mistakes. With Rust, you'd have to work pretty hard to write unsafe code that even compiles.</p>
<p>As new standards—and potentially even government regulations—begin to push for memory-safe languages in critical systems, the Open Device Partnership aims to be ahead of the curve by bringing that future into the present.</p>
<p>Let's start by familiarizing ourselves with Rust (if you are not already),
then we will get a high-level understanding of ODP Concepts in the <a href="intro/./Concepts.html">Concepts</a> section, which explains how the various pieces fit together.</p>
<p>One you've familiarized yourself with the fundamentals of Rust and the concepts and scope of ODP, you are ready to explore the ODP tracks and the repositories that support each track or to dive deep into practical examples in building your own firmware components that you can later use to build your own laptop.</p>
<p>Continue on to learn the concepts, or jump ahead to choose which <a href="intro/../tracks.html">ODP track</a> you will follow next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>The core firmware of a modern computing device is much more sophisticated than it was a couple of decades ago.
What started out on early computers as the Basic Input-Output System (BIOS) firmware that allowed keyboard input, clock support, and maybe serial terminal output designed to give the most rudimentary of control to a system before it has the opportunity to load the operating system, as well as the initial bootstrap loader to bring that onboard, has grown into an orchestration of individual microcontroller-driven subsystems that manage a variety of input devices, cryptography subsystems,
basic networking, power management, and even proprietary AI models.</p>
<p>Beyond handling the boot-time tasks, some of this lower-level firmware is meant to run autonomously in the background to monitor and adjust to operating conditions.  For example, a thermal control subsystem will take measures to cool the computer if the CPU temperature exceeds optimal levels, or a battery charging subsystem must correctly detect when the power cord has been plugged in or removed and execute the steps necessary to charge the system.  Such tasks are generally controlled by one or more Embedded Controllers, oftentimes found as a single System-on-Chip (SOC) construction.</p>
<p>Embedded Controllers are the unsung heroes of the modern laptop, quietly handling power management, thermal control,
battery charging, lid sensors, keyboard scan matrices, and sometimes even security functions.
There's a surprising amount of complexity tucked away in that little chip.</p>
<p>The drivers and handlers responsible for managing these subsystems must be secure, reliable, and easy to adopt with confidence.
This calls for a standardized, community-moderated approach—one that still leaves room for innovation and platform-specific
differentiation.</p>
<p>There are many proven standards that define and govern the development of this firmware.
For example, <strong>UEFI</strong> (<em>Unified Extensible Firmware Interface</em>) defines a standard for boot-level firmware in a series of layers, and <strong>DICE</strong> (Device Identity Composition Engine) defines a standard for cryptographic verification of firmware components for a security layer.</p>
<p>Hardware components issue events or respond to signals transmitted over data buses such as eSPI,UART, I2C/I3C. These signals
are monitored or driven by firmware, forming the basis for orchestrating and governing hardware behavior</p>
<p>Historically, much of this firmware has been vendor-supplied and tightly coupled to specific EC or boot hardware. It's often written in C or even assembly, and may be vulnerable to memory-unsafe operations or unintended behavior introduced by seemingly harmless changes.</p>
<p>The Open Device Partnership doesn't replace the former standards, but it defines a pattern for implementing this architecture in Rust.</p>
<p>As computing devices grow more complex and user data becomes increasingly sensitive, the need for provable safety
and security becomes critical.</p>
<p>Rust offers a compelling alternative. As a systems programming language with memory safety at its core, Rust enables secure,
low-level code without the tradeoffs typically associated with manual memory management.
It’s a natural fit for Embedded Controller development—today and into the future.</p>
<p>Abstraction and normalization are key goals. OEMs often integrate components from multiple vendors and must adapt quickly
when supply chains change. Rewriting integration logic for each vendor’s firmware is costly and error-prone.</p>
<p>By adopting ODP’s patterns, only the HAL layer typically needs to be updated when switching hardware components.
The higher-level logic—what the system does with the component—remains unchanged</p>
<p>Instead, if the ODP patterns have been adopted, all that really needs to change is the HAL mapping layers that describe how the hardware action and data signals are defined
and the higher-level business logic of handling that component can remain the same.</p>
<p>ODP is independent of any runtime or RTOS dependency.  Asynchronous support is provided by packages such as
the <a href="https://embassy.dev/">Embassy</a> framework for embedded systems.
Embassy provides key building blocks like Hardware Abstraction Layers (HALs), consistent timing models, and support for both asynchronous and blocking execution modes.</p>
<h3 id="so-how-does-this-work"><a class="header" href="#so-how-does-this-work">So how does this work?</a></h3>
<p>A Rust crate defines the component behavior by implementing hardware pin traits provided by the target microcontroller's HAL
(possibly via Embassy or a compatible interface). These traits are optionally normalized to <a href="https://en.wikipedia.org/wiki/ACPI">ACPI</a> (Advanced Configuration and
Power Interface) and ASL (ACPI Source Language) standards to align with common host-side expectations.</p>
<p>From there, the system moves into a familiar abstraction pattern. The HAL exposes actions on those pins
(such as read() or write()), and the service logic builds higher-level operations (like read_temperature() or set_fan_speed(x))
using those primitives.</p>
<pre class="mermaid">flowchart LR
Controller(Controller) --&gt; PinTrait(Pin Traits) --&gt; ASL(ASL) --&gt; HAL(HAL interface) --&gt; Fun(Functional Interface) --&gt; Code(Code action)
style Controller fill:#8C8
style PinTrait fill:#8C8
</pre>
<p>In the case of a controller being switched out, assuming both controllers perform the same basic
functionality (e.g. read temperature, set fan speed) only the pin traits specific to the controller
likely need to be changed to implement with similar behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-quick-look-at-rust"><a class="header" href="#a-quick-look-at-rust">A quick look at Rust</a></h1>
<p>If you are new to Rust, the venerable "Rust Book" is probably your best bet:
<a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></p>
<p>and a great sandbox to play in while learning can be found at <a href="https://play.rust-lang.org/">The Rust Playground</a></p>
<h3 id="but-before--you-run-off-to-do-that"><a class="header" href="#but-before--you-run-off-to-do-that">But before  you run off to do that...</a></h3>
<p>Let's look a little at what Rust has to offer first.</p>
<p><em><strong>The basics are very important to learn because Rust builds on itself and the advanced features are made possible by
leveraging the advantages of the basic ones.  Most of these have to do with the type and memory safety models that are fundamental to the Rust proposition.</strong></em></p>
<p>There are several parts to the rust toolchain that you should be aware of to start.</p>
<h3 id="cargo"><a class="header" href="#cargo">cargo</a></h3>
<p>Cargo is an all-around utility player for the rust environment.  It is many things:</p>
<ul>
<li>a build manager</li>
<li>a package manager</li>
<li>a linter / static analyzer</li>
<li>a documentation engine</li>
<li>a test runner</li>
<li>an extensible system driven by installed modules</li>
</ul>
<h3 id="rustup"><a class="header" href="#rustup">rustup</a></h3>
<p>While Cargo is your go-to player for building with a toolchain, <code>rustup</code> is used to setup and modify the toolchain for different needs.</p>
<p>Among its other uses, you may want to familiarize yourself with <code>rustup doc</code> which will open a locally-sourced web book for Rust documentation that can be used offline.</p>
<h3 id="rustc"><a class="header" href="#rustc">rustc</a></h3>
<p>Rust is a highly optimized compiled language. It's compiler is called <code>rustc</code>.</p>
<p>Typically <code>rustc</code> is not invoked directly; it is usually invoked with <code>cargo build</code></p>
<p>The compiler is thorough and strict by design.  Clean code is required on your part. Unused variables or mis-assigned variable types will result in compile errors.</p>
<ul>
<li>The compiler controls and understands memory allocation and deallocation</li>
<li>It tracks borrows/references (borrow checking)</li>
<li>Expands macros</li>
</ul>
<p>Although some might accuse the Rust compiler of being deliberately unforgiving and opinionated, it is not heartless.  It will tell you when you've done something wrong, and it will ask for additional information if it can't figure it out on its own (type, lifetime of borrowed values, etc)</p>
<h4 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h4>
<pre><code>- Like many languages, Rust is primarily an expression-based language, where an expression produces a result or an effect.
- Multiple expression types:
    - Literal
    - Path
    - Block
    - Operator
    - Struct
    - Tuple
    - Method
    - Closure
    - etc
- Expressions may be nested and obey an evaluation ordering

```
let y = 5;
let y = { let x = 5; x + 6; };
```
</code></pre>
<h4 id="variable-binding-and-ownership"><a class="header" href="#variable-binding-and-ownership">Variable binding and ownership</a></h4>
<p>In other languages, a "let" statement specifies an assignment.
In Rust, a "let" statement creates a variable binding. At first glance, this may seem the same, but there are important differences. A variable binding includes:</p>
<ul>
<li>Name of the binding</li>
<li>Whether or not the value is mutable (default is false)</li>
<li>The type of the value (based on type annotations, inferred by the compiler
or default associated with literal expression)​</li>
<li>A value or backing resource (memory allocated on stack or heap)​</li>
<li>Whether or not this binding "owns" the value.</li>
</ul>
<h4 id="binding-examples-primitive-types"><a class="header" href="#binding-examples-primitive-types">Binding examples (Primitive types)</a></h4>
<pre><code>fn main() {​
   // name: x, mutable: false, type: i32, value: 5 (stack), owner: true​
   let _x = 5;​
​
   // same result except with explicit type annotation of i32​
   let _x: i32 = 5; ​
​
   // now with unsigned integer​
   let _x: u32 = 5; ​
​
   //now mutable​
   let mut _x: u32 = 5; ​

   // creates 2 immutable variable bindings for x and y ​
   // using a tuple expression with integer literal expressions 1 and 2​
   let (_x, _y) = (1, 2); ​
​
   // now x &amp; y are mutable​
   let (mut _x, mut _y) = (1, 2); ​
}
</code></pre>
<h4 id="copy-semantics-and-move-semantics"><a class="header" href="#copy-semantics-and-move-semantics">Copy semantics and Move semantics</a></h4>
<p>Consider this code:</p>
<pre><code>fn copy_semantics() {​
    let x = 5;​
    let y = x;​
}
</code></pre>
<p>This binds the value 5 to 'x' and then binds the value of 'x' to 'y'.  So, in the end x == 5 and y == 5.
No surprise there, but it should be understood that this is true because the primitive types for this implement the "Copy" trait that allows this.</p>
<p>Now let's look at another bit of code</p>
<pre><code>fn move_semantics() {
    // String does not implement the copy trait... ​

    let message = String::from("hello Rustaceans");
    let mut _hello = message;


    println!("{}", message);
}
</code></pre>
<p>If your run this code in the Rust Playground you will see the following output:</p>
<pre><code>Exited with status 101

error[E0382]: borrow of moved value: `message`
 --&gt; src/main.rs:8:20
  |
4 |     let message = String::from("hello Rustaceans");
  |         ------- move occurs because `message` has type `String`, which does not implement the `Copy` trait
5 |     let mut _hello = message;
  |                      ------- value moved here
...
8 |     println!("{}", message);
  |                    ^^^^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
5 |     let mut _hello = message.clone();
  |                             ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground` (bin "playground") due to 1 previous error

</code></pre>
<p>Types that implement the Copy trait (like integers and booleans) are duplicated on assignment. For other types, ownership is transferred.</p>
<p>Simple primitive types implement the Copy trait — a marker trait indicating that values of a type can be duplicated with a simple bitwise copy</p>
<p>So you can see, the rust compiler, despite being picky, is very helpful.  It explains exactly what is happening here:</p>
<p>String does not implement the "Copy" trait, so an assignent 'moves' the value from 'message' to '_hello' so that when we try to
reference 'message' later in the print macro, we see the value is no longer there.  It even suggests some possible alternatives we might try.</p>
<h4 id="allocating-deallocating-and-scope"><a class="header" href="#allocating-deallocating-and-scope">Allocating, Deallocating, and scope</a></h4>
<ul>
<li>Memory is allocated when the result of an expression is assigned to a variable binding</li>
<li>Memory is deallocated when the variable binding that is the owner of the value goes out of scope</li>
<li>For non-primitive types (on the heap), you may call the <code>drop</code> function (trait) for resources that <em>you</em> control the lifetime scope for.</li>
<li>The drop trait should be custom implemented for resource types that have specific destructor needs.</li>
<li>Rust calls drop() automatically when a value goes out of scope, but you can override it via the Drop trait if your type needs custom cleanup logic (e.g. closing a file or freeing a resource).</li>
</ul>
<h4 id="rust-ownership-rules"><a class="header" href="#rust-ownership-rules">Rust ownership rules</a></h4>
<ul>
<li>Each value in rust has an owner (from a variable binding)</li>
<li>There can only be <strong>one</strong> owner at a time</li>
<li>When an owner goes out of scope, the value will be dropped.</li>
</ul>
<h4 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h4>
<p>Borrowing is the term used for a copy-by-reference. For example:</p>
<pre><code>fn borrowing() {​
    let mut x: String = String::from("asdf");​
​
    // Borrow is a verb… Borrowing a value from the owner​
    // The result of a borrow is a reference; below an immutable reference​
    let _y: &amp;String = &amp;x; ​
    // name: y, mutable: false, type: String, value: -&gt; x, owner: false; an immutable reference​

    // Mutable borrow... the variable binding you are borrowing must be mutable​
    let _z: &amp;mut String = &amp;mut x;​
    // name: z, mutable: true, type: String, value: -&gt; x, owner: false; a mutable reference​

    // You can borrow values stored on the heap or on the stack​
    let n: i32 = 5;​
    let _z: &amp;i32 = &amp;n; //is valid… same rules apply as for complex types​
}
</code></pre>
<h5 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h5>
<ul>
<li>Only 1 <em>mutable</em> borrow/reference at a time</li>
<li>As many <em>immutable</em> borrows as you like</li>
<li>If you have 1 or more immutable borrows and 1 mutable borrow, attempting to use any of the immutable borrows <em>after the value
has changed</em> will result in a compile error</li>
</ul>
<p>Rust uses lifetimes to ensure that borrowed references don’t outlive the data they point to. While often inferred by the compiler, they become important in more advanced usage.</p>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Rust functions look much like function definitions from other languages.  Here's some examples:</p>
<pre><code>// A function that takes no parameters returns no useable result (unit type)​
fn do_something() -&gt; () {}​

// equivalent to above… more typical​
fn do_something() {} ​

// this returns an i32 with value 3… ​
// remember return statement is not needed… just leave off the semi-colon​
fn get_three()-&gt; i32 {​
    3​
}​
</code></pre>
<ul>
<li>The function starts with <code>fn</code>.</li>
<li>Rust style conventions prefer "snake case" (underscore separated lowercase words) style for the function name.</li>
<li>Functions take parameters which are listed within parenthesis following the function name.</li>
<li>Functions that return a type denote their return type with -&gt; <code>&lt;type&gt;</code> after the parameter list.</li>
<li>The function body is within { } brackets.</li>
<li>The result of the last expression executed becomes the return value if no 'return' keyword is encountered.</li>
<li>The return type () is called the unit type — it’s like void in C/C++, representing ‘no meaningful value’.</li>
</ul>
<h4 id="function-parameters"><a class="header" href="#function-parameters">Function parameters</a></h4>
<ul>
<li>parameters must have a type annotation</li>
<li>all parameters will be copied, moved, or borrowed from their origins and delivered into the scope of the function (the parameter definition should indicate if they expect a borrow/reference, or an actual value).</li>
</ul>
<pre><code>fn do_some_things(x: i32, y: String, z: &amp;String, a: &amp;mut String) {}​
</code></pre>
<ul>
<li>x will be a copied value (from i32 primitive)</li>
<li>y will be a moved value (from the string)</li>
<li>z will be an immutable borrowed reference</li>
<li>a will be a mutable borrowed reference</li>
</ul>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<ul>
<li>Tuples are primitive types that contain a finite sequence ​</li>
<li>Tuples are heterogenous, the sequence does not need to be of the same type​</li>
<li>Tuples are a convenient way of returning multiple results from a function​</li>
<li>Tuples are often used with enums to associate one or more values with an enum variant​</li>
</ul>
<p><em>example:</em></p>
<pre><code>let x: (&amp;str,i32, char) = ("hello", 42, 'c')
</code></pre>
<p>In the example we define a tuple consisting of three element types: A string reference, a 32-bit integer, and a character. Then we assign literal values for this tuple definition to the binding variable 'x'.</p>
<h4 id="struct"><a class="header" href="#struct">Struct</a></h4>
<p>A Struct (structure) in Rust is much like a structure definition in several other languages.</p>
<p>For example:</p>
<pre><code>struct Example
{
    foo: String,
    bar: i32,
    baz: bool
}
</code></pre>
<p>There is also the concept of a 'tuple struct' which is a convenient way to give a name to a tuple that can be treated like a structure, such as the Tuple example we visited above:</p>
<pre><code>struct MyTupleStruct(&amp;String, i32, char)
</code></pre>
<p>Remember, tuples can have any number of elements in the sequence.</p>
<h4 id="enum-option-and-result"><a class="header" href="#enum-option-and-result">Enum, Option, and Result</a></h4>
<p>An enum is a way of saying that a value is one from a set of possible values.  Most languages have some form of enum, but Rust
has an particularly robust level of support around this construct.</p>
<p>Consider this example from the "Rust Book":</p>
<pre><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
<p>One can imagine "Message" being used to direct some operation to do one of the four listed things.  But note that each of these "directives" has annotations to describe the associated data type that accompany it.  "Quit" needs no parameters, "Move" comes with structured data for x and y, "Write" is passed a String, and "ChangeColor" gets a Tuple.</p>
<h5 id="option"><a class="header" href="#option">Option</a></h5>
<p>Option is a way to handle Null values in a way a little different from some other languages.  An Option is basically a way to say that something has a value or it has no value (Some or None). Option is an enum that is part of the standard Rust library.
Since <code>Option&lt;T&gt;</code> is not the same type as <code>T</code>, the compiler will not allow an evaluation of a possible Null value.
You can also use the <code>is_some()</code> and <code>is_none()</code> functions of an option to determine if it has a value.</p>
<h5 id="result"><a class="header" href="#result">Result</a></h5>
<p>Where Option is the state of "Some or None" Result is the state of "Ok or Err".</p>
<p><code>Option&lt;T&gt;</code> is used when a value may or may not be present. <code>Result&lt;T, E&gt;</code> is used when a function may succeed (Ok) or fail (Err). Both are enums and must be handled explicitly.</p>
<p>Any operation or function that is executed
may potentially fail, and Rust does not employ any sort of try/catch or "on_error" redirections found in other languages.
Error conditions are a fact of life and as such are part of the result of doing something. Getting used to evaluating the return value of a function operation may seem annoying at first, but it is actually pretty liberating because it generally simplifies error handling.</p>
<p>Let's consider this function:</p>
<pre><code>fn do_something() -&gt; Result&lt;String, std::io::Error&gt; {
    let x:String = "hooray".to_string();
    return Ok(x);
}
</code></pre>
<p>We can see this function returns the "Ok" result (we don't create an error case in this example).
Of course, unless we explicitly documented it, the caller has no idea there will not be an error, so it handles it like so:</p>
<pre><code>fn main() {
    
    let x = do_something();
    let y = match x {
        Ok(s) =&gt; s,
        Err(_e) =&gt; panic!("Oh noes!")
    };
    println!("{}", y);
}
</code></pre>
<p>The error case never occurs, but if it did, it would probably be inadvisable to simply call panic! as a result. Of course, sometimes
there are no good choices, but especially in firmware driver code, casually throwing panic! exceptions is not a good idea.</p>
<p>On that note, you will encounter a lot of sample code from the web and elsewhere that simply advise calling <code>.unwrap()</code> on an option or a result. While often used in examples or quick scripts, relying on .unwrap() in production firmware is discouraged. Define errors explicitly and handle them deliberately.</p>
<h4 id="functions-and-methods-for-user-defined-types"><a class="header" href="#functions-and-methods-for-user-defined-types">Functions and methods for user defined types</a></h4>
<p>User define types include enums, structs, and  union</p>
<pre><code>impl Student {​

    fn new_with_username_email(username: String, email: String) -&gt; Self {​
        Student {​
            active_enrollment: true,​
            username,​
            email​
        }​
    }​
    //method – with methods you add special parameter…  ​
    //a variable binding to “self”.  This binding can be mutable or //immutable​\
    fn get_username(&amp;self) -&gt; String { self.username }​
    fn get_student(email: &amp;str) -&gt; Student { //query db, return student }​
}
</code></pre>
<p><code>impl</code> blocks let you associate methods with a type. Methods that take &amp;self or &amp;mut self operate on an instance, while functions without self are typically constructors or associated functions.</p>
<h4 id="common-construction--initialization-patterns"><a class="header" href="#common-construction--initialization-patterns">Common construction / initialization patterns</a></h4>
<ul>
<li>"new" function</li>
<li>Default trait</li>
</ul>
<pre><code>impl Default for Student {​
    fn default() -&gt; Self {​
        Student {​
            active_enrollment: true, ​
            username: String::default(), ​
            email: String::new()​
        }​
    }​
}
</code></pre>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>This introduction to key concepts of Rust just touches the surface of the Rust language itself, not to mention the extended ecosystem and community that surrounds it.</p>
<p>The goal of this introduction has been to introduce the <em>fundamental safety and ownership guarantees</em> Rust builds into its core design to alleviate some of the shortcomings that other languages often suffer from.  These fundamentals are keystones to understanding the logic behind the rest of the language.</p>
<p><strong>Don't stop here</strong>:</p>
<ul>
<li>visit <a href="intro/concepts/rust-lang.org">Learn Rust - Rust Programming Language</a> and learn the language!</li>
<li>check out <a href="https://crates.io/">crates.io</a> for a taste of the many thousand 3rd-party packages (crates) that you can import for your project</li>
<li>Use the <a href="https://play.rust-lang.org">playground</a> to experiment as you learn.</li>
<li>for fun extended learning, visit <a href="https://github.com/rust-lang/rustlings">Rustlings</a>, where you get hands-on exercises to break in your muscle memory for writing solid Rust code.</li>
<li>Since you are here, you undoubtedly have an interest in using Rust to write firmware, so you should visit <a href="https://docs.rust-embedded.org/book/">Rust Embedded Book</a> for a relevant introduction to using Rust in an Embedded Development Environment.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina"><a class="header" href="#patina">Patina</a></h1>
<h2 id="boot-firmware"><a class="header" href="#boot-firmware">(Boot Firmware)</a></h2>
<p><em><strong>Patina</strong></em> is the codename for ODP's Rust-based SDK and framework for UEFI-compliant boot firmware development.</p>
<p>It is based upon the venerable <strong>UEFI</strong> standard and doesn't seek to reinvent the process of this well-known
framework, as it necessarily re-implements these familiar patterns in Rust instead of C.</p>
<h3 id="a-review-of-uefi"><a class="header" href="#a-review-of-uefi">A review of UEFI</a></h3>
<p><strong>UEFI</strong> stands for <em>Unified Extensible Firmware Interface</em> and can be described as broken into a series of layers, as this diagram shows:</p>
<p><img src="intro/concepts/./images/PI_Boot_Phases.jpg" alt="PI_Boot_phases" />
<em>(diagram source: TianoCore, , illustrating the PI Boot Flow from SEC to RT phase)</em></p>
<p>This boot-time firmware is executed by the platform main CPU on startup/reset and proceeds through the stages shown in the diagram.  As part of its initialization, it may communicate with the embedded system microcontrollers that are also under the control of ODP rust drivers to initiate and orchestrate them to a starting state.</p>
<p>While the majority of ODP development focuses on the <strong>DXE</strong> phase, Patina also supports implementation in the <strong>PEI</strong>, <strong>SEC</strong> and other phases.</p>
<p>Some aspects of UEFI, especially those that have already been deprecated, may not be supported under ODP.  These are legacy services, UI facilitators, and some Runtime Support components that either no longer serve a core purpose or can more effectively be implemented in other ways within ODP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-evolution-of-uefi-into-patina-with-rust-and-odp"><a class="header" href="#the-evolution-of-uefi-into-patina-with-rust-and-odp">The Evolution of UEFI into Patina with Rust and ODP</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Firmware and UEFI firmware in particular has long been written in C. Firmware operates in a unique environment to other
system software. It is written to bootstrap a system often at the host CPU reset vector and as part of a chain of
trust established by a hardware rooted immutable root of trust. Modern PC firmware is extraordinarily complex with
little room for error.</p>
<h3 id="firmware-evolution"><a class="header" href="#firmware-evolution">Firmware Evolution</a></h3>
<p>From a functional perspective, firmware must initialize the operating environment of a device. To do so involves
integrating vendor code for dedicated microcontrollers, security engines, individual peripherals, SOC initialization,
and so on. Individual firmware blobs may be located on a number of non-volatile media with very limited capacity. The
firmware must perform its functional tasks successfully or risk difficult to diagnose errors in higher levels of the
software stack that may impede overall device usability and debuggability.</p>
<p>These properties have led to slow but incremental expansion of host firmware advancements over time.</p>
<p><img src="intro/concepts/./images/uefi_evolution.png" alt="Host FW Evolution" /></p>
<h3 id="importance-of-security-in-firmware"><a class="header" href="#importance-of-security-in-firmware">Importance of Security in Firmware</a></h3>
<p>From a security perspective, firmware is an important component in the overall system Trusted Computing Base (TCB).
Fundamental security features taken for granted in later system software such as kernels and hypervisors are often
based on secure establishment in a lower layer of firmware. At the root is a concept of "trust".</p>
<p>While operating systems are attractive targets due to their ubiquity across devices and scale, attackers are
are increasingly viewing firmware as an attack surface in response to increasingly effective security measures
being applied in modern operating systems. While significant research has been devoted across the entire boot process,
UEFI firmware on the host CPU presents a unique opportunity to gain more visibility into early code execution details
and intercept the boot process before essential activities take place such as application of important security register
locks, cache/memory/DMA protections, isolated memory regions, etc. The result is code executed in this timeframe must
carry forward proper verification and measurement of future code while also ensuring it does not introduce a
vulnerability in its own execution.</p>
<h3 id="performance-reliability-in-firmware"><a class="header" href="#performance-reliability-in-firmware">Performance Reliability in Firmware</a></h3>
<p>From a performance perspective, firmware code is often expected to execute exceedingly fast. The ultimate goal is for
an end user to not even be aware such code is present. In a consumer device scenario, a user expects to press a power
button and immediately receive confirmation their system is working properly. In a server scenario, fleet uptime is
paramount. Poorly written firmware can lead to long boot times that impact virtual machine responsiveness and workload
scaling or, even worse, Denial of Service if the system fails to boot entirely. In an embedded scenario, government
regulations may require firmware to execute fast enough to show a backup camera within a fixed amount of time.</p>
<p>All of this is to illustrate that firmware must perform important work in a diverse set of hardware states with code
that is as small as possible and do so quickly and securely. In order to transition implementation spanning millions of
lines of code written in a language developed over 50 years ago requires a unique and compelling alternative.</p>
<h2 id="rust-and-firmware"><a class="header" href="#rust-and-firmware">Rust and Firmware</a></h2>
<p>For these reasons, modern PC firmware necessitates a powerful language that can support low-level programming with
maximum performance, reliability, and safety. While C has provided the flexibility needed to implement relatively
efficient firmware code, it has failed to prevent recurring problems around memory safety.</p>
<h3 id="stringent-safety"><a class="header" href="#stringent-safety">Stringent Safety</a></h3>
<p>Common pitfalls in C such as null pointer dereferences, buffer and stack overflows, and pointer mismanagement continue
to be at the root of high impact firmware vulnerabilities. These issues are especially impactful if they compromise
the system TCB. Rust is compelling for UEFI firmware development because it is designed around strong memory safety
without the usual overhead of a garbage collector. In addition, it enforces stringent type safety and concurrency rules
that prevent the types of issues that often lead to subtle bugs in low-level software development.</p>
<p>Languages aside, UEFI firmware has greatly fallen behind other system software in its adoption of basic memory
vulnerability mitigation techniques. For example, data execution protection, heap and stack guards, stack cookies,
and null pointer dereference detection is not present in the vast majority of UEFI firmware today. More advanced
(but long time) techniques such as Address Space Layout Randomization (ASLR), forward-edge control flow integrity
technologies such as x86 Control Flow Enforcement (CET) Indirect Branch Tracking (IBT) or Arm Branch Target
Identification (BTI) instructions, structured exception handling, and similar technologies are completely absent in
most UEFI firmware today. This of course exacerbates errors commonly made as a result of poor language safety.</p>
<p>Given firmware code also runs in contexts with high privilege level such as System Management Mode (SMM) in x86,
implementation errors can be elevated by attackers to gain further control over the system and subvert other
protections.</p>
<h3 id="developer-productivity"><a class="header" href="#developer-productivity">Developer Productivity</a></h3>
<p>The Rust ecosystem brings more than just safety. As a modern language firmware development can now participate
in concepts and communities typically closed to firmware developers. For example:</p>
<ul>
<li>
<p>Higher level multi-paradigm programming concepts such as those borrowed from functional programming in addition to
productive polymorphism features such as generics and traits.</p>
</li>
<li>
<p>Safety guarantees that prevent errors and reduce the need for a myriad of static analysis tools with flexibility to
still work around restrictions when needed in an organized and well understood way (unsafe code).</p>
</li>
</ul>
<h3 id="modern-tooling"><a class="header" href="#modern-tooling">Modern Tooling</a></h3>
<p>Rust includes a modern toolchain that is well integrated with the language and ecosystem. This standardizes tooling
fragmented across vendors today and lends more time to firmware development. Examples of tools and community support:</p>
<ul>
<li>
<p>An official package management system with useful tools such as first-class formatters and linters that reduce
project-specific implementations and focus discussion on functional code changes.</p>
</li>
<li>
<p>High quality reusable bundles of code in the form of crates that increase development velocity and engagement with
other domain experts.</p>
</li>
<li>
<p>Useful compilation messages and excellent documentation that can assist during code development.</p>
</li>
</ul>
<p>Rust's interoperability with C code is also useful. This enables a phased adoption pathway where codebases can start
incorporating Rust while still relying upon its extensive pre-existing code. At the same time, Rust has been conscious
of low-level needs and can precisely structure data for C compatibility.</p>
<h2 id="uefi-rust-in-odp"><a class="header" href="#uefi-rust-in-odp">UEFI Rust in ODP</a></h2>
<p>UEFI code in ODP plans to participate within the open Rust development community by:</p>
<ol>
<li>Engaging with the broader Rust community to learn best practices and share low-level system programming knowledge.</li>
<li>Leveraging and contributing back to popular crates and publishing new crates that may be useful to other projects.
<ul>
<li>A general design strategy is to solve common problems in a generic crate that can be shared and then integrate it
back into firmware.</li>
</ul>
</li>
<li>Collaborating with other firmware vendors and the UEFI Forum to share knowledge and best practices and
incorporate elements of memory safety languages like Rust into industry standard specifications where appropriate.
Some specifications have interfaces defined around concepts and practices common in unsafe lanuages that could
be improved for safety and reliability.</li>
</ol>
<p>Looking forward, we're continuing to expand the coverage of our firmware code written in Rust. We are excited to
continue learning more about Rust in collaboration with the community and our partners.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="odp-resources-for-uefi"><a class="header" href="#odp-resources-for-uefi">ODP Resources for UEFI</a></h3>
<p>For traditional UEFI development, an SDK called <strong>EDK II</strong> is often used to supply much of the common functionality.</p>
<p>However, the <strong>EDK II</strong> presumes the use of C, and ODP is seeking to replace this potentially insecure code base with Rust for future devices.</p>
<p>ODP features a subproject body of code that represents the elements one might traditionally find within the EDK II, but designed for  Rust.</p>
<p>The official documentation for the Patina track of ODP can be found here:</p>
<p><a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Official Patina Documentation</a></p>
<p>This document covers</p>
<ul>
<li>How to use materials from and contribute to the Open Device Partnership</li>
<li>Development tools you will need, including Rust and other supporting tools</li>
<li>Platform configuration and comparisons to EDK II (which may be familar to experienced UEFI developers)</li>
<li>Coding patterns and standards</li>
<li>Dependencies</li>
<li>Industry background and current state assessments</li>
</ul>
<h3 id="how-patina-compares-to-traditional-uefi-approaches"><a class="header" href="#how-patina-compares-to-traditional-uefi-approaches">How Patina compares to traditional UEFI approaches</a></h3>
<p>There are differences in the ODP approach here in a few areas.  For example, one significant departure is that in ODP there is no traditional SMM (System Management Mode).</p>
<p>SMM is a special-purpose operating mode provided by x86 CPUs (and compatible architectures) for executing highly privileged system-level code, independently of the operating system.</p>
<ul>
<li>
<p>It is triggered by a System Management Interrupt (SMI).</p>
</li>
<li>
<p>Code running in SMM has full control over the system, including memory, I/O, and other hardware.</p>
</li>
<li>
<p>It is isolated: the OS (and even hypervisors) cannot access or interfere with SMM execution or memory (SMRAM).</p>
</li>
</ul>
<p>This may seem more than a little significant at first because SMM is used in key EDK II contexts, including:</p>
<ul>
<li>SmmCore</li>
<li>SmmDriver</li>
<li>SmmCommunication</li>
<li>SmmVariable</li>
</ul>
<p>But there is good reason for this omission:</p>
<p>Traditional SMM is not supported to prevent coupling between the DXE and MM environments. This exclusion extends to so-called 'combined' DXE modules also.
These patterns are error-prone, increase DXE module complexity, and elevate the risk of security vulnerabilities.</p>
<p>Standalone MM should be used instead. The combined drivers have not gained traction in actual implementations due to their lack of compatibility for most practical purposes and further increase the likelihood of coupling between core environments and user error when authoring those modules. The Rust DXE Core focuses on modern use cases and simplification of the overall DXE environment.</p>
<h3 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h3>
<p>In upcoming sections we'll explore how Patina components interact within the DXE Core, how to define UEFI services in Rust, and how to develop real-world DXE drivers using ODP tools. First, we are going to discuss the role of ODP in an Embedded Controller context.  If you are not interested in the EC side of things, you may want to jump directly to the Patina material from the <a href="intro/concepts/../../tracks.html">ODP tracks</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller"><a class="header" href="#embedded-controller">Embedded Controller</a></h1>
<p><img src="intro/concepts/./images/simplified_layers.png" alt="ODP Architecture" /></p>
<p>An Embedded Controller is typically a single SOC (System on Chip) design capable of managing a number of low-level tasks.</p>
<p>These individual tasked components of the SOC are represented by the gold boxes in the diagram. The ODP Support for Embedded Controller development is represented in the diagram in the green boxes, whereas third party support libraries are depicted in blue.</p>
<h2 id="component-modularity"><a class="header" href="#component-modularity">Component modularity</a></h2>
<p>A Component can be thought of as a stack of functionality defined by traits (A trait in Rust is analogous to an interface in other comon languages).
For the functionality defined by the trait definition to interact with the hardware, there must be a HAL (hardware abstraction layer) defined that implements key actions required by the hardware to conduct these tasks.  These HAL actions are then controlled by the functional interface of the component definition.<br />
The component definition is part of a <em>Subsystem</em> of functionality that belongs to a <em>Service</em>.
For example, a Power Policy Service may host several related Subsystems for Battery, Charger, etc.  Each of these Subsystems have Controllers to interact with their corresponding components.  These Controllers are commanded by the Service their Subsystem belongs to, so for example, the power policy service may interrogate the current charge state of the battery. It does so by interrogating the Subsystem Controller which in turn relies upon the interface defined by the component Trait, which finally calls upon the hardware HAL to retrieve the necessary data from the hardware.  This chain of stacked concerns forms a common pattern that allows for agile modularity and flexible portability of components between target contexts.</p>
<p><img src="intro/concepts/..." alt="TODO: Diagram of the above" /></p>
<h2 id="secure-vs-non-secure"><a class="header" href="#secure-vs-non-secure">Secure vs Non-Secure</a></h2>
<p>Communication between Subsystems may be considered to be either a "Secure" channel for data communication or a "Non-Secure" channel. An implementation may use more than one transport for different controller and controller service needs.</p>
<p>Data communication with the embedded controller can be considered an <em>owned interface</em> because it is implemented within the EC architecture itself.  It may also tie into an external communication bus such as SPI or I2C for data exhanges between other MCUs or the host, but for purposes of communicating between its own subsystems, it is an internally implemented construct.</p>
<p>A "Secure" transport is one that can validate and trust the data from the channel, using cryptographic signatures and hypervisor isolation to insure the integrity of the data exchanged between subsystems.
Not all such channels must necessarily be secure, and indeed in some cases depending upon the components used it may not even be possible to secure a channel.  The ODP approach is agnostic to these decisions, and can support either or both patterns of
implementation.</p>
<p>Depending upon the hardware architecture and available supporting features, a secure channel may incorporate strong isolation between individual component subsystems through memory access and paging mechanisms and/or hypervisor control.</p>
<p>Two similar sounding, but different models become known here.  One is SMM, or "System Management Mode". SMM is a high-privilege CPU mode for x86 microcontrollers that EC services can utilize to gain access. To facilitate this, the SMM itself must be secured. This is done as part of the boot time validation and attestation of SMM access policies.  With this in place, EC Services may be accessed by employing a SMM interrupt.</p>
<p>For A deeper dive into what SMM is, see <a href="https://www.microsoft.com/en-us/security/blog/2020/11/12/system-management-mode-deep-dive-how-smm-isolation-hardens-the-platform/?msockid=1c8509b122806f6b2c281c61233a6e3e">How SMM isolation hardens the platform</a></p>
<p>Another term seen about will be "SMC", or "Secure Memory Control", which is a technology often found in ARM-based architectures. In this scheme, memory is divided into secure and non-secure areas that are mutally exclusive of each other,  as well as a narrow section known as "Non-Secure Callable" which is able to call into the "Secure" area from the "Non-Secure" side.</p>
<p>Secure Memory Control concepts are discussed in detail with this document:
<a href="https://developer.arm.com/documentation/100690/0201">TrustZone Technology for Armv8-M Architecture</a></p>
<p>SMM or SMC adoption has design ramifications for EC Services exchanges, but also affects the decisions made around boot firmware, and we'll see these terms again when we look at ODP Patina implementations.</p>
<h3 id="hypervisor-context-multiplexing"><a class="header" href="#hypervisor-context-multiplexing">Hypervisor context multiplexing</a></h3>
<p>Another component of a Secure EC design is the use of a hypervisor to constrain the scope of any given component service to a walled-off virtualization context. One such discussion of such use is detailed <a href="https://www.microsoft.com/en-us/security/blog/2018/06/05/virtualization-based-security-vbs-memory-enclaves-data-protection-through-isolation/?msockid=1c8509b122806f6b2c281c61233a6e3e">in this article</a></p>
<h3 id="the-open-device-partnership-defines"><a class="header" href="#the-open-device-partnership-defines">The Open Device Partnership defines:</a></h3>
<ul>
<li>An "owned interface" that communicates with the underlying hardware via the available data transport .</li>
<li>We can think of this transport as being a channel that is considered either "Secure" or "Non-Secure".</li>
<li>This interface supports business logic for operational abstractions and concrete implementations to manipulate or interrogate the connected hardware component.</li>
<li>The business logic code may rely upon other crates to perform its functions. There are several excellent crates available in the Rust community that may be leveraged, such as <a href="https://embassy.dev/">Embassy</a>.</li>
<li>Synchronous and asynchronous patterns are supported.</li>
<li>No runtime or RTOS dependencies.</li>
</ul>
<p>An implementation may look a little like this:</p>
<p><img src="intro/concepts/./images/odp_arch.png" alt="ODP Arch" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-services"><a class="header" href="#ec-services">EC Services</a></h1>
<p>Embedded controller services are available for the operating system to call for various higher-level purposes dictated by specification.
The Windows Operating system defines some of these standard services for its platform.</p>
<p>These service interfaces include those for:</p>
<ul>
<li>debug services</li>
<li>firmware management services</li>
<li>input management services</li>
<li>oem services</li>
<li>power services</li>
<li>time services</li>
</ul>
<p>Services may be available for operating systems other than Windows.</p>
<p>OEMs may wish to implement their own services as part of their product differentiation.</p>
<h3 id="ec-service-communication-protocols"><a class="header" href="#ec-service-communication-protocols">EC Service communication protocols</a></h3>
<p>With a communication channel protocol established between OS and EC, operating system agents and applications are able to monitor and operate peripheral controllers from application space.</p>
<p>This scope comes with some obvious security ramifications that must be recognized.</p>
<p>Implementations of ODP may be architected for both Secure and Non-Secure system firmware designs, as previously discussed.</p>
<p><img src="intro/concepts/./images/image1.png" alt="Secure Architecture" /></p>
<p>In the diagram above, the dark blue sections are those elements that are part of normal (non-secure) memory space and may be called
from a service interface directly.  As we can see on the Non-Secure side, the ACPI transport channel has access to the EC component implementations either directly or through the FF-A (Firmware Framework Memory Management Protocol).</p>
<h3 id="ff-a"><a class="header" href="#ff-a">FF-A</a></h3>
<p>The Firmware Framework Memory Management Protocol <a href="https://developer.arm.com/documentation/den0140/latest/">(Spec)</a>
describes the relationship of a hypervisor controlling a set of secure memory partitions with configurable access and ownership attributes and the protocol for exchanging information between these virtualized contexts.</p>
<p>FF-A is available for Arm devices only.  A common solution for x64 is still in development. For x64 implementations, use of SMM is employed to orchestrate hypervisor access using the [Hafnium] Rust product.</p>
<p>In a Non-Secure implementation <em>without</em> a hyperviser, the ACPI connected components can potentially change the state within any accessible memory space.  An implementation with a hypervisor cannot.  It may still be considered a "Non-Secure" implementation, however, as the ACPI data itself is unable to be verified for trust.</p>
<p>In a fully "Secure" implementation, controller code is validated at boot time to insure the trust of the data it provides. Additionally, for certain types of data, digital signing and/or encryption may be used on the data exchanged to provide an additional level of trust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-system-implementation"><a class="header" href="#sample-system-implementation">Sample System Implementation</a></h1>
<p>This is short sample implementing a thermal control service interface.
This sample assumes one thermal sensor and one thermal control device accessible via ACPI.
For an ARM implementation, FF-A and Hafnium is assumed.  For x86/x64, an eSPI transport is assumed and direct (Non-Secure) access is made from there.</p>
<h3 id="ffa-device-definition"><a class="header" href="#ffa-device-definition">FFA Device Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(\\_SB_.FFA0) {
  Name(_HID, "MSFT000C")
  OperationRegion(AFFH, FFixedHw, 4, 144)
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }

  // Other components check this to make sure FFA is available
  Method(AVAL, 0, Serialized) {
    Return(One)
  }

  // Register notification events from FFA
  Method(_RNY, 0, Serialized) {
    Return( Package() {
      Package(0x2) { // Events for Management Service
        ToUUID("330c1273-fde5-4757-9819-5b6539037502"),
        Buffer() {0x1,0x0} // Register event 0x1
      },
      Package(0x2) { // Events for Thermal service
        ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"),
        Buffer() {0x1,0x0,0x2,0x0,0x3,0x0} // Register events 0x1, 0x2, 0x3
      },
      Package(0x2) { // Events for input device
        ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),
        Buffer() {0x1,0x0} // Register event 0x1 for LID
      }
    } )
  }

  Method(_NFY, 2, Serialized) {
    // Arg0 == UUID
    // Arg1 == Notify ID
    // Management Service Events

    If(LEqual(ToUUID("330c1273-fde5-4757-9819-5b6539037502"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // Test Notification Event
          Notify(\\_SB.ECT0,0x20)
        }
      }
    }

    // Thermal service events
    If(LEqual(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // Temp crossed low threshold
          Notify(\\_SB.SKIN,0x80)
        }
        Case(2) { // Temp crossed high threshold
          Notify(\\_SB.SKIN,0x81)
        }
        Case(3) { // Critical temperature event
          Notify(\\_SB.SKIN,0x82)
        }
      }
    }

    // Input Device Events
    If(LEqual(ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // LID event
          Notify(\\_SB._LID,0x80)
        }
      }
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-mapped-interface-via-ffa-for-ucsi"><a class="header" href="#memory-mapped-interface-via-ffa-for-ucsi">Memory Mapped Interface via FFA for UCSI</a></h3>
<p>Note for this implementation of memory mapped interface to work the
memory must be marked as reserved by UEFI and not used by the OS and
direct access also given to the corresponding service in secure world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(USBC) {
  Name(_HID,EISAID(“USBC000”))
  Name(_CID,EISAID(“PNP0CA0”))
  Name(_UID,1)
  Name(_DDN, “USB Type-C”)
  Name(_ADR,0x0)
  OperationRegion(USBC, SystemMemory, UCSI_PHYS_MEM, 0x30)
  Field(USBC,AnyAcc,Lock,Preserve)
  {
    // USB C Mailbox Interface
    VERS,16, // PPM-\&gt;OPM Version
    RES, 16, // Reservied
    CCI, 32, // PPM-\&gt;OPM CCI Indicator
    CTRL,64, // OPM-\&gt;PPM Control Messages
    MSGI,128, // OPM-\&gt;PPM Message In
    MSGO,128, // PPM-\&gt;OPM Message Out
  }

  Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
  {

    // Compare passed in UUID to Supported UUID
    If(LEqual(Arg0,ToUUID(“6f8398c2-7ca4-11e4-ad36-631042b5008f”)))
    {
      // Use FFA to send Notification event down to copy data to EC
      If(LEqual(\\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
        CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
        CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
        CreateField(BUFF,16,128,UUID) // UUID of service
        CreateByteField(BUFF,18, CMDD) // In – First byte of command
        CreateField(BUFF,144,1024,FIFD) // Out – Msg data

        // Create Doorbell Event
        Store(20, LENG)
        Store(0x0, CMDD) // UCSI set doorbell
        Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID)
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
      } // End AVAL
    } // End UUID
  } // End DSM
}
<span class="boring">}</span></code></pre></pre>
<h3 id="thermal-acpi-interface-for-ffa"><a class="header" href="#thermal-acpi-interface-for-ffa">Thermal ACPI Interface for FFA</a></h3>
<p>This sample code shows one Microsoft Thermal zone for SKIN and then a
thermal device THRM for implementing customized IO.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sample Definition of FAN ACPI
Device(SKIN) {
  Name(_HID, "MSFT000A")

  Method(_TMP, 0x0, Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(30){})
      CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,TZID) // Temp Sensor ID
      CreateDWordField(BUFF,26,RTMP) // Output Data

      Store(20, LENG)
      Store(0x1, CMDD) // EC_THM_GET_TMP
      Store(0x2, TZID) // Temp zone ID for SKIIN
      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (RTMP)
      }
    }
    Return (Ones)
  }

  // Arg0 Temp sensor ID
  // Arg1 Package with Low and High set points
  Method(THRS,0x2, Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(32){})
      CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,TZID) // Temp Sensor ID
      CreateDwordField(BUFF,20,VTIM) // Timeout
      CreateDwordField(BUFF,24,VLO) // Low Threshold
      CreateDwordField(BUFF,28,VHI) // High Threshold
      CreateDWordField(BUFF,18,TSTS) // Output Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(32, LENG)
      Store(0x2, CMDD) // EC_THM_SET_THRS
      Store(Arg0, TZID)
      Store(DeRefOf(Index(Arg1,0)),VTIM)
      Store(DeRefOf(Index(Arg1,1)),VLO)
      Store(DeRefOf(Index(Arg1,2)),VHI)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (TSTS)
      }
    }
    Return (0x3) // Hardware failure
  }

  // Arg0 GUID 1f0849fc-a845-4fcf-865c-4101bf8e8d79
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    If(LEqual(ToUuid("1f0849fc-a845-4fcf-865c-4101bf8e8d79"),Arg0)) {
      Switch(Arg2) {
        Case (0) {
          Return(0x3) // Support Function 0 and Function 1
        }
        Case (1) {
          Return( THRS(0x2, Arg3) ) // Call to function to set threshold
        }
      }
    }
    Return(0x3)
  }
}

Device(THRM) {
  Name(_HID, "MSFT000B")

  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(GVAR,2,Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(38){})
      CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,INST) // Instance ID
      CreateWordField(BUFF,20,VLEN) // 16-bit variable length
      CreateField(BUFF,176,128,VUID) // UUID of variable to read
      CreateField(BUFF,208,64,RVAL) // Output Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(38, LENG)
      Store(0x5, CMDD) // EC_THM_GET_VAR
      Store(Arg0,INST) // Save instance ID
      Store(4,VLEN) // Variable is always DWORD here
      Store(Arg1, VUID)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (RVAL)
      }
    }
    Return (0x3)
  }

  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(SVAR,3,Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(42){})
      CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,INST) // Instance ID
      CreateWordField(BUFF,20,VLEN) // 16-bit variable length
      CreateField(BUFF,176,128,VUID) // UUID of variable to read
      CreateDwordField(BUFF,38,DVAL) // Data value
      CreateField(BUFF,208,32,RVAL) // Ouput Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(42, LENG)
      Store(0x6, CMDD) // EC_THM_SET_VAR
      Store(Arg0,INST) // Save instance ID
      Store(4,VLEN) // Variable is always DWORD here
      Store(Arg1, VUID)
      Store(Arg2,DVAL)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
      Return (RVAL)
      }
    }
    Return (0x3)
  }

  // Arg0 GUID
  // 07ff6382-e29a-47c9-ac87-e79dad71dd82 - Input
  // d9b9b7f3-2a3e-4064-8841-cb13d317669e - Output
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    // Input Variable
    If(LEqual(ToUuid("07ff6382-e29a-47c9-ac87-e79dad71dd82"),Arg0)) {
      Switch(Arg2) {
        Case(0) {
          // We support function 0-3
          Return(0xf)
        }
        Case(1) {
          Return(GVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"))) // OnTemp
        }
        Case(2) {
          Return(GVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"))) // RampTemp
        }
        Case(3) {
          Return(GVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"))) // MaxTemp
        }
      }
      Return(0x1)
    }

    // Output Variable
    If(LEqual(ToUuid("d9b9b7f3-2a3e-4064-8841-cb13d317669e"),Arg0)) {
      Switch(Arg2) {
        Case(0) {
          // We support function 0-3
          Return(0xf)
        }
        Case(1) {
          Return(SVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"),Arg3)) // OnTemp
        }
        Case(2) {
          Return(SVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"),Arg3)) // RampTemp
        }
        Case(3) {
          Return(SVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"),Arg3)) // MaxTemp
        }
      }
    }
    Return (0x1)
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="call-flows-for-secure-and-non-secure-implementation"><a class="header" href="#call-flows-for-secure-and-non-secure-implementation">Call Flows for secure and non-secure Implementation</a></h2>
<p>Depending on system requirements the ACPI calls may go directly to the
EC or through secure world then through to EC.</p>
<p>When using non-secure interface the ACPI functions must define protocol
level which is the Embedded controller for eSPI. For I2C/I3C or SPI
interfaces the corresponding ACPI device must define the bus dependency
and build the packet directly that is sent to the EC.</p>
<p>For secure communication all data is sent to the secure world via FF-A
commands described in this document and the actual bus protocol and data
sent to the EC is defined in the secure world in Hafnium. All support
for FF-A is inboxed in the OS by default so EC communication will always
work in any environment. However, FF-A is not supported in x86/x64
platforms so direct EC communication must be used on these platforms.</p>
<h3 id="non-secure-espi-access"><a class="header" href="#non-secure-espi-access">Non-Secure eSPI Access</a></h3>
<p>This call flow assumes using Embedded controller definition with
independent ACPI functions for MPTF support</p>
<h4 id="non-secure-espi-read"><a class="header" href="#non-secure-espi-read">Non-Secure eSPI READ</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC

  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    Memory32Fixed (ReadWrite, 0x100000, 0x10) // Used for simulated port access
    Memory32Fixed (ReadWrite, 0x100010, 0x10)
    // Interrupt defined for eSPI event signalling
    GpioInt(Edge, ActiveHigh, ExclusiveAndWake,PullUp 0,"\\_SB.GPI2"){43} 
  })

  Name(_GPE, 0) // GPE index for this EC

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
    BST1, 32, // Battery State
    BST2, 32, // Battery Present Rate
    BST3, 32, // Battery Remaining capacity
    BST4, 32, // Battery Present Voltage
  }

  Method (_BST) {
    Name (BSTD, Package (0x4)
    {
      \\_SB.PCI0.ISA0.EC0.BST1, // Battery State
      \\_SB.PCI0.ISA0.EC0.BST2, // Battery Present Rate
      \\_SB.PCI0.ISA0.EC0.BST3, // Battery Remaining Capacity
      \\_SB.PCI0.ISA0.EC0.BST4, // Battery Present Voltage
    })
    Return(BSTD)
  }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
  OSPM-&gt;&gt;ACPI: call _BST method
  ACPI-&gt;&gt;ACPI: Map to EC0 fields in EC operation Region
  ACPI-&gt;&gt;ACPI: EC0 accesses change to eSPI Peripheral accesses
  ACPI-&gt;&gt;eSPI: Each field acccess changed to peripheral read/write
  ACPI-&gt;&gt;ACPI: ACI handles SCI, port IO, MMIO, serialized
  ACPI-&gt;&gt;ACPI: eSPI read/writes complete
  ACPI-&gt;&gt;ACPI: Data is reorganized to _BST structure
  ACPI-&gt;&gt;OSPM: Return _BST structure with status
</pre>
<h4 id="non-secure-espi-notifications"><a class="header" href="#non-secure-espi-notifications">Non-Secure eSPI Notifications</a></h4>
<p>All interrupts are handled by the ACPI driver. When EC needs to send a
notification event the GPIO is asserted and traps into IRQ. ACPI driver
reads the EC_SC status register to determine if an SCI is pending. DPC
callback calls and reads the EC_DATA port to determine the _Qxx event
that is pending. Based on the event that is determined by ACPI the
corresponding _Qxx event function is called.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_Q07) {
  // Take action for event 7
  Notify(\\_SB._LID, 0x80)
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
  EC-&gt;&gt;SCI ISR: EC asserts alert (IRQ)
  SCI ISR-&gt;&gt;SCI DPC: Schedule DPC if EC_SC indicates SCI
  SCI DPC-&gt;&gt;EC: Read EC_DATA to determine event
  EC-&gt;&gt;SCI DPC: Send Qxx event
  SCI DPC-&gt;&gt;ACPI: Call _Qxx function in EC0
</pre>
<h3 id="secure-espi-access"><a class="header" href="#secure-espi-access">Secure eSPI Access</a></h3>
<p>The following flow assumes ARM platform using FF-A for secure calls.
Note if you want to use the same EC firmware on both platforms with
secure and non-secure access the EC_BAT_GET_BST in this case should
be convert to a peripheral access with the same IO port and offset as
non-secure definition.</p>
<h4 id="secure-espi-read"><a class="header" href="#secure-espi-read">Secure eSPI READ</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_BST) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, BMA1) // In – Averaging Interval
    CreateField(BUFF,144,128,BSTD) // Out – 4 DWord BST data

    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(42, LENG)
    Store(0x6, CMDD) // EC_BAT_GET_BST
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
    Return (BMAD)
    } 
  } 
  Return(Zero)
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
 OSPM-&gt;&gt;ACPI: call_BST method
 ACPI-&gt;&gt;FFA: Send EC_BAT_GET_BST_request
 FFA-&gt;&gt;EC Service: Forward EC_BAT_GET_BST_request
 EC Service-&gt;&gt;EC Service: Convert to eSPI peripheral read/write
 EC Service-&gt;&gt;eSPI: send peripheral read/write access
 EC Service-&gt;&gt;FFA: FFA_YIELD (as needed)
 FFA-&gt;&gt;EC Service: FFA_RESUME (check for complete)
 eSPI-&gt;&gt;EC Service: Return peripheral read data
 EC Service-&gt;&gt;EC Service: Convert to EC_BAT_GET_BST response
 EC Service-&gt;&gt;FFA: FFA response to original request
 FFA-&gt;&gt;ACPI: return FFA status and _BST response
 ACPI-&gt;OSPM: return _BST structure

</pre>
<h4 id="secure-espi-notification"><a class="header" href="#secure-espi-notification">Secure eSPI Notification</a></h4>
<p>When EC communication is done through Secure world we assert FIQ which
is handled as eSPI interrupt. eSPI driver reads EC_SC and EC_DATA to
retrieve the notification event details. On Non-secure implementation
ACPI converts this to Qxx callback. On secure platform this is converted
to a virtual ID and sent back to the OS via _NFY callback and a virtual
ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method(_NFY, 2, Serialized) {
  // Arg0 == UUID
  // Arg1 == Notify ID
  If(LEqual(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"),Arg0)) {
    If(LEqual(0x2,Arg1)) {
      Store(Arg1, \\_SB.ECT0.NEVT)
      Notify(\\_SB._LID, 0x80)
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
   EC-&gt;&gt;eSPI: EC asserts Alert (FIQ)
   eSPI-&gt;&gt;EC: Read EC_SC to check for SCI
   eSPI-&gt;&gt;EC: Read EC_DATA for SCI event
   EC-&gt;&gt;eSPI: SCI Qxx event
   
   eSPI-&gt;&gt;EC Service: Notification callback Qxx
   EC Service-&gt;&gt;EC Service: Convert qxx to Virtual ID
   EC Service-&gt;&gt;EC Nfy Service: Notify Virtual ID
   EC Nfy Service-&gt;&gt;FFA:Send Physical ID
   FFA-&gt;&gt;ACPI:Call_NFY with Virtual ID
   ACPI-&gt;&gt;ACPI: Read SMEM notify details
   ACPI--)EC Service: Clear event (optional)

   
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-ec-interface"><a class="header" href="#legacy-ec-interface">Legacy EC Interface</a></h1>
<p>ACPI specification has a definition for an embedded controller, however
this implementation is tied very closely to the eSPI bus and x86
architecture.</p>
<p>The following is an example of legacy EC interface definition from ACPI</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/11_Thermal_Management/thermal-zone-examples.html">11.7. Thermal Zone Examples — ACPI Specification 6.4
documentation</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Scope(\\_SB.PCI0.ISA0) {
  Device(EC0) {
    Name(_HID, EISAID("PNP0C09")) // ID for this EC

    // current resource description for this EC
    Name(_CRS, ResourceTemplate() {
      IO(Decode16,0x62,0x62,0,1)
      IO(Decode16,0x66,0x66,0,1)
    })

    Name(_GPE, 0) // GPE index for this EC
    
    // create EC's region and field for thermal support
    OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
    Field(EC0, ByteAcc, Lock, Preserve) {
      MODE, 1, // thermal policy (quiet/perform)
      FAN, 1, // fan power (on/off)
      , 6, // reserved
      TMP, 16, // current temp
      AC0, 16, // active cooling temp (fan high)
      , 16, // reserved
      PSV, 16, // passive cooling temp
      HOT 16, // critical S4 temp
      CRT, 16 // critical temp
    }

    // following is a method that OSPM will schedule after
    // it receives an SCI and queries the EC to receive value 7
    Method(_Q07) {
      Notify (\\_SB.PCI0.ISA0.EC0.TZ0, 0x80)
    } // end of Notify method

    // fan cooling on/off - engaged at AC0 temp
    PowerResource(PFAN, 0, 0) {
      Method(_STA) { Return (\\_SB.PCI0.ISA0.EC0.FAN) } // check power state
      Method(_ON) { Store (One, \\\\_SB.PCI0.ISA0.EC0.FAN) } // turn on fan
      Method(_OFF) { Store ( Zero, \\\\_SB.PCI0.ISA0.EC0.FAN) }// turn off
fan
    }

    // Create FAN device object
    Device (FAN) {
    // Device ID for the FAN
    Name(_HID, EISAID("PNP0C0B"))
    // list power resource for the fan
    Name(_PR0, Package(){PFAN})
    }

    // create a thermal zone
    ThermalZone (TZ0) {
      Method(_TMP) { Return (\\_SB.PCI0.ISA0.EC0.TMP )} // get current temp
      Method(_AC0) { Return (\\_SB.PCI0.ISA0.EC0.AC0) } // fan high temp
      Name(_AL0, Package(){\\_SB.PCI0.ISA0.EC0.FAN}) // fan is act cool dev
      Method(_PSV) { Return (\\_SB.PCI0.ISA0.EC0.PSV) } // passive cooling
temp
      Name(_PSL, Package (){\\_SB.CPU0}) // passive cooling devices
      Method(_HOT) { Return (\\_SB.PCI0.ISA0.EC0.HOT) } // get critical S4
temp
      Method(_CRT) { Return (\\_SB.PCI0.ISA0.EC0.CRT) } // get critical temp
      Method(_SCP, 1) { Store (Arg1, \\\\_SB.PCI0.ISA0.EC0.MODE) } // set
cooling mode

      Name(_TSP, 150) // passive sampling = 15 sec
      Name(_TZP, 0) // polling not required
      Name (_STR, Unicode ("System thermal zone"))
    } // end of TZ0
  } // end of ECO
} // end of \\\\_SB.PCI0.ISA0 scope-
<span class="boring">}</span></code></pre></pre>
<p>On platforms that do not support IO port access there is an option to
define MMIO regions to simulate the IO port transactions.</p>
<p>In the above example you can see that the operation region directly maps
to features on the EC and you can change the EC behavior by writing to a
byte in the region or reading the latest data from the EC.</p>
<p>For a system with the EC connected via eSPI and that needs a simple
non-secure interface to the EC the above mapping works very well and
keeps the code simple. The eSPI protocol itself has details on port
accesses and uses the peripheral channel to easily read/write memory
mapped regions.</p>
<p>As the EC features evolve there are several requirements that do no work
well with this interface:</p>
<ul>
<li>
<p>Different buses such as I3C, SPI, UART target a packet
request/response rather than a memory mapped interface</p>
</li>
<li>
<p>Protected or restricted access and validation of request/response</p>
</li>
<li>
<p>Firmware update, large data driven requests that require larger data
response the 256-byte region is limited</p>
</li>
<li>
<p>Discoverability of features available and OEM customizations</p>
</li>
<li>
<p>Out of order completion of requests, concurrency, routing and
priority handling</p>
</li>
</ul>
<p>As we try to address these limitations and move to a more packet based
protocol described in this document. The following section covers
details on how to adopt existing operation region to new ACPI
functionality.</p>
<h2 id="adopting-ec-operation-region"><a class="header" href="#adopting-ec-operation-region">Adopting EC Operation Region</a></h2>
<p>The new OS frameworks such as MPTF still use ACPI methods as primary
interface. Instead of defining devices such as FAN or ThermalZone in the
EC region you can simply define the EC region itself and then map all
the other ACPI functions to operate on this region. This will allow you
to maintain backwards compatibility with existing EC definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC
  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    IO(Decode16,0x62,0x62,0,1)
    IO(Decode16,0x66,0x66,0,1)
  })

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
  }
}

Device(SKIN) {
  Name(_HID, "MSFT000A") // New MPTF HID Temperature Device
  Method(_TMP, 0x0, Serialized) {
      Return( \\_SB.PCI0.ISA0.EC0.TMP)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>For more complicated functions that take a package some of the data may
be constructed within ACPI and some of the data pulled from the
OperationRegion. For example BIX for battery information may have a
combination of static and dynamic data like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_BIX) {
  Name (BAT0, Package (0x12)
  {
    0x01, // Revision
    0x02, // Power Unit
    0x03, // Design Capacity
    \\_SB.PCI0.ISA0.EC0.BFCC, // Last Full Charge Capacity
    0x05, // Battery Technology
    0x06, // Design Voltage
    0x07, // Design capacity of Warning
    0x08, // Design Capacity of Low
    \\_SB.PCI0.ISA0.EC0.BCYL, // Cycle Count
    0x0A, // Measurement Accuracy
    0x0B, // Max Sampling Time
    0x0C, // Min Sampling Time
    0x0D, // Max Averaging Interval
    0x0E, // Min Averaging Interval
    0x0F, // Battery Capacity Granularity 1
    0x10, // Battery Capacity Granularity 2
    "Model123", // Model Number
    "Serial456", // Serial Number
    "Li-Ion", // Battery Type
    "OEMName" // OEM Information
  })
  Return(BAT0)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-for-using-legacy-ec"><a class="header" href="#limitations-for-using-legacy-ec">Limitations for using Legacy EC</a></h2>
<p>Before using the Legacy EC definition OEM’s should be aware of several
use cases that may limit you ability to use it.</p>
<h3 id="acpi-support-for-espi-master"><a class="header" href="#acpi-support-for-espi-master">ACPI support for eSPI master</a></h3>
<p>In the case of Legacy EC the communication to the EC is accomplished
directly by the ACPI driver using PORT IO and eSPI Peripheral Bus
commands. On ARM platforms there is no PORT IO and these must be
substituted with MMIO regions. The ACPI driver needs changes to support
MMIO which is being evaluated and support is not yet available. Some
Silicon Vendors also do not implement the full eSPI specification and as
such the ACPI driver cannot handle all the communication needs. On these
platforms using Legacy EC interface is not an option.</p>
<h3 id="security-of-espi-bus"><a class="header" href="#security-of-espi-bus">Security of eSPI bus</a></h3>
<p>When non-secure world is given access to the eSPI bus it can send
commands to device on that bus. Some HW designs have the TPM or SPINOR
on the same physical bus as the EC. On these designs allowing non-secure
world to directly sends commands to EC can break the security
requirements of other devices on the bus. In these cases the eSPI
communication must be done in the secure world over FF-A as covered in
this document and not use the Legacy EC channel. Since non-secure world
has complete access to the EC operation region there is no chance for
encryption of data. All data in the operation region is considered
non-secure.</p>
<h3 id="functional-limitations-of-legacy-ec"><a class="header" href="#functional-limitations-of-legacy-ec">Functional limitations of Legacy EC</a></h3>
<p>The peripheral region that is mapped in the Legacy EC in ACPI is limited
to 256 bytes and notification events to the ones that are defined and
handled in ACPI driver. To create custom solutions, send large packets
or support encryption of data the Legacy EC interface has limitations in
this area.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-ec-services-overview"><a class="header" href="#secure-ec-services-overview">Secure EC Services Overview</a></h1>
<p>In this section we review a system design where the EC communication is
in the secure world running in a dedicated SP. In a system without
secure world or where communication to EC is not desired to be secure
all the ACPI functions can be mapped directly to data from the EC
operation region.</p>
<p>The following github projects provide sample implementations of this interface:</p>
<p><a href="https://github.com/opendevicepartnership/ec-test-app">ACPI EC samples, Kernel mode test driver, User mode test driver</a><br>
<a href="https://github.com/opendevicepartnership/haf-ec-service">Sample Secure Partition Service for EC services in RUST</a><br>
<a href="https://github.com/opendevicepartnership/ffa">RUST crate for FFA implementation in secure partition</a><br></p>
<p>The following GUID’s have been designed to represent each service
operating in the secure partition for EC.</p>
<table>
<thead>
<tr class="header">
<th>EC Service Name</th>
<th>Service GUID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<td>EC_SVC_MANAGEMENT</td>
<td>330c1273-fde5-4757-9819-5b6539037502</td>
<td>Used to query EC functionality, Board info, version, security state, FW update</td>
</tr>
<td>EC_SVC_POWER</td>
<td>7157addf-2fbe-4c63-ae95-efac16e3b01c</td>
<td>Handles general power related requests and OS Sx state transition state notification</td>
</tr>
<td>EC_SVC_BATTERY</td>
<td>25cb5207-ac36-427d-aaef-3aa78877d27e</td>
<td>Handles battery info, status, charging</td>
</tr>
<td>EC_SVC_THERMAL</td>
<td>31f56da7-593c-4d72-a4b3-8fc7171ac073</td>
<td>Handles thermal requests for skin and other thermal events</td>
</tr>
<td>EC_SVC_UCSI</td>
<td>65467f50-827f-4e4f-8770-dbf4c3f77f45</td>
<td>Handles PD notifications and calls to UCSI interface</td>
</tr>
<td>EC_SVC_INPUT</td>
<td>e3168a99-4a57-4a2b-8c5e-11bcfec73406</td>
<td>Handles wake events, power key, lid, input devices (HID separate instance)</td>
</tr>
<td>EC_SVC_TIME_ALARM</td>
<td>23ea63ed-b593-46ea-b027-8924df88e92f</td>
<td>Handles RTC and wake timers.</td>
</tr>
<td>EC_SVC_DEBUG</td>
<td>0bd66c7c-a288-48a6-afc8-e2200c03eb62</td>
<td>Used for telemetry, debug control, recovery modes, logs, etc</td>
</tr>
<td>EC_SVC_TEST</td>
<td>6c44c879-d0bc-41d3-bef6-60432182dfe6</td>
<td>Used to send commands for manufacturing/factory test</td>
</tr>
<td>EC_SVC_OEM1</td>
<td>9a8a1e88-a880-447c-830d-6d764e9172bb</td>
<td>Sample OEM custom service and example piping of events</td>
</tr>
</tbody>
</table>
<h2 id="ffa-overview"><a class="header" href="#ffa-overview">FFA Overview</a></h2>
<p>This section covers the components involved in sending a command to EC
through the FFA flow in windows. This path is specific to ARM devices
and a common solution with x64 is still being worked out. Those will
continue through the non-secure OperationRegion in the near term.</p>
<p><img src="intro/concepts/ec_services_example/media/image1.png" alt="A diagram of a computer security system Description automatically generated" /></p>
<p>ARM has a standard for calling into the secure world through SMC’s and
targeting a particular service running in secure world via a UUID. The
full specification and details can be found here: <a href="https://developer.arm.com/Architectures/Firmware%20Framework%20for%20A-Profile">Firmware Framework
for A-Profile</a></p>
<p>The windows kernel provides native ability for ACPI to directly send and
receive FFA commands. It also provides a driver ffadrv.sys to expose a
DDI that allows other drivers to directly send/receive FFA commands
without needing to go through ACPI.</p>
<p>Hyper-V forwards the SMC’s through to EL3 to Hafnium which then uses the
UUID to route the request to the correct SP and service. From the
corresponding EC service it then calls into the eSPI or underlying
transport layer to send and receive the request to the physical EC.</p>
<h3 id="ffa-device-definition-1"><a class="header" href="#ffa-device-definition-1">FFA Device Definition</a></h3>
<p>The FFA device is loaded from ACPI during boot and as such requires a
Device entry in ACPI</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Name(_HID, "MSFT000C")

  OperationRegion(AFFH, FFixedHw, 4, 144) 
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }     
    

  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              2, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
              Package () {
                     ToUUID("b510b3a3-59f6-4054-ba7a-ff2eb1eac765"), // Service2 UUID
                     Package () {
                          0x01,     //Cookie1
                          0x03,     //Cookie2
                      }
             }
         }
      }
    }
  }) // _DSD()

  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }

  Method(AVAL,0x0, Serialized)
  {
    Return(One)
  }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="hid-definition"><a class="header" href="#hid-definition">HID definition</a></h4>
<p>The _HID “MSFT000C” is reserved for FFA devices. Defining this HID for
your device will cause the FFA interface for the OS to be loaded on this
device.</p>
<h4 id="operation-region-definition"><a class="header" href="#operation-region-definition">Operation Region Definition</a></h4>
<p>The operation region is marked as FFixedHw type 4 which lets the ACPI
interpreter know that any read/write to this region requires special
handling. The length is 144 bytes because this region operates on
registers X0-X17 each of which are 8 bytes 18*8 = 144 bytes. This is
mapped to FFAC is 1152 bits (144*8) and this field is where we act
upon.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OperationRegion(AFFH, FFixedHw, 4, 144)
Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1),FFAC, 1152 }
<span class="boring">}</span></code></pre></pre>
<p>When reading and writing from this operation region the FFA driver does
some underlying mapping for X0-X3</p>
<pre><code>X0 = 0xc400008d // FFA_DIRECT_REQ2
X1 = (Receiver Endpoint ID) | (Sender Endpoint ID \&lt;\&lt; 16)
X2/X3 = UUID
</code></pre>
<p>The following is the format of the request and response packets that are
sent via ACPI</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FFA_REQ_PACKET
{
  uint8 status; // Not used just populated so commands are symmetric
  uint8 length; // Number of bytes in rawdata
  uint128 UUID;
  uint8 reqdata[];
}

FFA_RSP_PACKET
{
  uint8 status; // Status from ACPI if FFA command was sent successfully
  uint8 length;
  uint128 UUID;
  uint64 ffa_status; // Status returned from the service of the FFA command
  uint8 rspdata[];
}

CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // In/Out - UUID of service
CreateDwordField(BUFF,18,FFST)// Out - FFA command status
<span class="boring">}</span></code></pre></pre>
<h4 id="register-notification"><a class="header" href="#register-notification">Register Notification</a></h4>
<p>During FFA driver initialization it calls into secure world to get a
list of all available services for each secure partition. After this we
send a NOTIFICATION_REGISTRATION request to each SP that has a service
which registers for notification events</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              1, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
         }
      }
    }
  }) // _DSD()
<span class="boring">}</span></code></pre></pre>
<p><img src="intro/concepts/ec_services_example/media/image2.png" alt="A diagram of a application Description automatically generated" /></p>
<p>In the above example we indicate that the OS will handle 2 different
notification events for UUID 330c1273-fde5-4757-9819-5b6539037502 which
is our EC management UUID. FFA knows which secure partition this maps to
based on the list of services for each SP it has retrieved. Rather than
having to keep track of all the physical bits in the bitmask that are
used the FFA driver keeps track of this and allows each service to
create a list of virtual ID’s they need to handle. The FFA driver then
maps this to one of the available bits in the hardware bitmask and
passes this mapping down to the notification service running in a given
SP.</p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<table>
<thead>
<tr class="header">
<th><strong>Parameter </strong></th>
<th><strong>Register </strong></th>
<th><strong>Value </strong></th>
</tr>
</thead>
<tbody>
<td>Function<strong> </strong></td>
<td>X4 </td>
<td>0x1 </td>
</tr>
<td>UUID Lo<strong> </strong></td>
<td>X5 </td>
<td>Bytes [0..7] for the service UUID. </td>
</tr>
<td>UUID Hi<strong> </strong></td>
<td>X6 </td>
<td>Bytes [8..16] for the service UUID. </td>
</tr>
<td>Mappings Count<strong> </strong></td>
<td>X7 </td>
<td>The number of notification mappings </td>
</tr>
<td>Notification Mapping1<strong> </strong></td>
<td>X8 </td>
<td><p>Bits [0..16] – Notification ID. --&gt; 0,1,2,3,... </p>
<p> </p>
<p>Bits [16..32] – Notification Bitmap bit number (0-383).  </p></td>
</tr>
<td>Notification Mapping2<strong> </strong></td>
<td>X9 </td>
<td><p>Bits [0..16] – Notification ID. --&gt; 0,1,2,3,... </p>
<p> </p>
<p>Bits [16..32] – Notification Bitmap bit number (0-383). </p>
<p> </p></td>
</tr>
<td>...<strong> </strong></td>
<td>... </td>
<td>... </td>
</tr>
</tbody>
</table>
<p> </p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter </th><th>Register </th><th>Value </th></tr></thead><tbody>
<tr><td>Result</td><td>X4</td><td>0 on success. Otherwise, Failure</td></tr>
</tbody></table>
</div>
<p> </p>
<p>Note this NOTIFICATION_REGISTER request is sent to the
Notification Service UUID in the SP. The UUID of the service that the
notifications are for are stored in X5/X6 registers shown above.</p>
<p>The UUID for notification service is
{B510B3A3-59F6-4054-BA7A-FF2EB1EAC765} which is stored in X2/X3.</p>
<h4 id="notification-events"><a class="header" href="#notification-events">Notification Events</a></h4>
<p>All notification events sent from all secure partitions are passed back
through the FFA driver. The notification calls the _DSM method. Function 0
is always a bitmap of all the other functions supported. We must support at
least a minium of the Query and Notify.
The UUID is stored in Arg0 and the notification cookie is stored in Arg3 when Arg2 is 11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }
<span class="boring">}</span></code></pre></pre>
<p>The following is the call flow showing a secure interrupt arriving to
the EC service which results in a notification back to ACPI. The
notification payload can optionally be written to a shared buffer or
ACPI can make another call back into EC service to retrieve the
notification details.</p>
<p>The _NFY only contains the ID of the notification and no other payload,
so both ACPI and the EC service must be designed either with shared
memory buffer or a further notify data packet.</p>
<p><img src="intro/concepts/ec_services_example/media/image3.png" alt="A diagram of a service Description automatically generated" /></p>
<h2 id="runtime-requests"><a class="header" href="#runtime-requests">Runtime Requests</a></h2>
<p>During runtime the non-secure side uses FFA_MSG_SEND_DIRECT_REQ2
requests to send requests to a given service within an SP. Any request
that is expected to take longer than 500 uSec should yield control back
to the OS by calling FFA_YIELD within the service. When FFA_YIELD is
called it will return control back to the OS to continue executing but
the corresponding ACPI thread will be blocked until the original FFA
request completes with DIRECT_RSP2. Note this creates a polling type
interface where the OS will resume the SP thread after the timeout
specified. The following is sample call sequence.</p>
<p><img src="intro/concepts/ec_services_example/media/image4.png" alt="A diagram of a company&#39;s process Description automatically generated" /></p>
<h3 id="ffa-example-data-flow"><a class="header" href="#ffa-example-data-flow">FFA Example Data Flow</a></h3>
<p>For an example let’s take the battery status request _BST and follow
data through.</p>
<p><img src="intro/concepts/ec_services_example/media/image5.png" alt="A screenshot of a computer Description automatically generated" /></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FFA_REQ_PACKET req = {
  0x0, // Initialize to no error
  0x1, // Only 1 byte of data is sent after the header
  {0x25,0xcb,0x52,0x07,0xac,0x36,0x42,0x7d,0xaa,0xef,0x3a,0xa7,0x88,0x77,0xd2,0x7e},
  0x2 // EC_BAT_GET_BST
}
<span class="boring">}</span></code></pre></pre>
<p>The equivalent to write this data into a BUFF in ACPI is as follows</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // UUID of service
CreateByteField(BUFF,18, CMDD) // In – First byte of command
CreateField(BUFF,144,128,BSTD) // Out – Raw data response 4 DWords
Store(20,LENG)
Store(0x2, CMDD)
Store(ToUUID ("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID)
Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)
<span class="boring">}</span></code></pre></pre>
<p>The ACPI interpreter when walking through this code creates a buffer and
populates the data into buffer. The last line indicates to send this
buffer over FFA interface.</p>
<p>ACPI calls into the FFA interface to send the data over to the secure
world EC Service</p>
<pre><code>typedef struct _FFA_INTERFACE {
    ULONG Version;
    PFFA_MSG_SEND_DIRECT_REQ2 SendDirectReq2;
} FFA_INTERFACE, \*PFFA_INTERFACE;
</code></pre>
<h3 id="ffa-parsing"><a class="header" href="#ffa-parsing">FFA Parsing</a></h3>
<p>FFA is in charge of sending the SMC over to the secure world and routing
to the correct service based on UUID.</p>
<p><img src="intro/concepts/ec_services_example/media/image6.png" alt="A diagram of a computer Description automatically generated" /></p>
<pre><code>X0 = SEND_DIRECT_REQ2 SMC command ID
X1 = Source ID and Destination ID
X2 = UUID Low
X3 = UUID High
X4-X17 = rawdata
</code></pre>
<p><strong>Note:</strong> The status and length are not passed through to the secure
world they are consumed only be ACPI.</p>
<p>HyperV and Monitor have a chance to filter or deny the request, but in
general just pass the SMC request through to Hafnium</p>
<p>Hafnium extracts the data from the registers into an sp_msg structure
which is directly mapping contents from x0-x17 into these fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FfaParams {
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    pub x4: u64,
    pub x5: u64,
    pub x6: u64,
    pub x7: u64,
    pub x8: u64,
    pub x9: u64,
    pub x10: u64,
    pub x11: u64,
    pub x12: u64,
    pub x13: u64,
    pub x14: u64,
    pub x15: u64,
    pub x16: u64,
    pub x17: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>In our SP we receive the raw FfaParams structure and we convert this to
an FfaMsg using our translator. This pulls out the function_id,
source_id, destination_id and uuid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn from(params: FfaParams) -&gt; FfaMsg {
  FfaMsg {
    function_id: params.x0,              // Function id is in lower 32 bits of x0
    source_id: (params.x1 &gt;&gt; 16) as u16, // Source in upper 16 bits
    destination_id: params.x1 as u16,    // Destination in lower 16 bits
    uuid: u64_to_uuid(params.x2, params.x3),
    args64: [
      params.x4, params.x5, params.x6, params.x7, params.x8, params.x9, params.x10,
      params.x11, params.x12, params.x13, params.x14, params.x15, params.x16, params.x17,
            ],
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The destination_id is used to route the message to the correct SP, this
is based on the ID field in the DTS description file. Eg: id =
&lt;0x8001&gt;;</p>
<h3 id="ec-service-parsing"><a class="header" href="#ec-service-parsing">EC Service Parsing</a></h3>
<p>Within the EC partition there are several services that run, the routing
of the FF-A request to the correct services is done by the main message
handling loop for the secure partition. After receiving a message we
call into ffa_msg_handler and based on the UUID send it to the
corresponding service to handle the message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut next_msg = ffa.msg_wait();
loop {
  match next_msg {
    Ok(ffamsg) =&gt; match ffa_msg_handler(&amp;ffamsg) {
      Ok(msg) =&gt; next_msg = ffa.msg_resp(\&amp;msg),
      Err(_e) =&gt; panic!("Failed to handle FFA msg"),
    },
    Err(_e) =&gt; {
      panic!("Error executing msg_wait");
    }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>The main message loop gets the response back from ffa_msg_handler and
returns to non-secure world so the next incoming message after the
response is a new message to handle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ffa_msg_handler(msg: &amp;FfaMsg) -&gt; Result&lt;FfaMsg&gt; {
    println!(
        "Successfully received ffa msg:
        function_id = {:08x}
               uuid = {}",
        msg.function_id, msg.uuid
    );

    match msg.uuid {
        UUID_EC_SVC_MANAGEMENT =&gt; {
            let fwmgmt = fw_mgmt::FwMgmt::new();
            fwmgmt.exec(msg)
        }

        UUID_EC_SVC_NOTIFY =&gt; {
            let ntfy = notify::Notify::new();
            ntfy.exec(msg)
        }

        UUID_EC_SVC_POWER =&gt; {
            let pwr = power::Power::new();
            pwr.exec(msg)
        }

        UUID_EC_SVC_BATTERY =&gt; {
            let batt = battery::Battery::new();
            batt.exec(msg)
        }

        UUID_EC_SVC_THERMAL =&gt; {
            let thm = thermal::ThmMgmt::new();
            thm.exec(msg)
        }

        UUID_EC_SVC_UCSI =&gt; {
            let ucsi = ucsi::UCSI::new();
            ucsi.exec(msg)
        }

        UUID_EC_SVC_TIME_ALARM =&gt; {
            let alrm = alarm::Alarm::new();
            alrm.exec(msg)
        }

        UUID_EC_SVC_DEBUG =&gt; {
            let dbg = debug::Debug::new();
            dbg.exec(msg)
        }

        UUID_EC_SVC_OEM =&gt; {
            let oem = oem::OEM::new();
            oem.exec(msg)
        }

        _ =&gt; panic!("Unknown UUID"),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="large-data-transfers"><a class="header" href="#large-data-transfers">Large Data Transfers</a></h3>
<p>When making an FFA_MSG_SEND_DIRECT_REQ2 call the data is stored in
registers X0-X17. X0-X3 are reserved to store the Function Id, Source
Id, Destination Id and UUID. This leaves X4-X17 or 112 bytes. For larger
messages they either need to be broken into multiple pieces or make use
of a shared buffer between the OS and Secure Partition.</p>
<h4 id="shared-buffer-definitions"><a class="header" href="#shared-buffer-definitions">Shared Buffer Definitions</a></h4>
<p>To create a shared buffer you need to modify the dts file for the secure
partition to include mapping to your buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ns_comm_buffer {
  description = "ns-comm";
  base-address = &lt;0x00000100 0x60000000&gt;;
  pages-count = &lt;0x8&gt;;
  attributes = &lt;NON_SECURE_RW&gt;;
};
<span class="boring">}</span></code></pre></pre>
<p>During UEFI Platform initialization you will need to do the following
steps, see the FFA specification for more details on these commands</p>
<ul>
<li>FFA_MAP_RXTX_BUFFER</li>
<li>FFA_MEM_SHARE</li>
<li>FFA_MSG_SEND_DIRECT_REQ2 (EC_CAP_MEM_SHARE)</li>
<li>FFA_UNMAP_RXTX_BUFFER</li>
</ul>
<p>The RXTX buffer is used during larger packet transfers but can be
overridden and updated by the framework. The MEM_SHARE command uses the
RXTX buffer so we first map that buffer then populate our memory
descriptor requests to the TX_BUFFER and send to Hafnium. After sending
the MEM_SHARE request we need to instruct our SP to retrieve this
memory mapping request. This is done through our customer
EC_CAP_MEM_SHARE request where we describe the shared memory region
that UEFI has donated. From there we call FFA_MEM_RETRIEVE_REQ to map
the shared memory that was described to Hafnium. After we are done with
the RXTX buffers we must unmap them as the OS will re-map new RXTX
buffers. From this point on both Non-secure and Secure side will have
access to this shared memory buffer that was allocated.</p>
<h3 id="async-transfers"><a class="header" href="#async-transfers">Async Transfers</a></h3>
<p>All services are single threaded by default. Even when doing FFA_YIELD
it does not allow any new content to be executed within the service. If
you need your service to be truly asynchronous you must have commands
with delayed responses.</p>
<p>There is no packet identifier by default and tracking of requests and
completion by FFA, so the sample solution given here is based on shared
buffers defined in previous section and existing ACPI and FFA
functionality.</p>
<p><img src="intro/concepts/ec_services_example/media/image7.png" alt="A diagram of a service Description automatically generated" /></p>
<p>Inside of our FFA functions rather than copying our data payload into
the direct registers we define a queue in shared memory and populate the
actual data into this queue entry. In the FFA_MSG_SEND_DIRECT_REQ2
we populate an ASYNC command ID (0x0) along with the seq #. The seq #
is then used by the service to locate the request in the TX queue. We
define a separate queue for RX and TX so we don’t need to synchronize
between OS and secure partition.</p>
<p><img src="intro/concepts/ec_services_example/media/image8.png" alt="" /></p>
<h3 id="acpi-structures-and-methods-for-asynchronous"><a class="header" href="#acpi-structures-and-methods-for-asynchronous">ACPI Structures and Methods for Asynchronous</a></h3>
<p>The SMTX is shared memory TX region definition</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shared memory regions and ASYNC implementation
OperationRegion (SMTX, SystemMemory, 0x10060000000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMTX, AnyAcc, NoLock, Preserve)
{
  TVER, 16,
  TCNT, 16,
  TRS0, 32,
  TB0, 64,
  TB1, 64,
  TB2, 64,
  TB3, 64,
  TB4, 64,
  TB5, 64,
  TB6, 64,
  TB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  TE0, 2048,
  TE1, 2048,
  TE2, 2048,
  TE3, 2048,
  TE4, 2048,
  TE5, 2048,
  TE6, 2048,
  TE7, 2048,
}
<span class="boring">}</span></code></pre></pre>
<p>The QTXB method copies data into first available entry in the TX queue
and returns sequence number used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Arg0 is buffer pointer
// Arg1 is length of Data
// Return Seq \#
Method(QTXB, 0x2, Serialized) {
  Name(TBX, 0x0)
  Store(Add(ShiftLeft(1,32),Add(ShiftLeft(Arg1,16),SEQN)),TBX)
  Increment(SEQN)
  // Loop until we find a free entry to populate
  While(One) {
    If(LEqual(And(TB0,0xFFFF),0x0)) {
      Store(TBX,TB0); Store(Arg0,TE0); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB1,0xFFFF),0x0)) {
      Store(TBX,TB1); Store(Arg0,TE1); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB2,0xFFFF),0x0)) {
      Store(TBX,TB2); Store(Arg0,TE2); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB3,0xFFFF),0x0)) {
      Store(TBX,TB3); Store(Arg0,TE3); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB4,0xFFFF),0x0)) {
      Store(TBX,TB4); Store(Arg0,TE4); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB5,0xFFFF),0x0)) {
      Store(TBX,TB5); Store(Arg0,TE5); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB6,0xFFFF),0x0)) {
      Store(TBX,TB6); Store(Arg0,TE6); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB7,0xFFFF),0x0)) {
      Store(TBX,TB7); Store(Arg0,TE7); Return( And(TBX,0xFFFF) )
    }

    Sleep(5)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The SMRX is shared memory region for RX queues</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shared memory region
OperationRegion (SMRX, SystemMemory, 0x10060001000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMRX, AnyAcc, NoLock, Preserve)
{
  RVER, 16,
  RCNT, 16,
  RRS0, 32,
  RB0, 64,
  RB1, 64,
  RB2, 64,
  RB3, 64,
  RB4, 64,
  RB5, 64,
  RB6, 64,
  RB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  RE0, 2048,
  RE1, 2048,
  RE2, 2048,
  RE3, 2048,
  RE4, 2048,
  RE5, 2048,
  RE6, 2048,
  RE7, 2048,
}
<span class="boring">}</span></code></pre></pre>
<p>The RXDB function takes sequence number as input and will keep looping
through all the entries until we see packet has completed. Sleeps for
5ms between each iteration to allow the OS to do other things and other
ACPI threads can run.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allow multiple threads to wait for their SEQ packet at once
// If supporting packet \&gt; 256 bytes need to modify to stitch together packet
Method(RXDB, 0x1, Serialized) {
  Name(BUFF, Buffer(256){})
  // Loop forever until we find our seq
  While (One) {
    If(LEqual(And(RB0,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB0,16),0xFFFF),8), XB0)
      Store(RE0,BUFF); Store(0,RB0); Return( XB0 )
    }

    If(LEqual(And(RB1,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB1,16),0xFFFF),8), XB1)
      Store(RE1,BUFF); Store(0,RB1); Return( XB1 )
    }

    If(LEqual(And(RB2,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB2,16),0xFFFF),8), XB2)
      Store(RE2,BUFF); Store(0,RB2); Return( XB2 )
    }

    If(LEqual(And(RB3,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB3,16),0xFFFF),8), XB3)
      Store(RE3,BUFF); Store(0,RB3); Return( XB3 )
    }

    If(LEqual(And(RB4,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB4,16),0xFFFF),8), XB4)
      Store(RE4,BUFF); Store(0,RB4); Return( XB4 )
    }

    If(LEqual(And(RB5,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB5,16),0xFFFF),8), XB5)
      Store(RE5,BUFF); Store(0,RB5); Return( XB5 )
    }

    If(LEqual(And(RB6,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB6,16),0xFFFF),8), XB6)
      Store(RE6,BUFF); Store(0,RB6); Return( XB6 )
    }

    If(LEqual(And(RB7,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB7,16),0xFFFF),8), XB7)
      Store(RE7,BUFF); Store(0,RB7); Return( XB7 )
    }

    Sleep(5)
  }

  // If we get here didn't find a matching sequence number
  Return (Ones)
}
<span class="boring">}</span></code></pre></pre>
<p>The following is sample code to transmit a ASYNC request and wait for
the data in the RX buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method(ASYC, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
  Name(BUFF, Buffer(30){})
  CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
  CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
  CreateField(BUFF,16,128,UUID) // UUID of service
  CreateByteField(BUFF,18,CMDD) // Command register
  CreateWordField(BUFF,19,BSQN) // Sequence Number

  // x0 -\&gt; STAT
  Store(20, LENG)
  Store(0x0, CMDD) // EC_ASYNC command
  Local0 = QTXB(BUFF,20) // Copy data to our queue entry and get back SEQN
  Store(Local0,BSQN) // Sequence packet to read from shared memory
  Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
  Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

  If(LEqual(STAT,0x0) ) // Check FF-A successful?
  {
    Return (RXDB(Local0)) // Loop through our RX queue till packet completes
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="recovery-and-errors"><a class="header" href="#recovery-and-errors">Recovery and Errors</a></h2>
<p>The eSPI or bus driver is expected to detect if the EC is not responding
and retry. The FFA driver will report back in the status byte if it
cannot successfully talk to the secure world. If there are other
failures generally they should be returned back up through ACPI with a
value of (Ones) to indicate failure condition. This may cause some
features to work incorrectly.</p>
<p>It is also expected that the EC has a watchdog if something on the EC is
hung it should reset and reload on its own. The EC is also responsible
for monitoring that the system is running within safe parameters. The
thermal requests and queries are meant to be advisory in nature and EC
should be able to run independently and safely without any intervention
from the OS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<h4 id="ready-to-go-hands-on"><a class="header" href="#ready-to-go-hands-on"><em>Ready to go hands-on?</em></a></h4>
<p>Later in this book we will be writing real embedded code for real hardware, using one of many easily sourced and affordable development boards, such as the <a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3Discovery Board</a>, which is used in the Rust Embedded Book and is suitable for the exercises we will conduct here.</p>
<p>If you have a different development board, that's fine -- the examples are not really tied to any particular piece of  hardware, and only minor adjustments may be needed to adapt the instructions here to different hardware.</p>
<p>If you are new to embedded programming in Rust, you may find the guide and excercises in the
<a href="https://doc.rust-lang.org/stable/embedded-book/start">Rust Embedded Book</a> to be a great introduction.</p>
<p>Once we have learned the basic principles of how to use the Rust language in an embedded environment, and have set up the tooling, we are ready to move into the ODP framework to structure our designs.</p>
<p>Continue your journey with the <a href="intro/tutorial/./tutorial/Discovery.html">Discovery board</a>, which bridges familiar embedded projects and EC-style service structure.</p>
<h4 id="not-ready-to-go-hands-on"><a class="header" href="#not-ready-to-go-hands-on"><em><strong>Not</strong> ready to go hands-on?</em></a></h4>
<p>That's okay -- but you might want to look through this quick tutorial anyway because it contains key examples of the ODP construction patterns in practice.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="our-first-odp-style-handler-pair-with-faked-bus-semantics"><a class="header" href="#our-first-odp-style-handler-pair-with-faked-bus-semantics">Our first ODP-Style handler pair (with faked bus semantics)</a></h2>
<p>The microcontrollers used for Embedded Controller purposes are not the same ones used
in the example resources referenced by the Rust Book, but if you've started there then
you may already have a STM32F3 microcontroller Discovery board and you may have even played with it to blink the LED lights or some other exercises.</p>
<p>Let's build on what we already know from experimenting with the STM32F3 exercises from the Rust Book.</p>
<p>We already know we can use the tooling setup we have to write code for the STM32F3 that will light one of its LED displays when the user button is pressed.<br />
Code to do exactly that can be found in <a href="intro/tutorial/stm32f3-discovers/examples/button.rs">stm32f3-discovers/examples/button.rs</a> of the development board resources.</p>
<p>That code looks like this:</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;
use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::delay::Delay;
use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;

use stm32f3_discovery::button::UserButton;
use stm32f3_discovery::leds::Leds;
use stm32f3_discovery::switch_hal::{InputSwitch, OutputSwitch};

#[entry]
fn main() -&gt; ! {
    let device_periphs = pac::Peripherals::take().unwrap();
    let mut reset_and_clock_control = device_periphs.RCC.constrain();

    let core_periphs = cortex_m::Peripherals::take().unwrap();
    let mut flash = device_periphs.FLASH.constrain();
    let clocks = reset_and_clock_control.cfgr.freeze(&amp;mut flash.acr);
    let mut delay = Delay::new(core_periphs.SYST, clocks);

    // initialize user leds
    let mut gpioe = device_periphs.GPIOE.split(&amp;mut reset_and_clock_control.ahb);
    let leds = Leds::new(
        gpioe.pe8,
        gpioe.pe9,
        gpioe.pe10,
        gpioe.pe11,
        gpioe.pe12,
        gpioe.pe13,
        gpioe.pe14,
        gpioe.pe15,
        &amp;mut gpioe.moder,
        &amp;mut gpioe.otyper,
    );
    let mut status_led = leds.ld3;

    // initialize user button
    let mut gpioa = device_periphs.GPIOA.split(&amp;mut reset_and_clock_control.ahb);
    let button = UserButton::new(gpioa.pa0, &amp;mut gpioa.moder, &amp;mut gpioa.pupdr);

    loop {
        delay.delay_ms(50u16);

        match button.is_active() {
            Ok(true) =&gt; {
                status_led.on().ok();
            }
            Ok(false) =&gt; {
                status_led.off().ok();
            }
            Err(_) =&gt; {
                panic!("Failed to read button state");
            }
        }
    }
}</code></pre></pre>
<p>Of course, the STM32F3 is <em>not</em> an EC and we certainly would have little use for flashing lights on one if it were, but the basic process and principles are the same, and since we already know how to flash the lights, we can use this as a good way to show how and why the ODP framework fits into the scheme.</p>
<p>Let's first posit that the LED and the user button are two separate peripheral components.  As such, we probably want two separate ODP handlers to address these, and then some business logic to tie them together.  Let's start with the user button.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="addressing-the-user-button"><a class="header" href="#addressing-the-user-button">Addressing the user button</a></h3>
<p>The user button of the STM32F3 will trigger an interrupt signal that can be intercepted
by code to react to the button being pressed.</p>
<p>In the environment of an EC attached to an ACPI (or other transport) bus, the controller would be listening to / contributing to signals on that bus.</p>
<p>Recall our diagram of how EC components are attached to the bus through abstraction layers:</p>
<pre class="mermaid">flowchart TB
HW(Hardware) --&gt; ACPI(ACPI) --&gt; HAL(HAL) --&gt; Listener(Listener)
</pre>
<p>In this example, we’re not using an actual ACPI or I²C bus, but we can simulate the idea of signal propagation and component decoupling using shared memory and interrupts.</p>
<p>We'll listen to the button interrupt and place a signal into a memory address that is accessible by both our button producer and our LED consumer.  This will take the place
of the ACPI for us here.  In later excercises we'll explore the mappings to the ACPI and the ASL layers in a real Embedded Controller environment.</p>
<p>So let's create that button producer code.  It will wait for the interrupt that signals the button action and it will set an
AtomicBool at a location in memory named USER_BUTTON_PRESSED that we can interrogate at the listener side.</p>
<h6 id="buttonhandlerrs"><a class="header" href="#buttonhandlerrs">ButtonHandler.rs</a></h6>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;

use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::interrupt;
use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;
use stm32f3_discovery::wait_for_interrupt;

use core::sync::atomic::{AtomicBool, Ordering};
use stm32f3_discovery::button;
use stm32f3_discovery::button::interrupt::TriggerMode;

use stm32f3_discovery::leds::Leds;
use stm32f3_discovery::switch_hal::ToggleableOutputSwitch;


// this will be imported into the listener code for direct visibility rather than transmitting through a bus
static USER_BUTTON_PRESSED: AtomicBool = AtomicBool::new(false);

#[interrupt]
fn EXTI0() {
    //If we don't clear the interrupt to signal it's been serviced, it will continue to fire.
    button::interrupt::clear();
    // pa0 has a low pass filter on it, so no need to debounce in software
    USER_BUTTON_PRESSED.store(true, Ordering::SeqCst);
}

fn main() -&gt; ! {

    button::interrupt::enable(
        &amp;device_periphs.EXTI,
        &amp;device_periphs.SYSCFG,
        TriggerMode::Rising,
    );

    loop {
        wait_for_interrupt()
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="provide-an-api-for-controlling-the-lights"><a class="header" href="#provide-an-api-for-controlling-the-lights">Provide an API for controlling the lights</a></h3>
<p>We now have a handler that will tell us when the user has pressed the button, but we still need a way to turn on the lights.
Continuing the theme of ODP-style modularity, we will declare an API for light control here.</p>
<h6 id="ledapirs"><a class="header" href="#ledapirs">LedApi.rs</a></h6>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>let mut status_led;

fn lights_init() -&gt; ! {
    let device_periphs = pac::Peripherals::take().unwrap();
    let mut reset_and_clock_control = device_periphs.RCC.constrain();

    // initialize user leds
    let mut gpioe = device_periphs.GPIOE.split(&amp;mut reset_and_clock_control.ahb);
    let leds = Leds::new(
        gpioe.pe8,
        gpioe.pe9,
        gpioe.pe10,
        gpioe.pe11,
        gpioe.pe12,
        gpioe.pe13,
        gpioe.pe14,
        gpioe.pe15,
        &amp;mut gpioe.moder,
        &amp;mut gpioe.otyper,
    );

    status_led = leds.ld3;

}

fn lights_on() {
    status_led.on().ok();
}

fn lights_off() {
    status_led.off().ok()
}


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="tying-it-together"><a class="header" href="#tying-it-together">Tying it together</a></h3>
<p>We now have integrated a handler that will signal us when the button is pressed, and an API for turning on/off the lights. Let's complete the obvious logic and turn on/off the lights in response to the button.</p>
<h6 id="buttontoledservicers"><a class="header" href="#buttontoledservicers">ButtonToLedService.rs</a></h6>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;

use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;
use stm32f3_discovery::wait_for_interrupt;
use stm32f3_discovery::stm32f3xx_hal::delay::Delay;

mod ButtonHandler; 
mod LedApi;


fn read_user_button() -&gt; bool {
    USER_BUTTON_PRESSED.load(Ordering::SeqCst)
}

#[entry]
fn main() -&gt; ! {

    lights_init()

    let mut delay = Delay::new(core_periphs.SYST, clocks);
    
    loop {
        // give system some breathing room for the interrupt to occur
        delay.delay_ms(50u16);

        // synchronize the light to the button state
        if read_user_button() {
            lights_on()
        } else {
            lights_off()
        }

    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tracks-of-odp"><a class="header" href="#the-tracks-of-odp">The tracks of ODP</a></h1>
<p>ODP is a comprehensive umbrella addressing a span of firmware concerns:</p>
<ul>
<li>Boot Firmware / UEFI  (Patina)</li>
<li>Embedded Controller components and services (EC)</li>
<li>Security firmware and architecture</li>
</ul>
<p>Development efforts for these domains are often not performed by the same teams, and these pieces are often built independently of each other and only brought together in the end.</p>
<p>ODP does not usurp this development paradigm but rather empowers it further through the commonality of the Rust language and tools, and through a shared philosophy of modularity and agility.</p>
<h2 id="how-to-continue-with-this-book"><a class="header" href="#how-to-continue-with-this-book">How to continue with this book</a></h2>
<p>This book is geared to a couple of different distinct audiences.  If you are concerned primarily with any one of the particular 'tracks' of ODP and are interested in a guide to which ODP repositories are relevant for that track, continue with <a href="./what/what.html">What is in ODP?</a></p>
<p>If you are interested in examples of <em>how</em> to develop along any of these tracks, follow the examples in <a href="./laptop/laptop.html">Building a Virtual Laptop</a>, either those relevant to the topic of your interest alone, or follow the entire exercise to build a complete virtual laptop comprised of each of these elements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-in-odp"><a class="header" href="#what-is-in-odp">What is in ODP?</a></h1>
<p>There are over 60 repositories that make up the whole of the ODP umbrella.  Many of these are simply HAL definitions for particular hardware, but others define the critical business logic and data traits that comprise the portable and modular framework ODP provides.  Many of the crates defined by these repositories may be interdependent.
Other repositories represented here define tools and tests that are useful in development.</p>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th><th>Patina</th><th>EC</th><th>Security</th><th>Tooling</th><th>Other</th></tr></thead><tbody>
<tr><td><a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Developing UEFI with Rust</a></td><td><em>(Document)</em> An overview of using ODP Patina and Rust, how to contribute to ODP, and how to setup and build DXE Core components.</td><td>✅</td><td></td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/patina?tab=readme-ov-file#patina">patina</a></td><td>This maintains a library of crates that implement UEFI-like code in Rust. This defines all of the reusable</td><td>✅</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-dxe-core-qemu?tab=readme-ov-file#qemu-dxe-core-binaries">patina-dxe-core-qemu</a></td><td>This repository holds the code responsible for pulling in reusable Rust DXE Core components from the Patina SDK, combining these with locally defined custom components, and building the resulting <code>.efi</code> image that may be loaded into the QEMU emulator.</td><td>✅</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-qemu?tab=readme-ov-file#patina-platform-repository">patina-qemu</a></td><td>This repository supplies a platform wrapper that loads the <code>.efi</code> firmware into QEMU using EDK build tools (<code>stuart_build</code>) from the <code>.efi</code> file indicated at build time.</td><td>✅</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-fw-patcher?tab=readme-ov-file#firmware-rust-patcher">patina-fw-patcher</a></td><td>This repository simplifies the iterative turnaround for incremental builds in a workflow, once one has been established, able to forego the full <code>stuart_build</code> process for each code update.</td><td>✅</td><td></td><td></td><td>✅</td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-mtrr?tab=readme-ov-file#introduction">patina-mtrr</a></td><td>This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</td><td>✅</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-paging?tab=readme-ov-file#cpu-paging-support">patina-paging</a></td><td>Common paging support for various architectures such as ARM64 and X64</td><td>✅</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-services?tab=readme-ov-file#ec-services">embedded_services</a></td><td>Business logic service definitions and code for wrapping and controlling HAL-level component definitions into a service context.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/soc-embedded-controller">soc-embedded-controller</a></td><td>Demonstration of EC firmware built using ODP components</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-batteries?tab=readme-ov-file#embedded-batteries">embedded-batteries</a></td><td>SmartBattery Specification support defining traits for HAL abstraction.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-sensors?tab=readme-ov-file#embedded-sensors">embedded-sensors</a></td><td>Defines the embedded sensors interface for HAL abstraction. Designed for use with <code>embedded-services</code>.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-fans?tab=readme-ov-file#embedded-fans">embedded-fans</a></td><td>HAL definition for fan control. Designed for use with <code>embedded-services</code>.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-power-sequence?tab=readme-ov-file#embedded-power-sequence">embedded-power-sequence</a></td><td>Abstraction of SoC power on/off via firmware control.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-cfu?tab=readme-ov-file#embedded-cfu">embedded-cfu</a></td><td>Implements commands and responses as structs per the Windows CFU spec.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-usb-pd?tab=readme-ov-file#embedded-usb-pd">embedded-usb-pd</a></td><td>common types for usb pd.  May be necessary as a dependency for several <code>embedded-services</code> builds.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-mcu?tab=readme-ov-file#embedded-mcu">embedded-mcu</a></td><td>an agnostic set of MCU-related traits and libraries for manipulating hardware peripherals in a generic way.</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/hid-embedded-controller?tab=readme-ov-file#hid-embedded-controller">hid-embedded-controller</a></td><td>Embedded Controller HID library / HID over I2C demo</td><td></td><td>✅</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ec-test-app?tab=readme-ov-file#ec-test-app">ec-test-app</a></td><td>Test application to exercise EC functionality through ACPI from the OS</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ffa?tab=readme-ov-file#ff-a-firmware-framework-for-armv8-a-profile">ffa</a></td><td>FFA for Rust services running under Hafnium through FF-A</td><td></td><td>✅</td><td>✅</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/haf-ec-service?tab=readme-ov-file#hafnium-ec-service-in-rust">haf-ec-service</a></td><td>Rust services for Hafnium supported EC architectures.</td><td></td><td>✅</td><td>✅</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-mtrr?tab=readme-ov-file#introduction">patina-mtrr</a></td><td>This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</td><td>✅</td><td></td><td>✅</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-paging?tab=readme-ov-file#cpu-paging-support">patina-paging</a></td><td>Common paging support for various architectures such as ARM64 and X64</td><td>✅</td><td></td><td>✅</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/rust-crate-audits?tab=readme-ov-file#open-device-partnerships-rust-crate-audits">rust_crate_audits</a></td><td>Aggregated audits for Rust crates by the Open Device Partnership</td><td></td><td></td><td>✅</td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/uefi-bds">uefi-bds</a></td><td>UEFI Boot Device Selection DXE driver</td><td>✅</td><td></td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/uefi-corosensei">uefi-corosensei</a></td><td>UEFI fork of the corosensei crate</td><td>✅</td><td></td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/modern-payload">modern-payload</a></td><td>Slimmed down UEFI payload</td><td>✅</td><td></td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/slimloader">slimloader</a></td><td>First stage boot loader for AArch64</td><td>✅</td><td></td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ec-slimloader">ec-slimloader</a></td><td>A light-weight stage-one bootloader for loading an app image as configured by ec-slimloader-descriptors</td><td>✅</td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/name">ec-slimloader-descriptors</a></td><td>Boot-time application image management descriptors for enabling multi-image firmware boot scenarios, such as those provided by CFU</td><td>✅</td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/odp-utilites">odp-utilites</a></td><td>A collection of Rust utilities focused on embedded systems development.</td><td></td><td></td><td></td><td>✅</td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/systemview-tracing">systemview-tracing</a></td><td>Support for adding Segger SystemView tracing to ODP projects</td><td></td><td></td><td></td><td>✅</td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/nxp-header">nxp-header</a></td><td>CLI utility to modify binary firmware image file to add NXP image header</td><td></td><td></td><td></td><td>✅</td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq24773">bq24773</a></td><td>Driver for TI BQ24773 battery charge controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25713">bq25713</a></td><td>Driver for TI BQ25713 battery charge controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25730">bq25730</a></td><td>Driver for TI BQ25730 battery charge controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25770g">bq25770g</a></td><td>Driver for TI BQ2577G battery charge controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25773">bq25773</a></td><td>Driver for TI BQ25773 battery charge controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq40z50">bq40z50</a></td><td>Driver for TI BQ40Z50 Li-ion battery pack manager</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tmp108">tmp108</a></td><td>Driver for TI TMP108 digital temperature sensor</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/cec17-data">cec17-data</a></td><td>Single meta-PAC supporting all variants within the MEC/CEC family of MCUs produced by Microchip</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mec17xx-pac">mec17xx-pac</a></td><td>Peripheral Access Crate (PAC) for the Microchip MEC17xx family of MCUs</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt633s-pac">mimxrt633s-pac</a></td><td>Embedded PAC for NXP RT633s MCU</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt685s-pac">mimxrt685s-pac</a></td><td>Rust PAC created with svd2rust for MIMXRT685s family of MCUs</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt685s-examples">mimxrt685s-examples</a></td><td>Collection of examples demonstrating the use of the mimxrt685s-pac crate</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/npcx490m-pac">npcx490m-pac</a></td><td>Embedded PAC for Nuvoton NPCX490M MCU</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/npcx490m-examples">npcx490m-examples</a></td><td>Examples for Nuvoton NPCX490M Embedded PAC</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-regulator">embedded-regulator</a></td><td>Embedded HAL for system voltage regulators</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-keyboard-rs">embedded-keyboard-rs</a></td><td>Driver for embedded system matrix keyboards</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/rt4531">rt4531</a></td><td>Driver for Richtek RT4531 keyboard backlight controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tps65994ae">tps65994ae</a></td><td>Driver for TI TPS65994AE USB-C power delivery controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tps6699x">tps6699x</a></td><td>Driver for TI TPS6699x USB-C power delivery controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/is31fl3743b">is31fl3743b</a></td><td>Driver for Lumissil IS31FL3743B LED matrix controller</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/pcal6416a">pcal6416a</a></td><td>Rust driver for IO Expander pcal6416a</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-imxrt">embassy-imxrt</a></td><td>Embassy HAL for NXP IMXRT MCU family</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-microchip">embassy-microchip</a></td><td>Embassy HAL for Microchip MEC17xx and MEC16xx series MCUs</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-npcx">embassy-npcx</a></td><td>Embassy HAL for Nuvoton NPCX MCU family</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/lis2dw12-i2c">lis2dw12-i2c</a></td><td>Rust driver for STMicroelectronics LIS2DW12 accelerometer</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt600-fcb">mimxrt600-fcb</a></td><td>Flash Control Block for MIMXRT600 MCUs</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/MX25U1632FZUI02">MX25U1632FZUI02</a></td><td>Rust based driver for flash part MACRONIX/MX25U1632FZUI02</td><td></td><td>✅</td><td></td><td></td><td>✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-modern-laptop-using-odp"><a class="header" href="#how-to-build-a-modern-laptop-using-odp">How To Build A Modern Laptop using ODP</a></h1>
<p>This section will present a series of practical examples for creating ODP components for the embedded controller using a commodity-level development board to serve as an ersatz MCU SoC, and implementing a Patina DXE Core and bootloader to start up an operating system on a QEMU host that communicates with the EC. This is done through a series of practical exercises that stand alone as development examples, and come together in the end to create a credible, working integration.</p>
<p>These exercises will:</p>
<ul>
<li>build components for the embedded controller
<ul>
<li>battery, charger and power policy</li>
<li>thermal and sensors</li>
<li>connectivity</li>
<li>security architectures</li>
</ul>
</li>
<li>build components for the DXE Core
<ul>
<li>example component</li>
<li>firmware security</li>
<li>EC coordination</li>
</ul>
</li>
<li>integrate the components into a system
<ul>
<li>set up QEMU as a virtual host</li>
<li>use Patina firmware to boot this virtual host into Windows</li>
<li>coordinate between the boot firmware and the embedded controller</li>
<li>use runtime services to interact with EC services</li>
<li>implement and explore security firmware and architectures</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-development"><a class="header" href="#setting-up-development">Setting up Development</a></h1>
<p>If you are planning on going through these exercises to get a handle on developing components for Patina or the Embedded Controller, you will not need anything more than the Rust toolchain and development tools already described.  You can
build each of the exercises to construct a component in a non-embedded (std) environment and test on your local machine.</p>
<p>However, if you are planning on building for the virtual laptop project, you will need to set up QEMU as the host for the Patina boot firmware, and for EC Components, you will need a development board where you will target your embedded code to run on as a makeshift Embedded Controller.</p>
<p><a href="how/./qemu/qemu_setup_guide.html">QEMU Setup Guide</a></p>
<p><a href="how/...">Embedded Setup Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller-components"><a class="header" href="#embedded-controller-components">Embedded Controller Components</a></h1>
<p><em>TODO</em></p>
<p>The Embedded Controller topic comes first, because this is where most of the modern features live and when we get to Patina, it will need to wait for this to be ready and then also connect to it for certain runtime operations.</p>
<p>Basic idea is to reference the Battery effort currently in place, and the soon to follow Charger and Thermal examples.  This should provide a pretty good blueprint for building a mock or real EC for these components and inspire the pattern for things not covered by the examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-and-power-management"><a class="header" href="#battery-and-power-management">Battery and Power Management</a></h1>
<p>This example shows how to implement a mock battery service as part of the Embedded Controller (EC) power management system.</p>
<p>In this sample, we are going to implement a complete battery service subsystem.</p>
<h2 id="relevant-repositories"><a class="header" href="#relevant-repositories">Relevant Repositories</a></h2>
<p>We don't need to reinvent any wheels here. The ODP resources include ample template code and examples we can refer to for such a task. It is useful to identify which repositories contain these resources:</p>
<h3 id="embedded-services"><a class="header" href="#embedded-services">embedded-services</a></h3>
<p>We've touched on this before in <a href="how/ec/battery/../embedded_services/index.html">Embedded Services</a>, where we examined a Thermal subsystem implementation and explored variations between secure ARM-based and legacy x86_64-based systems.</p>
<p>We'll return to both of these concepts later. For now, we’ll focus on implementing a Battery subsystem and related Power Policy services. After that, we’ll fold in Thermal support and revisit the secure vs. non-secure implementations.</p>
<h3 id="embedded-batteries"><a class="header" href="#embedded-batteries">embedded-batteries</a></h3>
<p>This repository defines the Hardware Abstraction Layer (HAL) for a battery, tailored to the specific IC hardware being targeted. It builds a layered API chain upward, making most of the code portable and reusable across different integrations.</p>
<h3 id="embassy"><a class="header" href="#embassy">embassy</a></h3>
<p>Although our first exercises will be limited to simple desktop tests, we will then be building for an embedded context and that will require us to use features from <a href="https://embassy.dev/">Embassy</a> both directly and indirectly.</p>
<h3 id="soc-embedded-controller"><a class="header" href="#soc-embedded-controller">soc-embedded-controller</a></h3>
<p>This repository provides the core EC functionality, which in this case is centered around power policy and regulation.</p>
<p>We will refer to this later as we work on our own (virtual) battery service implementation.</p>
<p>We’ll begin with the battery service — one of the embedded services — and later return here to integrate our battery into the broader scope of power management.</p>
<hr />
<h3 id="the-smart-battery"><a class="header" href="#the-smart-battery">The Smart Battery</a></h3>
<p>Batteries are ubiquitous in today’s portable devices. With many types of batteries serving various applications and provided by many vendors, the <a href="https://sbs-forum.org/specs/sbdat110.pdf">Smart Battery Data Specification</a> offers a standard to normalize this diversity.</p>
<p>Published by the Smart Battery System Implementers Forum (SBS-IF), this specification defines both electrical characteristics and — more importantly for us — the data and communication semantics of battery state.</p>
<p>Let's explore how this specification informs our implementation.</p>
<h4 id="battery-information"><a class="header" href="#battery-information">Battery Information</a></h4>
<p>A battery provides dynamic information (e.g., remaining charge), static metadata (e.g., make/model/serial/version), and operational parameters (e.g., recommended charge voltage/current).</p>
<p>As explored in <a href="how/ec/battery/...">...</a>, some of this information is exposed through direct hardware interfaces (e.g., GPIO or MMIO), while others originate from firmware logic or are derived dynamically.</p>
<p>Batteries typically report their state over a bus when queried and may also broadcast alarms when thresholds are breached.</p>
<p>The SBS specification outlines these functions that a smart battery should implement. These define a consistent set of data points and behaviors that other power management components can rely on:</p>
<ul>
<li><code>ManufacturerAccess</code> – Optional, manufacturer-specific 16-bit value.</li>
<li><code>RemainingCapacityAlarm</code> – Battery capacity threshold at which an alert should be raised.</li>
<li><code>RemainingTimeAlarm</code> – Estimated time remaining before an alert should be raised.</li>
<li><code>BatteryMode</code> – Flags indicating operational states or supported features.</li>
<li><code>AtRate</code> – Charging/discharging rate used in subsequent time estimations.</li>
<li><code>AtRateTimeToFull</code> – Time to full charge at the given rate.</li>
<li><code>AtRateTimeToEmpty</code> – Time to depletion at the given rate.</li>
<li><code>AtRateTimeOK</code> – Whether the battery can sustain the given rate for at least 10 seconds.</li>
<li><code>Temperature</code> – Battery temperature.</li>
<li><code>Voltage</code> – Battery voltage.</li>
<li><code>Current</code> – Charge or discharge current.</li>
<li><code>AverageCurrent</code> – One-minute rolling average of current.</li>
<li><code>MaxError</code> – Expected error margin in charge calculations.</li>
<li><code>RelativeStateOfCharge</code> – % of full charge capacity remaining.</li>
<li><code>AbsoluteStateOfCharge</code> – % of design capacity remaining.</li>
<li><code>RemainingCapacity</code> – In mAh or Wh, based on a capacity mode flag.</li>
<li><code>FullChargeCapacity</code> – In mAh or Wh, based on capacity mode.</li>
<li><code>RunTimeToEmpty</code> – Estimated minutes remaining.</li>
<li><code>AverageTimeToEmpty</code> – One-minute average of minutes to empty.</li>
<li><code>AverageTimeToFull</code> – One-minute average of minutes to full charge.</li>
<li><code>BatteryStatus</code> – Flags indicating current state conditions.</li>
<li><code>CycleCount</code> - Number of cycles (a measure of wear). A cycle is the amount of discharge approximately equal to the value of the DesignCapacity.</li>
<li><code>DesignCapacity</code> - The theoretical capacity of a new battery pack.</li>
<li><code>DesignVoltage</code> - The theoritical voltage of a new battery pack.</li>
<li><code>SpecificationInfo</code> - Version and scaling specification info</li>
<li><code>ManufactureDate</code> - The data of manufacture as a bit-packed integer</li>
<li><code>SerialNumber</code> - the manufacturer assigned serial number of this battery pack.</li>
<li><code>ManufacturerName</code> - Name of the manufacturer</li>
<li><code>DeviceName</code> - Name of battery model.</li>
<li><code>DeviceChemistry</code> - String defining the battery chemical type</li>
<li><code>ManufacturerData</code> - (optional) proprietary manufacturer data.</li>
</ul>
<p>Please refer to the actual specification for details.  For example, functions referring to capacity may report in either current (mAh) or wattage (Wh) depending upon the current state of the CAPACITY_MODE flag (found in BatteryMode).</p>
<p>Some systems may support removable batteries, and such conditions must be accounted for in those designs.</p>
<hr />
<h2 id="a-mock-battery"><a class="header" href="#a-mock-battery">A Mock Battery</a></h2>
<p>In our example, we will use a microcontroller board as our EC but will not focus on real battery or charger hardware at this stage.</p>
<p>This allows us to begin development without sourcing specific hardware while still implementing nearly all of the system’s behavior. In the end, we will have a fully functional—albeit artificial—battery subsystem.</p>
<p>Once complete, this mock can be replaced with hardware-specific IO bindings, without requiring changes to the higher-level system logic.</p>
<p>Next we will look at what resources in the ODP repositories we will be working with as we build our battery implementation.</p>
<!--[Return to Library](../../Library.html) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mock-battery-project"><a class="header" href="#a-mock-battery-project">A Mock Battery Project</a></h1>
<p>In the previous section, we saw how the <em>Smart Battery Specification (SBS)</em> defines a set of functions that a Smart Battery service should implement.</p>
<p>In this section, we are going to review how these traits are defined in Rust within the <a href="https://github.com/OpenDevicePartnership/embedded-services/">embedded-services repository</a>, and we are going to import these structures into our own workspace as we build our mock battery.
In subsequent sections we'll connect the battery into the supporting upstream EC service framwork.</p>
<h2 id="setting-up-for-development"><a class="header" href="#setting-up-for-development">Setting up for development</a></h2>
<p>We are going to create a project space that contains a folder for our battery code, and the dependent repository clones.</p>
<p>So, start by finding a suitable location on your local computer and create the workpace:</p>
<pre><code>mkdir battery_project
cd battery_project
git init
</code></pre>
<p>This will create a workspace root for us and establish it as a git repository (not attached).</p>
<p>Now, we are going to bring the embedded-batteries directory
into our workspace and build the crates it exports.</p>
<p><em>(from the <code>battery_project</code> directory):</em></p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-batteries
</code></pre>
<p>Now, we can create our project space and start our own work.  Within the battery_project directory, create a folder named mock_battery and give it this project structure:</p>
<pre><code>mock_battery/
  src/ 
   - lib.rs
   - mock_battery.rs
  Cargo.toml 
  
Cargo.toml  
</code></pre>
<p>note there are two <code>Cargo.toml</code> files here. One is within the <code>battery_project</code> root folder and the other is at the root of <code>mock_battery</code>.  The <code>mock_battery.rs</code> file resides within the <code>mock_battery/src</code> directory.</p>
<p>The contents of the <code>battery_project/Cargo.toml</code> file should contain:</p>
<pre><code>[workspace]
resolver = "2"
members = [
    "mock_battery"
]

</code></pre>
<p>and the contents of the <code>battery_project/mock_battery/Cargo.toml</code> file should be set to:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
</code></pre>
<p>This structure and the <code>Cargo.toml</code> definitions just define a minimal skeleton for the dependencies we will be adding to as we continue to build our mock battery implementation and work it into the larger ODP framework.</p>
<p>The <code>lib.rs</code> file is used to tell Rust which modules are part of the project. Set it's contents to:</p>
<pre><code>pub mod mock_battery;
</code></pre>
<p>the <code>mock_battery.rs</code> file can be empty for now.  We will define its contents in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-odp-repositories-for-defined-battery-traits"><a class="header" href="#using-the-odp-repositories-for-defined-battery-traits">Using the ODP repositories for defined Battery Traits</a></h1>
<p>In the previous step we set up our project workspace so that we can import from the ODP framework. In this step we will define the traits that our mock battery will expose.</p>
<h1 id="implementing-the-defined-traits"><a class="header" href="#implementing-the-defined-traits">Implementing the defined traits</a></h1>
<p>From the overview discussion you will recall that the SBS specification defines the Smart Battery with a series of functions that will return required data in expected ways.
Not surprisingly, then, we will find that the embedded-batteries crate we have imported defines these functions as traits to a SmartBattery trait.  If you are new to Rust, recall that if this were, say, C++ or Java, we would call this the SmartBattery <em>class</em>, or an <em>interface</em>.  These are <em>almost</em> interchangeable terms, but there are differences.  See <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">this definition</a> for more detail on that.</p>
<p>If we look through the <code>embedded-batteries</code> repository, we will see the SmartBattery trait defines the same functions we saw in the specification (except for the optional proprietary manufacturer facilitations).</p>
<p>So our job now is to implement these functions with data that comes from our battery - our Mock Battery.</p>
<p>We'll start off our <code>mock_battery.rs</code> file with this:</p>
<pre><code>use embedded_batteries::smart_battery::{
    SmartBattery, CapacityModeValue, CapacityModeSignedValue, BatteryModeFields,
    BatteryStatusFields, SpecificationInfoFields, ManufactureDate, ErrorType, 
    ErrorKind
};

#[derive(Debug)]
pub enum MockBatteryError {}

impl core::fmt::Display for MockBatteryError {
    fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
        write!(f, "MockBatteryError")
    }
}

use embedded_batteries::smart_battery::Error;

impl Error for MockBatteryError {
    fn kind(&amp;self) -&gt; ErrorKind {
        ErrorKind::Other
    }    
}

pub struct MockBattery;

impl ErrorType for MockBattery {
    type Error = MockBatteryError;
}

impl SmartBattery for MockBattery {
    fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    fn set_remaining_capacity_alarm(&amp;mut self, _val: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn set_remaining_time_alarm(&amp;mut self, _val: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::default())
    }

    fn set_battery_mode(&amp;mut self, _val: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    fn set_at_rate(&amp;mut self, _val: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    fn temperature(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2950) // 29.5°C in deciKelvin
    }

    fn voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7500) // mV
    }

    fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1500)
    }

    fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1400)
    }

    fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(1)
    }

    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }

    fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(85)
    }

    fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4200))
    }

    fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4800))
    }

    fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(60)
    }

    fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(75)
    }

    fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(30)
    }

    fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2000)
    }

    fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(8400)
    }

    fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::default())
    }

    fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(100)
    }

    fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(5000))
    }

    fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7800)
    }

    fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::default())
    }

    fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(12345)
    }

    fn manufacturer_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MockBatteryCorp";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MB-4200";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_chemistry(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"Li-Ion";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }
}

</code></pre>
<p>Yes, that's a bit long, but it's not particularly complex.
We'll unpack what all this is in a moment.  For now, let's verify this Rust code is valid and that we've imported from the ODP repository properly.</p>
<p>Type</p>
<pre><code>cargo build
</code></pre>
<p>at the project root.
This should build without error.</p>
<h2 id="whats-in-there"><a class="header" href="#whats-in-there">What's in there</a></h2>
<p>The code in <code>mock_battery.rs</code> starts out with a <code>use</code> statement that imports what we will need from the <code>embedded-batteries::smart_battery</code> crate.</p>
<p>The next section defines a simple custom error type for use in our mock battery implementation. This MockBatteryError enum currently has no variants — it serves as a placeholder that allows our code to conform to the expected error traits used by the broader embedded_batteries framework.</p>
<p>By implementing core::fmt::Display, we ensure that error messages can be printed in a readable form (here, just "MockBatteryError"). Then, by implementing the embedded_batteries::smart_battery::Error trait, we allow this error to be returned in contexts where the smart battery interface expects a well-formed error object. The .kind() method returns ErrorKind::Other to indicate a generic error category.</p>
<p>This scaffolding allows our mock implementation to slot into the service framework cleanly, even if the actual logic is still forthcoming.</p>
<p>Finally, we get to the SmartBattery implementation for our MockBattery.  As you might guess, this simply implements each of the functions of the trait as declared, by simply returning an arbitrary representative return value for each.  We'll make these values more meaningful later, but for now, it's pretty minimalist.</p>
<h2 id="now-to-expose-this-to-the-service"><a class="header" href="#now-to-expose-this-to-the-service">Now to expose this to the service</a></h2>
<p>We have defined the battery traits and given our simulated placeholder values for our mock battery here.
If we were implementing a real battery, the process would follow the same pattern except that instead of the literal values we've assigned, we would
call upon our Hardware Abstraction Layer (HAL) implementation modules to pull these values from the actual hardware circuitry, per manufacturer design (i.e. GPIO or MMIO).
But before any of this is useful, it needs to be exposed to the service layer.  In the next step, we'll do a simple test that shows we can expose these values, and then we'll implement the service layer that conveys these up the chain in response to service messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-values"><a class="header" href="#battery-values">Battery values</a></h1>
<p>In the previous step, we defined the traits of our mock battery.  In this step, we will begin to implement the service layer that defines the messaging between the battery and the controller controller service.</p>
<p>Before we implement the actual service, however, let's write a quick test/example to illustrate these values being extracted from our battery traits.</p>
<h2 id="create-mainrs-file-for-mock_battery"><a class="header" href="#create-mainrs-file-for-mock_battery">Create main.rs file for mock_battery</a></h2>
<p>In your mock_battery project create <code>src/main.rs</code> with this content:</p>
<pre><code>use mock_battery::mock_battery::MockBattery;
use embedded_batteries::smart_battery::SmartBattery;

fn main() {
    let mut battery = MockBattery;

    let voltage = battery.voltage().unwrap();
    let soc = battery.relative_state_of_charge().unwrap();
    let temp = battery.temperature().unwrap();

    println!("Voltage: {} mV", voltage);
    println!("State of Charge: {}%", soc);
    println!("Temperature: {} deci-K", temp);
}
</code></pre>
<p>and type <code>cargo run</code> to build and execute it.
After it builds and runs successfully, you should see output similar to this:</p>
<pre><code>Voltage: 7500 mV
State of Charge: 88%
Temperature: 2950 deci-K
</code></pre>
<p>Note that you can execute <code>Cargo run</code> in this case both from either the <code>battery_project/mock_battery</code> or <code>battery_project</code> directories.<br />
As we continue with the integration, we will only be able to build and execute from the <code>battery_project</code> root, so you may want to get used to running from there.</p>
<p>We're going to replace this main.rs very shortly in an upcoming step, and this print to console behavior will be removed.  But for now it's a good sanity check of what you have built so far.
Later, we'll turn checks like this into meaningful unit tests.</p>
<p>We'll move ahead with forwarding this information up to the battery service controller,
but for now, pat yourself on the back, pour yourself a cup of coffee, and take a moment to review the pattern you have walked through:</p>
<ul>
<li>Identified the traits needed for the battery per spec as reflected in the <code>SmartBattery</code> trait imported from the ODP embedded-batteries repository</li>
<li>Implemented a HAL layer to retrieve these values from the hardware (We conveniently skipped this part because this is a mock battery)</li>
<li>Implemented the traits to return these values per the <code>SmartBattery</code> trait</li>
<li>Created a simple sanity check to prove these values are available at runtime.</li>
</ul>
<p>Next, we'll look at the ODP embedded-services repository and the battery-service support we find there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-for-the-embedded-target"><a class="header" href="#building-for-the-embedded-target">Building for the Embedded Target</a></h1>
<p>We've validated our simplistic mock battery has implemented basic traits, and we've been able to do that with a generic build on the desktop.
To go much further, we need to start building for the embedded controller context that this component is designed to run as - targeted for a microcontroller, without standard library dependencies.</p>
<p>Which development board we use at this point isn’t critical. Our mock battery and simulated components will remain software-only for now, so we don’t need physical hardware peripherals or a fully implemented HAL. Later, when we explore advanced features like ARM TrustZone or Hafnium hypervisor integration, we may need a specific Cortex-M board — but those can be hard to source. So rather than lock ourselves in too early, we’ll keep this next section general and adaptable to what you may already have.</p>
<p>In particular, if you've followed the excellent  <a href="https://docs.rust-embedded.org/book/">Rust Embedded Book</a>, there's a good chance you already have an STM32 Discovery board on hand. These boards are inexpensive, well-supported, and ideal for this stage of development.</p>
<p>The examples here will use the STM32F3 Discovery board. If you're using a different board, you may need to adjust your configuration accordingly. That said, our code will aim to be as portable and HAL-independent as possible.</p>
<h2 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h2>
<p>To build for an embedded target, we need to prepare our development environment with a few important tools and configuration files.</p>
<p>While there are many variations depending on target board and host OS, we will aim to keep this setup as broadly compatible and standard as possible.</p>
<h3 id="installing-the-embedded-rust-toolchain"><a class="header" href="#installing-the-embedded-rust-toolchain">Installing the Embedded Rust Toolchain</a></h3>
<p>The standard Rust toolchain needs a few additions to suppor cross-compiling for emedded targets.</p>
<p>Staying within your current <code>battery_project</code> workspace,
run</p>
<pre><code>rustup target add thumbv7em-none-eabihf
</code></pre>
<h3 id="including-embassy"><a class="header" href="#including-embassy">Including Embassy</a></h3>
<p>Many of the embedded features supported by ODP rely on dependencies of Embassy, and we will also want to use many of Embassy's framework support to simplify our construction.
To keep things as consistent as possible, we will be bringing in the Embassy repository as another submodule, similar to what we did with <code>embedded-batteries</code></p>
<p>At the <code>battery_project</code> root:</p>
<pre><code>git submodule add https://github.com/embassy-rs/embassy.git
</code></pre>
<h3 id="updating-the-configuration-files"><a class="header" href="#updating-the-configuration-files">Updating the configuration files</a></h3>
<p>In <code>mock_battery/Cargo.toml</code>, update the contents to look like this:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embassy-executor = { path = "../embassy/embassy-executor", optional = true }

[features]
default = ["embedded"]
embedded = ["embassy-executor"]
</code></pre>
<p>At the top-level Cargo.toml (<code>battery_project/Cargo.toml</code>), update the workspace members to include the new local crates:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embassy/embassy-executor"
]
</code></pre>
<p>Now you should be able to build with</p>
<pre><code>cargo build
</code></pre>
<p>That should build properly.
Now let's see if we can target our embedded toolchain.
enter</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>This will produce a number of errors because we still have the old <code>println!</code> statements in there from the previous example.
We also need to better prepare the code for a "no-std" environment.</p>
<p>Replace the current <code>main.rs</code> content with this new version:</p>
<pre><code>#![no_std]
#![no_main]

use embedded_batteries::smart_battery::SmartBattery;
use mock_battery::mock_battery::MockBattery;
use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let mut battery = MockBattery;

    let _ = battery.voltage();
    let _ = battery.relative_state_of_charge();
    let _ = battery.temperature();

    loop {}
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>You can see we're not only not printing anything to the output here, we have specifically declared <code>#![no_std]</code> and provided a <code>#[panic_handler]</code> that normally would be supplied by std.</p>
<p>One more thing to do.  In <code>lib.rs</code>, add <code>#![no_std]</code> at the top of that file as well.</p>
<pre><code>#![no_std]
pub mod mock_battery;
</code></pre>
<p>Now</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>should build without issue.</p>
<p>In the next section, we will look at writing Unit Tests to prove out the behaviors of our mock battery and provide some simulation of charge behaviors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-preparation"><a class="header" href="#battery-service-preparation">Battery Service Preparation</a></h1>
<p>We've successfully exposed and proven our implementation of battery traits and their values for our mock battery,
and built for an embedded target.
In this step, we'll continue our integration by connecting to a battery service, but that requires some setup to cover first.</p>
<h2 id="battery-service"><a class="header" href="#battery-service">Battery-service</a></h2>
<p>The ODP repository <code>embedded-services</code> has the <code>battery-service</code> we need for this, as well as the power-policy infracture support that uses it.</p>
<p>The ODP repository <code>embedded-cfu</code> is also needed here,
as is <code>embedded-usb-pd</code>.</p>
<p>We will bring these into our scope now.</p>
<p>In the <code>battery_project</code>, we'll bring these in with the commands:</p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-services

git submodule add git@github.com:OpenDevicePartnership/embedded-cfu

git submodule add git@github.com:OpenDevicePartnership/embedded-usb-pd

</code></pre>
<h3 id="a-mock-battery-device"><a class="header" href="#a-mock-battery-device">A Mock Battery Device</a></h3>
<p>To fit the design of the ODP battery service, we first need to create a wrapper that contains our MockBattery and a Device Trait.  We need to implement <code>DeviceContainer</code> for this wrapper and reference that <code>Device</code>.
Then we will register the wrapper with <code>register_device(...)</code> and we will have an async loop that awaits commands on the <code>Device</code>'s <code>channel</code>, executes them, and updates state.</p>
<h4 id="import-the-battery-service-from-the-odp-crate"><a class="header" href="#import-the-battery-service-from-the-odp-crate">Import the battery-service from the ODP crate</a></h4>
<p>One of the service definitions from the <code>embedded-services</code> repository we brought into scope is the <code>battery-service</code>.
We now need to update our Cargo.toml to know where to find it.
Open the <code>Cargo.toml</code> file of your mock-battery project and add the dependency to the battery-service path to our Cargo.toml.  We will also need a reference to <code>embedded-services</code> itself for various support needs.  Update your <code>mock_battery/Cargo.toml</code> so that your <code>[dependencies]</code> section now looks like this:</p>
<pre><code>[dependencies]
cortex-m-rt = "0.7.3"
static_cell = "2.0.0"
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embedded-batteries-async = { path = "../embedded-batteries/embedded-batteries-async" }
battery-service = { path = "../embedded-services/battery-service" }
embedded-services = { path = "../embedded-services/embedded-service" }
</code></pre>
<p>This will allow us to import what we need for the next steps.</p>
<h3 id="define-the-mockbatterydevice-wrapper"><a class="header" href="#define-the-mockbatterydevice-wrapper">Define the MockBatteryDevice wrapper</a></h3>
<p>In your mock_battery project <code>src</code> folder, create a new file named <code>mock_battery_device.rs</code> and give it this content:</p>
<pre><code>use crate::mock_battery::MockBattery;
use embedded_services::power::policy::DeviceId;
use embedded_services::power::policy::action::device::AnyState;
use embedded_services::power::policy::device::{
    Device, DeviceContainer, CommandData, ResponseData//, State
};
// use embedded_services::intrusive_list::Node;


pub struct MockBatteryDevice {
    #[allow(dead_code)] // Prevent unused warning for MockBattery -- not used yet   
    battery: MockBattery,
    device: Device,
}

impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }

    pub fn device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }

    pub async fn run(&amp;self) {
        loop {
            let cmd = self.device.receive().await;

            // Access command using the correct method
            let request = &amp;cmd.command; 

            match request {
                CommandData::ConnectConsumer(_cap) =&gt; {
                    // println!("Received ConnectConsumer for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    // Safe placeholder: detach any existing state
                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::ConnectProvider(_cap) =&gt; {
                    // println!("Received ConnectProvider for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::Disconnect =&gt; {
                    // println!("Received Disconnect");

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; {
                            // println!("Already disconnected or idle");
                        }
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }
            }
        }
    }
}

impl DeviceContainer for MockBatteryDevice {
    fn get_power_policy_device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }
}
</code></pre>
<p>What we've done here is:</p>
<ul>
<li>
<p>Imported what we need from the ODP repositories for both the SmartBattery definition from <code>embedded-batteries</code> and the battery service components from <code>embedded-services</code> crates as as our own local MockBattery definition.</p>
</li>
<li>
<p>Define and implement our MockBatteryDevice</p>
</li>
<li>
<p>implement a run loop for our MockBatteryDevice</p>
</li>
</ul>
<p>Note also there are some commented-out <code>println!</code> macros. We can't use <code>println!</code> in our embedded context, but we'll deal with that later. For now these comments serve as placeholders.</p>
<h4 id="including-mock_battery_device"><a class="header" href="#including-mock_battery_device">Including mock_battery_device</a></h4>
<p>Just like we had to inform the build of our mock_battery, we need to do likewise with mock_battery_device.  So edit <code>lib.rs</code> and to this:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
</code></pre>
<p><strong>Important</strong>: Note that we also added <code>#![no_std]</code> at the top of this <code>lib.rs</code> file.  This is necessary to insure that our build is not expecting the defaults from std to be available.</p>
<h4 id="updating-the-dependencies"><a class="header" href="#updating-the-dependencies">Updating the dependencies</a></h4>
<p>We now must make some edits to our top-level <code>battery_project/Cargo.toml</code> file to reflect the new dependencies.</p>
<p>Add the references to our embedded-services dependencies to <code>members</code> list of the <code>[workspace]</code> section so it now has all our new members:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embedded-batteries/embedded-batteries-async",
    "embedded-services/embedded-service",
    "embedded-services/battery-service",
    "embedded-cfu",
    "embedded-usb-pd",
    "embassy/embassy-executor",
    "embassy/embassy-futures",
    "embassy/embassy-sync",
    "embassy/embassy-time",
    "embassy/embassy-time-driver"
]
</code></pre>
<p>and create a new <code>[workspace.depedencies]</code> section in this file as well:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
</code></pre>
<p>This reconciles the name from 'embedded-service' to 'embedded-services'.</p>
<h2 id="-dependency-detour-manual-overrides-required--"><a class="header" href="#-dependency-detour-manual-overrides-required--">🛠️🧩 Dependency Detour: Manual Overrides Required 🧩 🛠️</a></h2>
<p>At this point, you'll encounter a wall of configuration.
If you try to build here you will get an error about an failure to inherit a workspace dependency or else a dependency not found.  This is due to the need to match the configurations for the crates we are importing.  You can use tools like <code>cargo search</code> to show the current version of dependencies, for example, and tackle these one at a time, but in the interest of efficiency, just copy what is shown here, because there is a lot.</p>
<p>Unfortunately, the current structure of the service crates requires us to explicitly patch and align many transitive dependencies to avoid conflicts—especially around async runtime and HAL crates.</p>
<p>This may feel excessive, but it’s a one-time setup step to align everything cleanly for builds targeting either desktop or embedded systems. Once it’s in place, the rest of the work proceeds smoothly.</p>
<p>Your top-level Cargo.toml at <code>battery_project/Cargo.toml</code> should have a full <code>[workspace.dependencies]</code> section that looks like this:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
defmt = "1.0"
embassy-executor = { path = "embassy/embassy-executor" }
embassy-futures = { path = "embassy/embassy-futures" }
embassy-sync = { path = "embassy/embassy-sync" }
embassy-time = { path = "embassy/embassy-time" }
embassy-time-driver = { path = "embassy/embassy-time-driver" }
embedded-batteries-async = { path = "embedded-batteries/embedded-batteries-async" }
embedded-cfu-protocol = { path = "embedded-cfu" }
embedded-usb-pd = { path = "embedded-usb-pd" }

embedded-hal = "1.0.0"
embedded-hal-async = "1.0.0"
log = "0.4"
bitfield = "0.17.0"
bitflags = "2.8.0"
bitvec = { version = "1.0.1", default-features = false }
cfg-if = "1.0.0"
chrono = { version = "0.4", default-features = false }
cortex-m = "0.7.6"
cortex-m-rt = "0.7.5"
critical-section = "1.1"
document-features = "0.2.7"                    
embedded-hal-nb = "1.0.0"
embedded-io = "0.6.1"
embedded-io-async = "0.6.1"
embedded-storage = "0.3.0"
embedded-storage-async = "0.3.0"
rand_core = "0.9.3"
heapless = { version = "0.7.16", default-features = false }
fixed = { version = "1.23.1", default-features = false }
postcard = { version = "1.1.1", default-features = false }
serde = { version = "1.0.219", default-features = false, features = ["derive"] }
</code></pre>
<p>After you've done all that,  you should be able to build with</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>and get a clean result</p>
<p>Next we will work to put this battery to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-registry"><a class="header" href="#battery-service-registry">Battery Service Registry</a></h1>
<p>So far, we've defined our mock battery and wrapped it in Device wrapper so that it is ready to be included in a Service registry.</p>
<p>To do so meant committing to an embedded target build and a no-std environment compatible with the ODP crates and dependencies.</p>
<p>Now it is time to prepare the code we need to put this MockBatteryDevice to work.</p>
<h3 id="looking-at-the-examples"><a class="header" href="#looking-at-the-examples">Looking at the examples</a></h3>
<p>The <code>embedded-services</code> repository has some examples for us to consider already.  In the <code>embedded-services/examples/std</code> folder, particularly in <code>battery.rs</code> and <code>power_policy.rs</code> we can see how devices are created and then registered, and also how they are executed via per-device tasks.  The system is initialized and a runtime <code>Executor</code> is used to spawn the tasks.</p>
<h2 id="-wiring-up-the-battery-service"><a class="header" href="#-wiring-up-the-battery-service">🔌 Wiring Up the Battery Service</a></h2>
<p>We need to create a device <code>Registry</code> as defined by <code>embedded-services</code> to wire our <code>MockBatteryDevice</code> into.</p>
<p>To do this, let's replace our current <code>mock_battery/main.rs</code> with this:</p>
<pre><code>#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embedded_services::init;
use embedded_services::power::policy::{register_device, DeviceId};
use static_cell::StaticCell;
use mock_battery::mock_battery_device::MockBatteryDevice;

use battery_service::{self, device::Device, wrapper::Wrapper};
use mock_battery::mock_battery_controller::MockBatteryController;

#[embassy_executor::main]
async fn async_main(spawner: Spawner) {
    // Required by embedded-services to initialize internals
    init().await;

    // Initialize and register our battery device
    static BATTERY: StaticCell&lt;MockBatteryDevice&gt; = StaticCell::new();
    let battery = BATTERY.init(MockBatteryDevice::new(DeviceId(0)));
    register_device(battery).await.unwrap();
    spawner.must_spawn(battery_run_task(battery));

    static WRAPPER: StaticCell&lt;Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;&gt; = StaticCell::new();


    // Initialize our fuel gauge controller
    static CONTROLLER: StaticCell&lt;MockBatteryController&gt; = StaticCell::new();
    let controller = CONTROLLER.init(MockBatteryController::new());
    
    // Initialize the device used by the battery service wrapper
    static DEVICE: StaticCell&lt;Device&gt; = StaticCell::new();
    let dev = DEVICE.init(Device::new(battery_service::device::DeviceId(1)));

    // Create a wrapper that can process battery service messages
    let wrapper = WRAPPER.init(Wrapper::new(dev, controller));
    // must_spawn will panic if the task fails to spawn, suitable for no_std
    spawner.must_spawn(wrapper_task(wrapper));

    
}

#[embassy_executor::task]
async fn battery_run_task(battery: &amp;'static MockBatteryDevice) {
    battery.run().await;
}


#[embassy_executor::task]
async fn wrapper_task(wrapper: &amp;'static Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;) {
    loop {
        wrapper.process().await;
    }
}

/// Required by embedded targets for panic handling
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>When you execute <code>cargo build --target thumbv7em-none-eabihf</code> you will receive errors, such as
"error: No architecture selected for embassy-executor. Make sure you've enabled one of the <code>arch-*</code> features in your Cargo.toml."</p>
<p>We still have some configuration to do.</p>
<p><code>embassy-executor</code> requires specific selection of the MCU architecture via features.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, remove the line
from the <code>[dependencies]</code> section</p>
<pre><code>embassy-executor = { path = "../embassy/embassy-executor", optional = true }
</code></pre>
<p>and add this section:</p>
<pre><code>[dependencies.embassy-executor]
path = "../embassy/embassy-executor"
features = ["arch-cortex-m", "executor-thread"]
optional = true
</code></pre>
<p>also, add these lines to the <code>[dependencies]</code> section (these references will come up soon):</p>
<pre><code>embassy-time = { path = "../embassy/embassy-time" }
embassy-sync = { path = "../embassy/embassy-sync" }
</code></pre>
<p>and then try again: <code>cargo build --target thumbv7em-none-eabihf</code></p>
<h2 id="the-battery-service"><a class="header" href="#the-battery-service">The Battery Service</a></h2>
<p>Now we have registered our battery device as a device for the embedded-services power policy,
but the <code>battery_service</code> knows how to use a battery specifically, so we need to register our battery as a 'fuel gauge' by that definition.</p>
<h3 id="the-battery-controller"><a class="header" href="#the-battery-controller">The Battery Controller</a></h3>
<p>The battery service <code>Controller</code> is the trait interface used to control a battery connected via the SmartBattery trait interface at a slightly higher level.</p>
<p>Create a new file in <code>mock_battery</code> named <code>mock_battery_controller.rs</code> and give it this content:</p>
<pre><code>use battery_service::controller::{Controller, ControllerEvent};
use battery_service::device::{DynamicBatteryMsgs, StaticBatteryMsgs};
use embassy_time::{Duration, Timer};
use embedded_batteries_async::smart_battery::{
    SmartBattery, ErrorType, 
    ManufactureDate, SpecificationInfoFields, CapacityModeValue, CapacityModeSignedValue,
    BatteryModeFields, BatteryStatusFields, 
    DeciKelvin, MilliVolts
};
use core::convert::Infallible;

pub struct MockBatteryController;

impl MockBatteryController {
    pub fn new() -&gt; Self {
        Self
    }
}

impl ErrorType for MockBatteryController {
    type Error = Infallible;
}

impl SmartBattery for &amp;mut MockBatteryController {
    async fn temperature(&amp;mut self) -&gt; Result&lt;DeciKelvin, Self::Error&gt; {
        Ok(2732) // Stubbed temperature in deci-Kelvin
    }
    // You can stub other SmartBattery methods as needed
    async fn voltage(&amp;mut self) -&gt; Result&lt;MilliVolts, Self::Error&gt; {
        Ok(11000)
    }


    // Stub all other required methods
    async fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn set_remaining_capacity_alarm(&amp;mut self, _: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn set_remaining_time_alarm(&amp;mut self, _: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::new())
    }

    async fn set_battery_mode(&amp;mut self, _: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    async fn set_at_rate(&amp;mut self, _: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    async fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::new())
    }

    async fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::new())
    }

    async fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    async fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn manufacturer_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_chemistry(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }    
}

impl Controller for &amp;mut MockBatteryController {
    type ControllerError = Infallible;

    async fn initialize(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    async fn get_static_data(&amp;mut self) -&gt; Result&lt;StaticBatteryMsgs, Self::ControllerError&gt; {
        Ok(StaticBatteryMsgs { ..Default::default() })
    }

    async fn get_dynamic_data(&amp;mut self) -&gt; Result&lt;DynamicBatteryMsgs, Self::ControllerError&gt; {
        Ok(DynamicBatteryMsgs { ..Default::default() })
    }

    async fn get_device_event(&amp;mut self) -&gt; ControllerEvent {
        loop {
            Timer::after(Duration::from_secs(60)).await;
        }
    }

    async fn ping(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    fn get_timeout(&amp;self) -&gt; Duration {
        Duration::from_secs(10)
    }

    fn set_timeout(&amp;mut self, _duration: Duration) {
        // Ignored for mock
    }
}
</code></pre>
<p>This just implements the SmartBattery traits with stubs for now.  We will connect it to our mock_battery shortly.  But for now, this gets us going past the next few steps.</p>
<h4 id="add-to-librs"><a class="header" href="#add-to-librs">add to <code>lib.rs</code></a></h4>
<p>Don't forget that we need to include this new file in our <code>lib.rs</code> declarations:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
</code></pre>
<p>Make sure you can build cleanly at this point, and then we will move ahead.</p>
<h3 id="the-fuel-gauge"><a class="header" href="#the-fuel-gauge">The fuel gauge</a></h3>
<p>The battery service has the concept of a 'fuel gauge' that calls into the SmartBattery traits to monitor charge / discharge.</p>
<p>We'll hook that up now.</p>
<p>Add this task to your <code>main.rs</code> file, nearby the other tasks found there:</p>
<pre><code>#[embassy_executor::task]
async fn battery_service_init_task(dev: &amp;'static Device) {
    let reg = battery_service::register_fuel_gauge(dev).await;
    if reg.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register fuel gauge device");
    }
}

</code></pre>
<p>and we'll call upon it just after registering the device, so at the end of your <code>async main</code> function, just after <code>spawner.must_spawn(wrapper_task(wrapper));</code>, add this:</p>
<pre><code> 
    // Register the fuel gauge device with the battery service
    spawner.must_spawn(battery_service_init_task(dev));
</code></pre>
<p>Verify you can still build cleanly</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<h3 id="implementing-comms"><a class="header" href="#implementing-comms">Implementing "comms"</a></h3>
<p>The battery service is one of several services that may reside within the Embedded Controller (EC) microcontroller. In a fully integrated system, messages between the EC and other components — such as a host CPU or companion chips — are typically carried over physical transports like SPI or I²C.</p>
<p>However, within the EC firmware itself, services communicate through an internal message routing layer known as comms. This abstraction allows us to test and exercise service logic without needing external hardware.</p>
<p>At this point, we’ll establish a simple comms setup that allows messages to reach our battery service from other parts of the EC — particularly the power policy manager. The overall comms architecture can expand later to handle actual buses, security paging, or multi-core domains, but for now, a minimal local implementation will suffice.</p>
<h4 id="the-espi-comms"><a class="header" href="#the-espi-comms">The "espi" comms</a></h4>
<p>We'll follow a pattern exhibited by the ODP <code>embedded-services/examples/std/src/bin/battery.rs</code>, but trimmed for embedded/no-std use.</p>
<p>Create a file for a module named <code>espi_service.rs</code> inside your <code>mock_battery/src</code> folder and give it this content:</p>
<pre><code>use battery_service::context::{BatteryEvent, BatteryEventInner};
use battery_service::device::DeviceId;
use embassy_sync::blocking_mutex::raw::NoopRawMutex;
use embassy_sync::once_lock::OnceLock;
use embassy_sync::signal::Signal;
use embedded_services::comms::{self, EndpointID, External};
use embedded_services::ec_type::message::BatteryMessage;


pub struct EspiService {
    endpoint: comms::Endpoint,
    _signal: Signal&lt;NoopRawMutex, BatteryMessage&gt;,
}

impl EspiService {
    pub fn new() -&gt; Self {
        Self {
            endpoint: comms::Endpoint::uninit(EndpointID::External(External::Host)),
            _signal: Signal::new(),
        }
    }
}

impl comms::MailboxDelegate for EspiService {
    fn receive(&amp;self, message: &amp;comms::Message) -&gt; Result&lt;(), comms::MailboxDelegateError&gt; {
        let msg = message
            .data
            .get::&lt;BatteryMessage&gt;()
            .ok_or(comms::MailboxDelegateError::MessageNotFound)?;

        match msg {
            BatteryMessage::CycleCount(_count) =&gt; {
                // Do something if needed; placeholder
                Ok(())
            }
            _ =&gt; Err(comms::MailboxDelegateError::InvalidData),
        }
    }
}

static ESPI_SERVICE: OnceLock&lt;EspiService&gt; = OnceLock::new();

pub async fn init() {

    let svc = ESPI_SERVICE.get_or_init(EspiService::new);
    if comms::register_endpoint(svc, &amp;svc.endpoint).await.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register ESPI service endpoint");
    }

}

#[embassy_executor::task]
pub async fn task() {
    let svc = ESPI_SERVICE.get().await;

    let _ = svc.endpoint.send(
        EndpointID::Internal(comms::Internal::Battery),
        &amp;BatteryEvent {
            device_id: DeviceId(1),
            event: BatteryEventInner::DoInit,
        },
    ).await;

    let _ = battery_service::wait_for_battery_response().await;

    loop {
        let _ = svc.endpoint.send(
            EndpointID::Internal(comms::Internal::Battery),
            &amp;BatteryEvent {
                device_id: DeviceId(1),
                event: BatteryEventInner::PollDynamicData,
            },
        ).await;

        let _ = battery_service::wait_for_battery_response().await;

        embassy_time::Timer::after(embassy_time::Duration::from_secs(5)).await;
    }
}
</code></pre>
<p>Before the loop, the DoInit message is sent which will cause <code>Controller::initialize</code> to be invoked via service layer.  The loop runs at 5 second intervals and polls for updates in the dynamic data
(such as the current level of charge).</p>
<p>and, by now I'm sure you know the drill, remember to add this module to your <code>lib.rs</code> file:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
pub mod espi_service;
</code></pre>
<p>Now we will attach it in our <code>main.rs</code> file.</p>
<p>Add this <code>use</code> statement to import it:</p>
<pre><code>use mock_battery::espi_service;
</code></pre>
<p>and these lines at the end of your <code>async main</code> to initialize it and spin it up:</p>
<pre><code>    // Start up our comms
    espi_service::init().await;
    spawner.must_spawn(espi_service::task());
</code></pre>
<h3 id="adding-some-logging-support"><a class="header" href="#adding-some-logging-support">Adding some logging support</a></h3>
<p>We are now in a position to get data from our battery.  But how will we know? We need some logging in place first.  Let's hook that up now.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, add or update these values in their respective sections:</p>
<pre><code>[dependencies]
defmt = "1.0"
defmt-rtt = "0.4"
panic-probe = { version = "0.3", features = ["print-defmt"] }

# Add the log shim for libraries using `log` crate
log = { version = "0.4", features = ["release_max_level_debug"], optional = true }
defmt-log = { version = "0.3", optional = true }

[features]
default = ["embedded", "defmt-log", "log"]

[package.metadata.cargo-xbuild]
linker = "rust-lld"

</code></pre>
<p>We can now remove the <code>#![panic_handler] block in </code>main.rs` altogether and replace it with:</p>
<pre><code>/// Required by embedded targets for panic handling
use panic_probe as _; // This provides a defmt-compatible panic handler
</code></pre>
<p>The panic-probe crate, when built with the print-defmt feature, automatically installs the right panic handler for you — no need to write one manually.</p>
<p>Using the logging is straightforward.  Examples of log statements would be like:</p>
<pre><code>info!("Starting wrapper task");
warn!("Something unusual");
error!("Something failed: {:?}", err);
</code></pre>
<!-- 
Note - this setup for logging is incomplete and turns out to be much more of a rabbit-hole than I could have imagined.
Additionally, major revisions to memory.x and
some of the cargo settings are needed, plus some
stubs for the cortex-m that need to be put into place that are not documented yet before anything
will build correctly to flash to the hardware. 
This is the current WIP and may require a separate section before continuing here.
-->
<h3 id="getting-the-dynamic-data"><a class="header" href="#getting-the-dynamic-data">Getting the dynamic data</a></h3>
<p>So now that we have logging in place,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="charger"><a class="header" href="#charger">Charger</a></h1>
<p><em>TODO</em></p>
<p>This will be an adjunct to the current Battery example, completing the relationship for power management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal"><a class="header" href="#thermal">Thermal</a></h1>
<p><em>TODO</em></p>
<p>This example will closely follow the Battery effort and will tie into the overall EC Services in much the same way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connectivity"><a class="header" href="#connectivity">Connectivity</a></h1>
<p><em>TODO</em></p>
<p>possibly include a USB example
may also include mentions (probably not examples) of WiFi and Bluetooth integration</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>May or may not produce a sample showing implementation of USB. If there is not an example, there will at least be a discussion.</p>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wifi"><a class="header" href="#wifi">WiFi</a></h1>
<p>May or may not produce and example of implementing WiFi...
If no example, there will at least be a discussion.<br />
This <em>might</em> move to Patina, although I think it may need to be on the EC for certain options to be practical. <em>TBD</em></p>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bluetooth"><a class="header" href="#bluetooth">Bluetooth</a></h1>
<p><em>TODO</em></p>
<p>May or may not produce and example of implementing Bluetooth...
If no example, there will at least be a discussion.<br />
This <em>might</em> move to Patina, although I think it may need to be on the EC for certain options to be practical. <em>TBD</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina-components"><a class="header" href="#patina-components">Patina Components</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-evolution-of-uefi-into-patina-with-rust-and-odp-1"><a class="header" href="#the-evolution-of-uefi-into-patina-with-rust-and-odp-1">The Evolution of UEFI into Patina with Rust and ODP</a></h1>
<p><em>Deprecated -- replace</em></p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Firmware and UEFI firmware in particular has long been written in C. Firmware operates in a unique environment to other
system software. It is written to bootstrap a system often at the host CPU reset vector and as part of a chain of
trust established by a hardware rooted immutable root of trust. Modern PC firmware is extraordinarily complex with
little room for error.</p>
<h3 id="firmware-evolution-1"><a class="header" href="#firmware-evolution-1">Firmware Evolution</a></h3>
<p>From a functional perspective, firmware must initialize the operating environment of a device. To do so involves
integrating vendor code for dedicated microcontrollers, security engines, individual peripherals, SOC initialization,
and so on. Individual firmware blobs may be located on a number of non-volatile media with very limited capacity. The
firmware must perform its functional tasks successfully or risk difficult to diagnose errors in higher levels of the
software stack that may impede overall device usability and debuggability.</p>
<p>These properties have led to slow but incremental expansion of host firmware advancements over time.</p>
<p><img src="how/patina/tree/./media/uefi_evolution.png" alt="Host FW Evolution" /></p>
<h3 id="importance-of-security-in-firmware-1"><a class="header" href="#importance-of-security-in-firmware-1">Importance of Security in Firmware</a></h3>
<p>From a security perspective, firmware is an important component in the overall system Trusted Computing Base (TCB).
Fundamental security features taken for granted in later system software such as kernels and hypervisors are often
based on secure establishment in a lower layer of firmware. At the root is a concept of "trust".</p>
<p>While operating systems are attractive targets due to their ubiquity across devices and scale, attackers are
are increasingly viewing firmware as an attack surface in response to increasingly effective security measures
being applied in modern operating systems. While significant research has been devoted across the entire boot process,
UEFI firmware on the host CPU presents a unique opportunity to gain more visibility into early code execution details
and intercept the boot process before essential activities take place such as application of important security register
locks, cache/memory/DMA protections, isolated memory regions, etc. The result is code executed in this timeframe must
carry forward proper verification and measurement of future code while also ensuring it does not introduce a
vulnerability in its own execution.</p>
<h3 id="performance-reliability-in-firmware-1"><a class="header" href="#performance-reliability-in-firmware-1">Performance Reliability in Firmware</a></h3>
<p>From a performance perspective, firmware code is often expected to execute exceedingly fast. The ultimate goal is for
an end user to not even be aware such code is present. In a consumer device scenario, a user expects to press a power
button and immediately receive confirmation their system is working properly. In a server scenario, fleet uptime is
paramount. Poorly written firmware can lead to long boot times that impact virtual machine responsiveness and workload
scaling or, even worse, Denial of Service if the system fails to boot entirely. In an embedded scenario, government
regulations may require firmware to execute fast enough to show a backup camera within a fixed amount of time.</p>
<p>All of this is to illustrate that firmware must perform important work in a diverse set of hardware states with code
that is as small as possible and do so quickly and securely. In order to transition implementation spanning millions of
lines of code written in a language developed over 50 years ago requires a unique and compelling alternative.</p>
<h2 id="rust-and-firmware-1"><a class="header" href="#rust-and-firmware-1">Rust and Firmware</a></h2>
<p>For these reasons, modern PC firmware necessitates a powerful language that can support low-level programming with
maximum performance, reliability, and safety. While C has provided the flexibility needed to implement relatively
efficient firmware code, it has failed to prevent recurring problems around memory safety.</p>
<h3 id="stringent-safety-1"><a class="header" href="#stringent-safety-1">Stringent Safety</a></h3>
<p>Common pitfalls in C such as null pointer dereferences, buffer and stack overflows, and pointer mismanagement continue
to be at the root of high impact firmware vulnerabilities. These issues are especially impactful if they compromise
the system TCB. Rust is compelling for UEFI firmware development because it is designed around strong memory safety
without the usual overhead of a garbage collector. In addition, it enforces stringent type safety and concurrency rules
that prevent the types of issues that often lead to subtle bugs in low-level software development.</p>
<p>Languages aside, UEFI firmware has greatly fallen behind other system software in its adoption of basic memory
vulnerability mitigation techniques. For example, data execution protection, heap and stack guards, stack cookies,
and null pointer dereference detection is not present in the vast majority of UEFI firmware today. More advanced
(but long time) techniques such as Address Space Layout Randomization (ASLR), forward-edge control flow integrity
technologies such as x86 Control Flow Enforcement (CET) Indirect Branch Tracking (IBT) or Arm Branch Target
Identification (BTI) instructions, structured exception handling, and similar technologies are completely absent in
most UEFI firmware today. This of course exacerbates errors commonly made as a result of poor language safety.</p>
<p>Given firmware code also runs in contexts with high privilege level such as System Management Mode (SMM) in x86,
implementation errors can be elevated by attackers to gain further control over the system and subvert other
protections.</p>
<h3 id="developer-productivity-1"><a class="header" href="#developer-productivity-1">Developer Productivity</a></h3>
<p>The Rust ecosystem brings more than just safety. As a modern language firmware development can now participate
in concepts and communities typically closed to firmware developers. For example:</p>
<ul>
<li>
<p>Higher level multi-paradigm programming concepts such as those borrowed from functional programming in addition to
productive polymorphism features such as generics and traits.</p>
</li>
<li>
<p>Safety guarantees that prevent errors and reduce the need for a myriad of static analysis tools with flexibility to
still work around restrictions when needed in an organized and well understood way (unsafe code).</p>
</li>
</ul>
<h3 id="modern-tooling-1"><a class="header" href="#modern-tooling-1">Modern Tooling</a></h3>
<p>Rust includes a modern toolchain that is well integrated with the language and ecosystem. This standardizes tooling
fragmented across vendors today and lends more time to firmware development. Examples of tools and community support:</p>
<ul>
<li>
<p>An official package management system with useful tools such as first-class formatters and linters that reduce
project-specific implementations and focus discussion on functional code changes.</p>
</li>
<li>
<p>High quality reusable bundles of code in the form of crates that increase development velocity and engagement with
other domain experts.</p>
</li>
<li>
<p>Useful compilation messages and excellent documentation that can assist during code development.</p>
</li>
</ul>
<p>Rust's interoperability with C code is also useful. This enables a phased adoption pathway where codebases can start
incorporating Rust while still relying upon its extensive pre-existing code. At the same time, Rust has been conscious
of low-level needs and can precisely structure data for C compatibility.</p>
<h2 id="uefi-rust-in-odp-1"><a class="header" href="#uefi-rust-in-odp-1">UEFI Rust in ODP</a></h2>
<p>UEFI code in ODP plans to participate within the open Rust development community by:</p>
<ol>
<li>Engaging with the broader Rust community to learn best practices and share low-level system programming knowledge.</li>
<li>Leveraging and contributing back to popular crates and publishing new crates that may be useful to other projects.
<ul>
<li>A general design strategy is to solve common problems in a generic crate that can be shared and then integrate it
back into firmware.</li>
</ul>
</li>
<li>Collaborating with other firmware vendors and the UEFI Forum to share knowledge and best practices and
incorporate elements of memory safety languages like Rust into industry standard specifications where appropriate.
Some specifications have interfaces defined around concepts and practices common in unsafe lanuages that could
be improved for safety and reliability.</li>
</ol>
<p>Looking forward, we're continuing to expand the coverage of our firmware code written in Rust. We are excited to
continue learning more about Rust in collaboration with the community and our partners.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-for-patina"><a class="header" href="#setting-up-for-patina">Setting up for Patina</a></h1>
<p>Patina is based upon the foundations of UEFI, and as such, much of the tooling used to build boot firmware
continues to leverage the existing proven tools from Tianocore, such as the <code>stuart_build</code> set of commands, and many other parts familiar within the EDK II framework.</p>
<p>The steps to setting up the tooling can be found documented in the Readme of the <a href="https://github.com/OpenDevicePartnership/patina-qemu">patina-qemu</a> repository, but what is not immediately clear from that discussion is the role that different repositories play.  This is a bit of a marathon, so we'll walk through it here.</p>
<h3 id="the-repositories-involved"><a class="header" href="#the-repositories-involved">The repositories involved</a></h3>
<p>The full umbrella of ODP material encompassses multiple repositories, because ODP covers several diverse aspects of firmware development that speak to different audiences.  Simililarly, the Patina subsection of ODP itself is maintained in multiple repositories, which ones are utilized by a developer will depend upon the goals and scope of a particular project.</p>
<p>The most common Patina-related repositories are as follows</p>
<ul>
<li>
<p><strong>patina</strong> - This maintains a library of crates that implement UEFI-like code in Rust. This defines all of the reusable
'Patina SDK' components that may be pulled into other workflows (such as <em>patina-dxe-core-qemu</em>) to create customized <code>.efi</code> images.</p>
</li>
<li>
<p><strong>patina-dxe-core-qemu</strong> - This repository holds the code responsible for pulling in reusable Rust DXE Core components from the Patina SDK, combining these with locally defined custom components, and building the resulting <code>.efi</code> image that may be loaded into the QEMU emulator.</p>
</li>
<li>
<p><strong>patina-qemu</strong> - This repository supplies a platform wrapper that loads the <code>.efi</code> firmware into QEMU using EDK build tools (<code>stuart_build</code>) from the <code>.efi</code> file indicated at build time.</p>
</li>
<li>
<p><strong>patina-fw-patcher</strong> - This repository simplifies the iterative turnaround for incremental builds in a workflow, once one has been established, able to forego the full <code>stuart_build</code> process for each code update.</p>
</li>
<li>
<p><strong>patina-mtrr</strong> - This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</p>
</li>
<li>
<p><strong>patina-paging</strong> - Common paging support for various architectures such as ARM64 and X64</p>
</li>
</ul>
<p>In this discussion we will be focused on the steps required to build Patina into a QEMU emulator.  We will be primarily concerned
with the <strong>patina-dxe-core-qemu</strong> and <strong>patina-quemu</strong> repositories for this.</p>
<h2 id="preparing-the-workspace-environment"><a class="header" href="#preparing-the-workspace-environment">Preparing the workspace environment</a></h2>
<hr />
<p>_TODO - Rewrite as a guide to how to read the other docs to set up and then come back here.</p>
<p>Note that we'll need to clone or submodule the two repos we need.</p>
<p>Include a note about making sure windows has long path support turned on or alternately creating an alias</p>
<p>Some of the qemu mentions here can go up to the overview_</p>
<hr />
<p>Much of the steps shown here are restructured from the <a href="https://github.com/OpenDevicePartnership/patina-qemu?tab=readme-ov-file#first-time-tool-setup-instructions-for-this-repository">patina-qemu README</a>, but contains a few additional clarifications.</p>
<p>The end result will be a set of Patina rust-based firmware running as a QEMU hosted emulated platform.  Once this is established, we can work with the firmware ourselves and/or we can target an actual platform board instead of the emulator.  But let's not get ahead of ourselves just yet.  First we need to get things into place.</p>
<h2 id="qemu-q35-package"><a class="header" href="#qemu-q35-package">Qemu Q35 package</a></h2>
<p>In these steps, we will be building an emulated platform based on the Intel Q35 chipset. This will demonstrate the Patina UEFI firmware development for x86/64.  The patina-qemu repository also has support for an ARM architecture. Refer there for more information.</p>
<h2 id="preparing-for-stuart"><a class="header" href="#preparing-for-stuart">Preparing for "Stuart"</a></h2>
<p>The EDK II build tool, <code>Stuart</code>, is duplicated in the patina-qemu repository and further leveraged by specific platform build scripts.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>But before we go there, we need to make sure we have Python installed.
For Windows, download the <a href="https://www.python.org/downloads/windows/">official Python installer</a></p>
<p>(For Linux or MacOS, consult available sources for installing Python for your platform).</p>
<p>The installer should install both <code>python</code> and <code>py</code> (python launcher).  Test your installation with</p>
<pre><code>py -0
</code></pre>
<p>This should list the available python versions, and</p>
<pre><code>python --version
</code></pre>
<p>should verify your default python version is available.</p>
<h3 id="patina-qemu"><a class="header" href="#patina-qemu">patina-qemu</a></h3>
<p>Now to get on with building the "Stuart" tools:</p>
<p>Start by cloning the patina-quemu repository to your workspace.</p>
<pre><code>git clone git@github.com:OpenDevicePartnership/patina-qemu.git
</code></pre>
<p>and then we are going to establish a virtual python environment in this space and use it to build the tools.</p>
<p>(Windows)</p>
<pre><code>cd edk2
py -m venv .venv
.venv\Scripts\activate.bat
pip install -r pip-requirements.txt --upgrade
stuart_setup -c .pytool/CISettings.py
</code></pre>
<h2 id="patina-qemu-1"><a class="header" href="#patina-qemu-1">Patina-qemu</a></h2>
<p>Now we are equipped to build from the patina-qemu repository.
Start by cloning the patina-quemu repository to your workspace.</p>
<pre><code>git clone git@github.com:OpenDevicePartnership/patina-qemu.git
</code></pre>
<h3 id="shorten-the-path"><a class="header" href="#shorten-the-path">Shorten the path</a></h3>
<p>On Windows, the build commands reference pathnames that when combined can exceed the maximum allowed path length, so to prevent issues here, we will redirect where we work so that our paths are shorter.</p>
<p>Do this from within the patina-quemu repository root directory:</p>
<pre><code>cd
&lt;this will show you the full path of the repository root, where you are&gt;
subst z: &lt;full path shown above&gt;

cd z:\
z:
</code></pre>
<p>now you should be able to treat your Z:\ location the same as your repository root, but the resulting path names will be shorter.</p>
<h3 id="preparing-and-building"><a class="header" href="#preparing-and-building">Preparing and Building</a></h3>
<p>(from within your new Z:\ location)</p>
<pre><code># Create a Python virtual environment for this workspace
py -e -m venv patina.venv 
# and then activate it
.\patina.venv\Scripts\activate.bat
</code></pre>
<p>Note that there is <code>activate.bat</code> (for cmd) and <code>Activate.ps1</code> (for PowerShell).  Use the one that matches your console shell.</p>
<p>Now install the python dependencies:</p>
<pre><code>pip install --upgrade -r pip-requirements.txt
</code></pre>
<p>Then use the Stuart tools to setup and build:</p>
<pre><code>stuart_setup -c Platforms\QemuQ35Pkg\PlatformBuild.py
stuart_upgrade -c Platforms\QemuQ35Pkg\PlatformBuild.py

</code></pre>
<h3 id="first-and-subsequent-setup"><a class="header" href="#first-and-subsequent-setup">First and subsequent setup</a></h3>
<p>The steps above will create a virtual python environment and install the stuart tools into it.
You should only need to do these steps the one time for your workspace.
On subsequent visits, simply activate the virtual environment again (<code>.\patina.venv\Scripts\activate.bat</code>)
and then proceed with the build and/or run steps.</p>
<p>To build and install into QEMU, include the --FlashRom argument:</p>
<pre><code>stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --FlashRom
</code></pre>
<p>building will take several minutes.  At the end of this you should see a QEMU window that shows a brief splash graphic and then a shell prompt and output showing success.</p>
<p>You will also see a long train of runtime debug output to the console window.  This will exceed the scroll-back buffer of the window so you won't be able to see the first portion of it.  The tail end of this runtime log will likely contain a number of TRACE level warnings at this stage.  We can ignore this output at this time.</p>
<p>To build without running on QEMU, leave off the <code>--FlashRom</code> flag.</p>
<h3 id="what-did-we-just-build"><a class="header" href="#what-did-we-just-build">What did we just build?</a></h3>
<p>The Patina DXE Core was successfully installed into your QEMU emulator!  But the actual Rust code for that is contained within a prebuilt .efi binary.  Next we will look at the steps you will need to take to update that .efi binary so that <em>your</em> firmware development can be set into place.</p>
<p>Now that the QEMU tooling is ready, let's look at getting a customized Patina core and your own component code onto it with the next steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina-dxe-core-qemu-code"><a class="header" href="#patina-dxe-core-qemu-code">Patina-dxe-core-qemu Code</a></h1>
<p>The <a href="https://github.com/OpenDevicePartnership/patina-dxe-core-qemu">"patina-dxe-core-qemu" repository</a> contains the tooling and build steps needed to combine elements of the patina SDK (maintained in the 'patina' repository) with locally provided component code.</p>
<p>Let's review the component parts of UEFI again at this point:</p>
<p><img src="how/patina/tree/./media/PI_Boot_Phases.jpg" alt="UEFI Diagram" /></p>
<p>All of these sections can be found covered in the Patina implementation.
The DXE Core (colloquially pronounced "Dixie") is the Driver Execution Environment and where most of the key development for components is centered.<br />
There is also of course the Runtime Services (RT) that continue beyond boot of the OS.
And there are all the parts in between, including security management, transient system load (TSL) handling, logging, boot device selection, and so forth.
There are some key differences between a conventional UEFI implmentation and Patina.
One such difference is there is no traditional EFI Dispatcher.  Instead, the DXE Core is built monolithically using dependency injection for the drivers that are bound to a prescribed function.</p>
<p>Read more about the construction and differences of the Patina code base in the <a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Patina Documentation</a></p>
<h2 id="how-does-this-come-together"><a class="header" href="#how-does-this-come-together">How does this come together?</a></h2>
<p>Within the patina-dxe-core-qemu repository there is a primary file at <code>bin\q35_dxe_core.rs</code> that controls the monolithic construction of the core and its various components. Inpecting this file, we see a key function, <code>Core::defualt()</code> that is the launching point for a number of <code>.with_component()</code> and <code>.with_config()</code> calls chained together to construct the complement of our firmware image.</p>
<p>Patina uses a Dependency-Injection scheme to map components and their configurations into the dispatch mechanism, and this is where the registration comes together.</p>
<h2 id="reviewing-and-finalizing-the-setup"><a class="header" href="#reviewing-and-finalizing-the-setup">Reviewing and finalizing the setup</a></h2>
<p>Before we start constructing our own component, let's take a moment to be sure we are set up properly and understand the steps of the process:</p>
<ol>
<li>We will be making our coding additions within our local patina-dxe-core-qemu repository space, and build it there.</li>
<li>When the code is ready, we will switch to our Z:\ location (which is our alias for the patina-qemu repository root) and build and run the stuart_build process that will construct our emulator image and execute it in QEMU.</li>
</ol>
<h3 id="finalizing-setup"><a class="header" href="#finalizing-setup">Finalizing setup</a></h3>
<p>For the binding in step 2 to work, we need to tell the patina-qemu tools where the <code>.efi</code> target file is, so that it can load it into the emulator.  Let's find out where this is.</p>
<p>from your local patina-dxe-core-qemu root, type <code>cargo make q35</code> this should produce a build with no errors.  Now look in the location <code>target\x86_64-unknown-uefi\debug\</code> and you should see a <code>qemu_q35_dxe_core.efi</code> file created there.
Note the full path to this file, i.e. <code>&lt;your-path-to-repository-root&gt;\target\x86_64-unknown-uefi\debug\qemu_q35_dxe_core.efi</code></p>
<p>Go to your patina-qemu local directory and edit the file <code>Platforms\QemuQ35Pkg\QemuQ35Pkg.fdf</code>.  Around about line 644 you will see a section that looks like this:</p>
<pre><code>FILE DXE_CORE = 23C9322F-2AF2-476A-BC4C-26BC88266C71 {
!if $(TARGET) == RELEASE
  SECTION PE32 = $(DXE_CORE_BINARY_PATH)/release/qemu_q35_dxe_core.efi
!else
  SECTION PE32 = $(DXE_CORE_BINARY_PATH)/debug/qemu_q35_dxe_core.efi
!endif
  SECTION UI = "DxeCore"
}
</code></pre>
<p>This implies that the DXE_CORE_BINARY_PATH environment variable can be used to redirect where the <code>.efi</code> file comes from.<br />
As of this writing, however, the repository code does not behave this way.  Instead, we must change this to a literal path that points to our location.</p>
<p>Change this section to look like this:</p>
<pre><code>FILE DXE_CORE = 23C9322F-2AF2-476A-BC4C-26BC88266C71 {
SECTION PE32 = &lt;your-path-to-repository-root&gt;\target\x86_64-unknown-uefi\debug\qemu_q35_dxe_core.efi
SECTION UI = "DxeCore"
}
</code></pre>
<p>So that it will point to the output where your <code>.efi</code> is being constructed.  Note that we are explicitly referring to the debug (default) build here.  Adjust this path as needed for release builds or other targets.</p>
<h3 id="redirecting-log-output"><a class="header" href="#redirecting-log-output">Redirecting log output</a></h3>
<p>You may recall that when we did our first test run using the default <code>.efi</code> location that the runtime debug log output was output to the console and was too lengthy to see the top portion of. We can redirect the output to go to a file instead, which will allow us to see everything as well as keeping it in a place we can review after each run.</p>
<p>Edit the file <code>Platforms\QemuQ35Pkg\Plugins\QemuRunner.py</code> and look for a line that says  <code>args = "-debugcon stdio"</code> (about line 66) and change this to read <code>args = "-debugcon file:debug.log"</code>.  This will redirect log output to a file "debug.log" in your Z:\ location when run.</p>
<p>Now, still at the Z:\ prompt (activated), type</p>
<pre><code>stuart_build -c Platforms\QemuQ35Pkg/PlatformBuild.py --FlashRom
</code></pre>
<p>Again, this will take several minutes and cover a few phases with lots of console output.
Finally, the QEMU window will appear, display it's splash graphic, identifying text, and shell prompt.</p>
<p>You will find your Z:\debug.log file now populated and containing the run output.</p>
<p>Verify this is from your local build by checking this log.
You should see the log line</p>
<pre><code>INFO - DXE Core Platform Binary v0.3.2
</code></pre>
<p>around about line 900 - 910 or so
<em>note version number may be different</em></p>
<p>This log line is emitted from the <code>bin/q35_dxe_core.rs</code> file of the patina-dxe-core-qemu sources, which is the launch point for the components.</p>
<p>We will create and install our own component in the next exercise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-component"><a class="header" href="#creating-a-component">Creating a component</a></h1>
<p>By this point, we have set up our development workspace between the patina-dxe-core-qemu and the patina-qemu repositories and have them wired together so that the image loaded and run in the QEMU emulator is that which was built from the patina-dxe-core-qemu sources.</p>
<p>Now let's create our own component that we can add to this set.</p>
<p>In the <code>src</code> directory we find a <code>component</code> directory and some other small <code>.rs</code> files. The <code>component</code> directory is where we will be adding our new component.</p>
<h3 id="defining-the-component-code"><a class="header" href="#defining-the-component-code">Defining the component code</a></h3>
<p>Inside the <code>component</code> directory, create a new file named <code>test_component.rs</code> that contains this content:</p>
<pre><code>use log::info;
use patina_sdk::{component::params::Config, error::Result};

#[derive(Default, Clone, Copy)]
pub struct Name(pub &amp;'static str);

pub fn run_test_component(name: Config&lt;Name&gt;) -&gt; Result&lt;()&gt; {
    info!("============= Test Component ===============");
    info!("Hello, {}!", name.0);
    info!("=========================================");
    Ok(())
}
</code></pre>
<p>As you can see, this presents a classic 'hello world' style example, which is all we will need to get started.</p>
<p>It starts by importing (the <code>use</code> statements at the top) the logging support we will use for our message, the Config construct from the patina_sdk that we will use for our parameter, and the classic Rust <code>Result</code> construct.</p>
<p>The function signature for this implementation forms the basis for the dependency injection we will register in the next step.</p>
<h3 id="registering-the-component"><a class="header" href="#registering-the-component">Registering the component</a></h3>
<p>The file <code>bin/q35_dxe_core.rs</code> is the main binding and execution point for the manifest of components that will make up the image.</p>
<p>If we look at this file we will see a Core:default() function is called with a number of <code>with_config()</code> and <code>with_component()</code> calls, along with a few others, chained together. This sets up the components that will be included.
The chain concludes with <code>.start().unwrap()</code>.  We can add our component just prior to this, by inserting the lines</p>
<pre><code>.with_component(test_component::run_test_component)
.with_config(test_component::Name("World"))
</code></pre>
<p>just before the <code>.start()</code> call.</p>
<h3 id="importing-the-component"><a class="header" href="#importing-the-component">importing the component</a></h3>
<p>Of course, before this code can register our component, it must know about it.</p>
<p>We name it as one of the exported components by editing <code>src/q35/component.rs</code> and adding the line <code>pub mod test_component;</code> to this file.</p>
<p>We can then add our import to the list of 'use<code>statements near the top of the</code>bin/q35_dxe_core.rs` file with the line</p>
<pre><code>use qemu_resources:q35::component::test_component;
</code></pre>
<h3 id="removing-other-samples"><a class="header" href="#removing-other-samples">removing other samples</a></h3>
<p><em>(optional)</em>
You may have noticed in the debug.log dispatches to other "hello, world" sample components.  These come from the patina_samples section of the 'patina' repository.  Recall, the 'patina' repository is like a library of prebuilt-crates.  This sample code there is one of these crates, but we don't need to use it.  Let's either comment out or remove the <code>use patina_samples as sc</code> line from the list of <code>use</code> statements and these lines from the Core::default() chain:</p>
<pre><code>.with_config(sc::Name("World")) // Config knob for sc::log_hello
</code></pre>
<pre><code>        .with_component(sc::log_hello) // Example of a function component
        .with_component(sc::HelloStruct("World")) // Example of a struct component
        .with_component(sc::GreetingsEnum::Hello("World")) // Example of a struct component (enum)
        .with_component(sc::GreetingsEnum::Goodbye("World")) // Example of a struct component (enum)
</code></pre>
<p>As this will remove some of the clutter from our example build. We will leave the other components there, and verify that we've added our <code>test_component</code> references.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>We can now build with the command <code>cargo make q35</code></p>
<p>.</p>
<p>Once we have built without errors, switch to Z:\ and run
<code>stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --FlashRom</code></p>
<p>and check the debug.log after it runs.</p>
<p>Search for 'test component' and you should find this:</p>
<pre><code>INFO - DISPATCH_ATTEMPT BEGIN: Id = ["qemu_resources::q35::component::test_component::run_test_component"]
INFO - ============= Test Component ===============
INFO - Hello, World!
INFO - =========================================
INFO - DISPATCH_ATTEMPT END: Id = ["qemu_resources::q35::component::test_component::run_test_component"] Status = [Success]
</code></pre>
<p>Congratulations! you have built and run your first Patina Rust component and executed it as emulated firmware!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-patina-fw-patcher"><a class="header" href="#using-the-patina-fw-patcher">Using the Patina FW Patcher</a></h1>
<p>There is no need to rebuild everything with the Stuart build process each time you make a change in Rust.</p>
<p>The Patina-FW-Patcher is maintained in a repository of the same name: <a href="https://github.com/OpenDevicePartnership/patina-fw-patcher">patina-fw-patcher</a>.  The README there has instructions for use.</p>
<p>There are a couple of ways to efficiently update the firmware build, depending upon the circumstances.</p>
<p>(TODO practical examples)</p>
<p><a href="how/patina/tree/../../../library.html">Return to Library</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-1"><a class="header" href="#security-1">Security</a></h1>
<p><em>TODO</em></p>
<p>With overview and links to prior articles.
3rd party support content reposition to here.
Solicit input for this one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dxe"><a class="header" href="#dxe">DXE</a></h1>
<p><em>TODO</em> : Move the existing test_component example here</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booting-into-windows"><a class="header" href="#booting-into-windows">Booting into Windows</a></h1>
<p><em>TODO</em> -- find existing doc on this and reference</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-the-virtual-laptop"><a class="header" href="#integrating-the-virtual-laptop">Integrating the Virtual Laptop</a></h1>
<p><em>TODO</em>
This section will take the components created in the previous exercises and apply them in an integration that
covers</p>
<ul>
<li>
<p>setting up QEMU as a host</p>
</li>
<li>
<p>apply the Patina Firmware we built in exercises and a bootloader</p>
</li>
<li>
<p>communicate with the EC we have constructed in exercises</p>
</li>
<li>
<p>run some tests</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-and-takeaways"><a class="header" href="#summary-and-takeaways">Summary and Takeaways</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odp-specification-documents"><a class="header" href="#odp-specification-documents">ODP Specification documents</a></h1>
<p>Adherence to the specifications defined by the ODP allow for component portability and auditing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller-interface-specification"><a class="header" href="#embedded-controller-interface-specification">Embedded Controller Interface Specification</a></h1>
<p>Embedded Controller(EC) Interface Specification describes base set of requirements to interface to core windows features.
It covers the following areas:</p>
<ul>
<li>Firmware Management</li>
<li>Battery</li>
<li>Time and Alarm</li>
<li>UCSI</li>
<li>Thermal and Power</li>
<li>Input Devices</li>
<li>Customization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-soc-interface"><a class="header" href="#ec-soc-interface">EC SOC Interface</a></h1>
<h2 id="ec-physical-interface"><a class="header" href="#ec-physical-interface">EC Physical Interface</a></h2>
<p>The interface by which the EC is physically wired to the SOC may vary
depending on what interfaces are supported by the Silicon Vendor, EC
manufacturer and OEM. It is recommended that a simple and low latency
protocol is chosen such as eSPI, I3C, UART, memory.</p>
<h2 id="ec-software-interface"><a class="header" href="#ec-software-interface">EC Software Interface</a></h2>
<p>There are several existing OS interfaces that exist today via ACPI and
HID to manage thermal, battery, keyboard, touch etc. These existing
structures need to keep working and any new interface must be created in
such a way that it does not break existing interfaces. This document
covers details on how to implement EC services in secure world and keep
compatibility with non-secure EC OperationRegions. It is important to
work towards a more robust solution that will handle routing, larger
packets and security in a common way across OS’s and across SV
architectures.</p>
<p><img src="specs/ec_interface/media/odp_arch.png" alt="EC connections to apps" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-ec-interface-1"><a class="header" href="#legacy-ec-interface-1">Legacy EC Interface</a></h1>
<p>ACPI specification has a definition for an embedded controller, however
this implementation is tied very closely to the eSPI bus and x86
architecture.</p>
<p>The following is an example of legacy EC interface definition from ACPI</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/11_Thermal_Management/thermal-zone-examples.html">11.7. Thermal Zone Examples — ACPI Specification 6.4
documentation</a></p>
<pre><code>Scope(\\_SB.PCI0.ISA0) {
  Device(EC0) {
    Name(_HID, EISAID("PNP0C09")) // ID for this EC

    // current resource description for this EC
    Name(_CRS, ResourceTemplate() {
      IO(Decode16,0x62,0x62,0,1)
      IO(Decode16,0x66,0x66,0,1)
    })

    Name(_GPE, 0) // GPE index for this EC
    
    // create EC's region and field for thermal support
    OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
    Field(EC0, ByteAcc, Lock, Preserve) {
      MODE, 1, // thermal policy (quiet/perform)
      FAN, 1, // fan power (on/off)
      , 6, // reserved
      TMP, 16, // current temp
      AC0, 16, // active cooling temp (fan high)
      , 16, // reserved
      PSV, 16, // passive cooling temp
      HOT 16, // critical S4 temp
      CRT, 16 // critical temp
    }

    // following is a method that OSPM will schedule after
    // it receives an SCI and queries the EC to receive value 7
    Method(_Q07) {
      Notify (\\_SB.PCI0.ISA0.EC0.TZ0, 0x80)
    } // end of Notify method

    // fan cooling on/off - engaged at AC0 temp
    PowerResource(PFAN, 0, 0) {
      Method(_STA) { Return (\\_SB.PCI0.ISA0.EC0.FAN) } // check power state
      Method(_ON) { Store (One, \\\\_SB.PCI0.ISA0.EC0.FAN) } // turn on fan
      Method(_OFF) { Store ( Zero, \\\\_SB.PCI0.ISA0.EC0.FAN) }// turn off
fan
    }

    // Create FAN device object
    Device (FAN) {
    // Device ID for the FAN
    Name(_HID, EISAID("PNP0C0B"))
    // list power resource for the fan
    Name(_PR0, Package(){PFAN})
    }

    // create a thermal zone
    ThermalZone (TZ0) {
      Method(_TMP) { Return (\\_SB.PCI0.ISA0.EC0.TMP )} // get current temp
      Method(_AC0) { Return (\\_SB.PCI0.ISA0.EC0.AC0) } // fan high temp
      Name(_AL0, Package(){\\_SB.PCI0.ISA0.EC0.FAN}) // fan is act cool dev
      Method(_PSV) { Return (\\_SB.PCI0.ISA0.EC0.PSV) } // passive cooling
temp
      Name(_PSL, Package (){\\_SB.CPU0}) // passive cooling devices
      Method(_HOT) { Return (\\_SB.PCI0.ISA0.EC0.HOT) } // get critical S4
temp
      Method(_CRT) { Return (\\_SB.PCI0.ISA0.EC0.CRT) } // get critical temp
      Method(_SCP, 1) { Store (Arg1, \\\\_SB.PCI0.ISA0.EC0.MODE) } // set
cooling mode

      Name(_TSP, 150) // passive sampling = 15 sec
      Name(_TZP, 0) // polling not required
      Name (_STR, Unicode ("System thermal zone"))
    } // end of TZ0
  } // end of ECO
} // end of \\\\_SB.PCI0.ISA0 scope-
</code></pre>
<p>On platforms that do not support IO port access there is an option to
define MMIO regions to simulate the IO port transactions.</p>
<p>In the above example you can see that the operation region directly maps
to features on the EC and you can change the EC behavior by writing to a
byte in the region or reading the latest data from the EC.</p>
<p>For a system with the EC connected via eSPI and that needs a simple
non-secure interface to the EC the above mapping works very well and
keeps the code simple. The eSPI protocol itself has details on port
accesses and uses the peripheral channel to easily read/write memory
mapped regions.</p>
<p>As the EC features evolve there are several requirements that do no work
well with this interface:</p>
<ul>
<li>
<p>Different buses such as I3C, SPI, UART target a packet
request/response rather than a memory mapped interface</p>
</li>
<li>
<p>Protected or restricted access and validation of request/response</p>
</li>
<li>
<p>Firmware update, large data driven requests that require larger data
response the 256-byte region is limited</p>
</li>
<li>
<p>Discoverability of features available and OEM customizations</p>
</li>
<li>
<p>Out of order completion of requests, concurrency, routing and
priority handling</p>
</li>
</ul>
<p>As we try to address these limitations and move to a more packet based
protocol described in this document. The following section covers
details on how to adopt existing operation region to new ACPI
functionality.</p>
<h2 id="adopting-ec-operation-region-1"><a class="header" href="#adopting-ec-operation-region-1">Adopting EC Operation Region</a></h2>
<p>The new OS frameworks such as MPTF still use ACPI methods as primary
interface. Instead of defining devices such as FAN or ThermalZone in the
EC region you can simply define the EC region itself and then map all
the other ACPI functions to operate on this region. This will allow you
to maintain backwards compatibility with existing EC definitions.</p>
<pre><code>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC
  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    IO(Decode16,0x62,0x62,0,1)
    IO(Decode16,0x66,0x66,0,1)
  })

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
  }
}

Device(SKIN) {
  Name(_HID, "MSFT000A") // New MPTF HID Temperature Device
  Method(_TMP, 0x0, Serialized) {
      Return( \\_SB.PCI0.ISA0.EC0.TMP)
  }
}
</code></pre>
<p>For more complicated functions that take a package some of the data may
be constructed within ACPI and some of the data pulled from the
OperationRegion. For example BIX for battery information may have a
combination of static and dynamic data like this:</p>
<pre><code>Method (_BIX) {
  Name (BAT0, Package (0x12)
  {
    0x01, // Revision
    0x02, // Power Unit
    0x03, // Design Capacity
    \\_SB.PCI0.ISA0.EC0.BFCC, // Last Full Charge Capacity
    0x05, // Battery Technology
    0x06, // Design Voltage
    0x07, // Design capacity of Warning
    0x08, // Design Capacity of Low
    \\_SB.PCI0.ISA0.EC0.BCYL, // Cycle Count
    0x0A, // Measurement Accuracy
    0x0B, // Max Sampling Time
    0x0C, // Min Sampling Time
    0x0D, // Max Averaging Interval
    0x0E, // Min Averaging Interval
    0x0F, // Battery Capacity Granularity 1
    0x10, // Battery Capacity Granularity 2
    "Model123", // Model Number
    "Serial456", // Serial Number
    "Li-Ion", // Battery Type
    "OEMName" // OEM Information
  })
  Return(BAT0)
}
</code></pre>
<h2 id="limitations-for-using-legacy-ec-1"><a class="header" href="#limitations-for-using-legacy-ec-1">Limitations for using Legacy EC</a></h2>
<p>Before using the Legacy EC definition OEM’s should be aware of several
use cases that may limit you ability to use it.</p>
<h3 id="acpi-support-for-espi-master-1"><a class="header" href="#acpi-support-for-espi-master-1">ACPI support for eSPI master</a></h3>
<p>In the case of Legacy EC the communication to the EC is accomplished
directly by the ACPI driver using PORT IO and eSPI Peripheral Bus
commands. On ARM platforms there is no PORT IO and these must be
substituted with MMIO regions. The ACPI driver needs changes to support
MMIO which is being evaluated and support is not yet available. Some
Silicon Vendors also do not implement the full eSPI specification and as
such the ACPI driver cannot handle all the communication needs. On these
platforms using Legacy EC interface is not an option.</p>
<h3 id="security-of-espi-bus-1"><a class="header" href="#security-of-espi-bus-1">Security of eSPI bus</a></h3>
<p>When non-secure world is given access to the eSPI bus it can send
commands to device on that bus. Some HW designs have the TPM or SPINOR
on the same physical bus as the EC. On these designs allowing non-secure
world to directly sends commands to EC can break the security
requirements of other devices on the bus. In these cases the eSPI
communication must be done in the secure world over FF-A as covered in
this document and not use the Legacy EC channel. Since non-secure world
has complete access to the EC operation region there is no chance for
encryption of data. All data in the operation region is considered
non-secure.</p>
<h3 id="functional-limitations-of-legacy-ec-1"><a class="header" href="#functional-limitations-of-legacy-ec-1">Functional limitations of Legacy EC</a></h3>
<p>The peripheral region that is mapped in the Legacy EC in ACPI is limited
to 256 bytes and notification events to the ones that are defined and
handled in ACPI driver. To create custom solutions, send large packets
or support encryption of data the Legacy EC interface has limitations in
this area.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-ec-services-overview-1"><a class="header" href="#secure-ec-services-overview-1">Secure EC Services Overview</a></h1>
<p>In this section we review a system design where the EC communication is
in the secure world running in a dedicated SP. In a system without
secure world or where communication to EC is not desired to be secure
all the ACPI functions can be mapped directly to data from the EC
operation region.</p>
<p>The following github projects provide sample implementations of this interface:</p>
<p><a href="https://github.com/opendevicepartnership/ec-test-app">ACPI EC samples, Kernel mode test driver, User mode test driver</a><br>
<a href="https://github.com/opendevicepartnership/haf-ec-service">Sample Secure Partition Service for EC services in RUST</a><br>
<a href="https://github.com/opendevicepartnership/ffa">RUST crate for FFA implementation in secure partition</a><br></p>
<p>The following GUID’s have been designed to represent each service
operating in the secure partition for EC.</p>
<table>
<thead>
<tr class="header">
<th>EC Service Name</th>
<th>Service GUID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<td>EC_SVC_MANAGEMENT</td>
<td>330c1273-fde5-4757-9819-5b6539037502</td>
<td>Used to query EC functionality, Board info, version, security state, FW update</td>
</tr>
<td>EC_SVC_POWER</td>
<td>7157addf-2fbe-4c63-ae95-efac16e3b01c</td>
<td>Handles general power related requests and OS Sx state transition state notification</td>
</tr>
<td>EC_SVC_BATTERY</td>
<td>25cb5207-ac36-427d-aaef-3aa78877d27e</td>
<td>Handles battery info, status, charging</td>
</tr>
<td>EC_SVC_THERMAL</td>
<td>31f56da7-593c-4d72-a4b3-8fc7171ac073</td>
<td>Handles thermal requests for skin and other thermal events</td>
</tr>
<td>EC_SVC_UCSI</td>
<td>65467f50-827f-4e4f-8770-dbf4c3f77f45</td>
<td>Handles PD notifications and calls to UCSI interface</td>
</tr>
<td>EC_SVC_INPUT</td>
<td>e3168a99-4a57-4a2b-8c5e-11bcfec73406</td>
<td>Handles wake events, power key, lid, input devices (HID separate instance)</td>
</tr>
<td>EC_SVC_TIME_ALARM</td>
<td>23ea63ed-b593-46ea-b027-8924df88e92f</td>
<td>Handles RTC and wake timers.</td>
</tr>
<td>EC_SVC_DEBUG</td>
<td>0bd66c7c-a288-48a6-afc8-e2200c03eb62</td>
<td>Used for telemetry, debug control, recovery modes, logs, etc</td>
</tr>
<td>EC_SVC_TEST</td>
<td>6c44c879-d0bc-41d3-bef6-60432182dfe6</td>
<td>Used to send commands for manufacturing/factory test</td>
</tr>
<td>EC_SVC_OEM1</td>
<td>9a8a1e88-a880-447c-830d-6d764e9172bb</td>
<td>Sample OEM custom service and example piping of events</td>
</tr>
</tbody>
</table>
<h2 id="ffa-overview-1"><a class="header" href="#ffa-overview-1">FFA Overview</a></h2>
<p>This section covers the components involved in sending a command to EC
through the FFA flow in windows. This path is specific to ARM devices
and a common solution with x64 is still being worked out. Those will
continue through the non-secure OperationRegion in the near term.</p>
<p><img src="specs/ec_interface/media/image1.png" alt="A diagram of a computer security system Description automatically generated" /></p>
<p>ARM has a standard for calling into the secure world through SMC’s and
targeting a particular service running in secure world via a UUID. The
full specification and details can be found here: <a href="https://developer.arm.com/Architectures/Firmware%20Framework%20for%20A-Profile">Firmware Framework
for A-Profile</a></p>
<p>The windows kernel provides native ability for ACPI to directly send and
receive FFA commands. It also provides a driver ffadrv.sys to expose a
DDI that allows other drivers to directly send/receive FFA commands
without needing to go through ACPI.</p>
<p>Hyper-V forwards the SMC’s through to EL3 to Hafnium which then uses the
UUID to route the request to the correct SP and service. From the
corresponding EC service it then calls into the eSPI or underlying
transport layer to send and receive the request to the physical EC.</p>
<h3 id="ffa-device-definition-2"><a class="header" href="#ffa-device-definition-2">FFA Device Definition</a></h3>
<p>The FFA device is loaded from ACPI during boot and as such requires a
Device entry in ACPI</p>
<pre><code>  Name(_HID, "MSFT000C")

  OperationRegion(AFFH, FFixedHw, 4, 144) 
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }     
    

  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              2, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
              Package () {
                     ToUUID("b510b3a3-59f6-4054-ba7a-ff2eb1eac765"), // Service2 UUID
                     Package () {
                          0x01,     //Cookie1
                          0x03,     //Cookie2
                      }
             }
         }
      }
    }
  }) // _DSD()

  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }

  Method(AVAL,0x0, Serialized)
  {
    Return(One)
  }
}
</code></pre>
<h4 id="hid-definition-1"><a class="header" href="#hid-definition-1">HID definition</a></h4>
<p>The _HID “MSFT000C” is reserved for FFA devices. Defining this HID for
your device will cause the FFA interface for the OS to be loaded on this
device.</p>
<h4 id="operation-region-definition-1"><a class="header" href="#operation-region-definition-1">Operation Region Definition</a></h4>
<p>The operation region is marked as FFixedHw type 4 which lets the ACPI
interpreter know that any read/write to this region requires special
handling. The length is 144 bytes because this region operates on
registers X0-X17 each of which are 8 bytes 18*8 = 144 bytes. This is
mapped to FFAC is 1152 bits (144*8) and this field is where we act
upon.</p>
<pre><code>OperationRegion(AFFH, FFixedHw, 4, 144)
Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1),FFAC, 1152 }
</code></pre>
<p>When reading and writing from this operation region the FFA driver does
some underlying mapping for X0-X3</p>
<pre><code>X0 = 0xc400008d // FFA_DIRECT_REQ2
X1 = (Receiver Endpoint ID) | (Sender Endpoint ID \&lt;\&lt; 16)
X2/X3 = UUID
</code></pre>
<p>The following is the format of the request and response packets that are
sent via ACPI</p>
<pre><code>FFA_REQ_PACKET
{
  uint8 status; // Not used just populated so commands are symmetric
  uint8 length; // Number of bytes in rawdata
  uint128 UUID;
  uint8 reqdata[];
}

FFA_RSP_PACKET
{
  uint8 status; // Status from ACPI if FFA command was sent successfully
  uint8 length;
  uint128 UUID;
  uint64 ffa_status; // Status returned from the service of the FFA command
  uint8 rspdata[];
}

CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // In/Out - UUID of service
CreateDwordField(BUFF,18,FFST)// Out - FFA command status
</code></pre>
<h4 id="register-notification-1"><a class="header" href="#register-notification-1">Register Notification</a></h4>
<p>During FFA driver initialization it calls into secure world to get a
list of all available services for each secure partition. After this we
send a NOTIFICATION_REGISTRATION request to each SP that has a service
which registers for notification events</p>
<pre><code>  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              1, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
         }
      }
    }
  }) // _DSD()
</code></pre>
<p><img src="specs/ec_interface/media/image2.png" alt="A diagram of a application Description automatically generated" /></p>
<p>In the above example we indicate that the OS will handle 2 different
notification events for UUID 330c1273-fde5-4757-9819-5b6539037502 which
is our EC management UUID. FFA knows which secure partition this maps to
based on the list of services for each SP it has retrieved. Rather than
having to keep track of all the physical bits in the bitmask that are
used the FFA driver keeps track of this and allows each service to
create a list of virtual ID’s they need to handle. The FFA driver then
maps this to one of the available bits in the hardware bitmask and
passes this mapping down to the notification service running in a given
SP.</p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<table>
<thead>
<tr class="header">
<th><strong>Parameter </strong></th>
<th><strong>Register </strong></th>
<th><strong>Value </strong></th>
</tr>
</thead>
<tbody>
<td>Function<strong> </strong></td>
<td>X4 </td>
<td>0x1 </td>
</tr>
<td>UUID Lo<strong> </strong></td>
<td>X5 </td>
<td>Bytes [0..7] for the service UUID. </td>
</tr>
<td>UUID Hi<strong> </strong></td>
<td>X6 </td>
<td>Bytes [8..16] for the service UUID. </td>
</tr>
<td>Mappings Count<strong> </strong></td>
<td>X7 </td>
<td>The number of notification mappings </td>
</tr>
<td>Notification Mapping1<strong> </strong></td>
<td>X8 </td>
<td><p>Bits [0..16] – Notification ID. --&gt; 0,1,2,3,... </p>
<p> </p>
<p>Bits [16..32] – Notification Bitmap bit number (0-383).  </p></td>
</tr>
<td>Notification Mapping2<strong> </strong></td>
<td>X9 </td>
<td><p>Bits [0..16] – Notification ID. --&gt; 0,1,2,3,... </p>
<p> </p>
<p>Bits [16..32] – Notification Bitmap bit number (0-383). </p>
<p> </p></td>
</tr>
<td>...<strong> </strong></td>
<td>... </td>
<td>... </td>
</tr>
</tbody>
</table>
<p> </p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter </th><th>Register </th><th>Value </th></tr></thead><tbody>
<tr><td>Result</td><td>X4</td><td>0 on success. Otherwise, Failure</td></tr>
</tbody></table>
</div>
<p> </p>
<p>Note this NOTIFICATION_REGISTER request is sent to the
Notification Service UUID in the SP. The UUID of the service that the
notifications are for are stored in X5/X6 registers shown above.</p>
<p>The UUID for notification service is
{B510B3A3-59F6-4054-BA7A-FF2EB1EAC765} which is stored in X2/X3.</p>
<h4 id="notification-events-1"><a class="header" href="#notification-events-1">Notification Events</a></h4>
<p>All notification events sent from all secure partitions are passed back
through the FFA driver. The notification calls the _DSM method. Function 0
is always a bitmap of all the other functions supported. We must support at
least a minium of the Query and Notify.
The UUID is stored in Arg0 and the notification cookie is stored in Arg3 when Arg2 is 11.</p>
<pre><code>  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }
</code></pre>
<p>The following is the call flow showing a secure interrupt arriving to
the EC service which results in a notification back to ACPI. The
notification payload can optionally be written to a shared buffer or
ACPI can make another call back into EC service to retrieve the
notification details.</p>
<p>The _NFY only contains the ID of the notification and no other payload,
so both ACPI and the EC service must be designed either with shared
memory buffer or a further notify data packet.</p>
<p><img src="specs/ec_interface/media/image3.png" alt="A diagram of a service Description automatically generated" /></p>
<h2 id="runtime-requests-1"><a class="header" href="#runtime-requests-1">Runtime Requests</a></h2>
<p>During runtime the non-secure side uses FFA_MSG_SEND_DIRECT_REQ2
requests to send requests to a given service within an SP. Any request
that is expected to take longer than 500 uSec should yield control back
to the OS by calling FFA_YIELD within the service. When FFA_YIELD is
called it will return control back to the OS to continue executing but
the corresponding ACPI thread will be blocked until the original FFA
request completes with DIRECT_RSP2. Note this creates a polling type
interface where the OS will resume the SP thread after the timeout
specified. The following is sample call sequence.</p>
<p><img src="specs/ec_interface/media/image4.png" alt="A diagram of a company&#39;s process Description automatically generated" /></p>
<h3 id="ffa-example-data-flow-1"><a class="header" href="#ffa-example-data-flow-1">FFA Example Data Flow</a></h3>
<p>For an example let’s take the battery status request _BST and follow
data through.</p>
<p><img src="specs/ec_interface/media/image5.png" alt="A screenshot of a computer Description automatically generated" /></p>
<pre><code>FFA_REQ_PACKET req = {
  0x0, // Initialize to no error
  0x1, // Only 1 byte of data is sent after the header
  {0x25,0xcb,0x52,0x07,0xac,0x36,0x42,0x7d,0xaa,0xef,0x3a,0xa7,0x88,0x77,0xd2,0x7e},
  0x2 // EC_BAT_GET_BST
}
</code></pre>
<p>The equivalent to write this data into a BUFF in ACPI is as follows</p>
<pre><code>Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // UUID of service
CreateByteField(BUFF,18, CMDD) // In – First byte of command
CreateField(BUFF,144,128,BSTD) // Out – Raw data response 4 DWords
Store(20,LENG)
Store(0x2, CMDD)
Store(ToUUID ("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID)
Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)
</code></pre>
<p>The ACPI interpreter when walking through this code creates a buffer and
populates the data into buffer. The last line indicates to send this
buffer over FFA interface.</p>
<p>ACPI calls into the FFA interface to send the data over to the secure
world EC Service</p>
<pre><code>typedef struct _FFA_INTERFACE {
    ULONG Version;
    PFFA_MSG_SEND_DIRECT_REQ2 SendDirectReq2;
} FFA_INTERFACE, \*PFFA_INTERFACE;
</code></pre>
<h3 id="ffa-parsing-1"><a class="header" href="#ffa-parsing-1">FFA Parsing</a></h3>
<p>FFA is in charge of sending the SMC over to the secure world and routing
to the correct service based on UUID.</p>
<p><img src="specs/ec_interface/media/image6.png" alt="A diagram of a computer Description automatically generated" /></p>
<pre><code>X0 = SEND_DIRECT_REQ2 SMC command ID
X1 = Source ID and Destination ID
X2 = UUID Low
X3 = UUID High
X4-X17 = rawdata
</code></pre>
<p><strong>Note:</strong> The status and length are not passed through to the secure
world they are consumed only be ACPI.</p>
<p>HyperV and Monitor have a chance to filter or deny the request, but in
general just pass the SMC request through to Hafnium</p>
<p>Hafnium extracts the data from the registers into an sp_msg structure
which is directly mapping contents from x0-x17 into these fields.</p>
<pre><code>pub struct FfaParams {
    pub x0: u64,
    pub x1: u64,
    pub x2: u64,
    pub x3: u64,
    pub x4: u64,
    pub x5: u64,
    pub x6: u64,
    pub x7: u64,
    pub x8: u64,
    pub x9: u64,
    pub x10: u64,
    pub x11: u64,
    pub x12: u64,
    pub x13: u64,
    pub x14: u64,
    pub x15: u64,
    pub x16: u64,
    pub x17: u64,
}
</code></pre>
<p>In our SP we receive the raw FfaParams structure and we convert this to
an FfaMsg using our translator. This pulls out the function_id,
source_id, destination_id and uuid.</p>
<pre><code>fn from(params: FfaParams) -&gt; FfaMsg {
  FfaMsg {
    function_id: params.x0,              // Function id is in lower 32 bits of x0
    source_id: (params.x1 &gt;&gt; 16) as u16, // Source in upper 16 bits
    destination_id: params.x1 as u16,    // Destination in lower 16 bits
    uuid: u64_to_uuid(params.x2, params.x3),
    args64: [
      params.x4, params.x5, params.x6, params.x7, params.x8, params.x9, params.x10,
      params.x11, params.x12, params.x13, params.x14, params.x15, params.x16, params.x17,
            ],
  }
}
</code></pre>
<p>The destination_id is used to route the message to the correct SP, this
is based on the ID field in the DTS description file. Eg: id =
&lt;0x8001&gt;;</p>
<h3 id="ec-service-parsing-1"><a class="header" href="#ec-service-parsing-1">EC Service Parsing</a></h3>
<p>Within the EC partition there are several services that run, the routing
of the FF-A request to the correct services is done by the main message
handling loop for the secure partition. After receiving a message we
call into ffa_msg_handler and based on the UUID send it to the
corresponding service to handle the message.</p>
<pre><code>let mut next_msg = ffa.msg_wait();
loop {
  match next_msg {
    Ok(ffamsg) =&gt; match ffa_msg_handler(&amp;ffamsg) {
      Ok(msg) =&gt; next_msg = ffa.msg_resp(\&amp;msg),
      Err(_e) =&gt; panic!("Failed to handle FFA msg"),
    },
    Err(_e) =&gt; {
      panic!("Error executing msg_wait");
    }
   }
}
</code></pre>
<p>The main message loop gets the response back from ffa_msg_handler and
returns to non-secure world so the next incoming message after the
response is a new message to handle.</p>
<pre><code>fn ffa_msg_handler(msg: &amp;FfaMsg) -&gt; Result&lt;FfaMsg&gt; {
    println!(
        "Successfully received ffa msg:
        function_id = {:08x}
               uuid = {}",
        msg.function_id, msg.uuid
    );

    match msg.uuid {
        UUID_EC_SVC_MANAGEMENT =&gt; {
            let fwmgmt = fw_mgmt::FwMgmt::new();
            fwmgmt.exec(msg)
        }

        UUID_EC_SVC_NOTIFY =&gt; {
            let ntfy = notify::Notify::new();
            ntfy.exec(msg)
        }

        UUID_EC_SVC_POWER =&gt; {
            let pwr = power::Power::new();
            pwr.exec(msg)
        }

        UUID_EC_SVC_BATTERY =&gt; {
            let batt = battery::Battery::new();
            batt.exec(msg)
        }

        UUID_EC_SVC_THERMAL =&gt; {
            let thm = thermal::ThmMgmt::new();
            thm.exec(msg)
        }

        UUID_EC_SVC_UCSI =&gt; {
            let ucsi = ucsi::UCSI::new();
            ucsi.exec(msg)
        }

        UUID_EC_SVC_TIME_ALARM =&gt; {
            let alrm = alarm::Alarm::new();
            alrm.exec(msg)
        }

        UUID_EC_SVC_DEBUG =&gt; {
            let dbg = debug::Debug::new();
            dbg.exec(msg)
        }

        UUID_EC_SVC_OEM =&gt; {
            let oem = oem::OEM::new();
            oem.exec(msg)
        }

        _ =&gt; panic!("Unknown UUID"),
    }
}
</code></pre>
<h3 id="large-data-transfers-1"><a class="header" href="#large-data-transfers-1">Large Data Transfers</a></h3>
<p>When making an FFA_MSG_SEND_DIRECT_REQ2 call the data is stored in
registers X0-X17. X0-X3 are reserved to store the Function Id, Source
Id, Destination Id and UUID. This leaves X4-X17 or 112 bytes. For larger
messages they either need to be broken into multiple pieces or make use
of a shared buffer between the OS and Secure Partition.</p>
<h4 id="shared-buffer-definitions-1"><a class="header" href="#shared-buffer-definitions-1">Shared Buffer Definitions</a></h4>
<p>To create a shared buffer you need to modify the dts file for the secure
partition to include mapping to your buffer.</p>
<pre><code>ns_comm_buffer {
  description = "ns-comm";
  base-address = &lt;0x00000100 0x60000000&gt;;
  pages-count = &lt;0x8&gt;;
  attributes = &lt;NON_SECURE_RW&gt;;
};
</code></pre>
<p>During UEFI Platform initialization you will need to do the following
steps, see the FFA specification for more details on these commands</p>
<ul>
<li>FFA_MAP_RXTX_BUFFER</li>
<li>FFA_MEM_SHARE</li>
<li>FFA_MSG_SEND_DIRECT_REQ2 (EC_CAP_MEM_SHARE)</li>
<li>FFA_UNMAP_RXTX_BUFFER</li>
</ul>
<p>The RXTX buffer is used during larger packet transfers but can be
overridden and updated by the framework. The MEM_SHARE command uses the
RXTX buffer so we first map that buffer then populate our memory
descriptor requests to the TX_BUFFER and send to Hafnium. After sending
the MEM_SHARE request we need to instruct our SP to retrieve this
memory mapping request. This is done through our customer
EC_CAP_MEM_SHARE request where we describe the shared memory region
that UEFI has donated. From there we call FFA_MEM_RETRIEVE_REQ to map
the shared memory that was described to Hafnium. After we are done with
the RXTX buffers we must unmap them as the OS will re-map new RXTX
buffers. From this point on both Non-secure and Secure side will have
access to this shared memory buffer that was allocated.</p>
<h3 id="async-transfers-1"><a class="header" href="#async-transfers-1">Async Transfers</a></h3>
<p>All services are single threaded by default. Even when doing FFA_YIELD
it does not allow any new content to be executed within the service. If
you need your service to be truly asynchronous you must have commands
with delayed responses.</p>
<p>There is no packet identifier by default and tracking of requests and
completion by FFA, so the sample solution given here is based on shared
buffers defined in previous section and existing ACPI and FFA
functionality.</p>
<p><img src="specs/ec_interface/media/image7.png" alt="A diagram of a service Description automatically generated" /></p>
<p>Inside of our FFA functions rather than copying our data payload into
the direct registers we define a queue in shared memory and populate the
actual data into this queue entry. In the FFA_MSG_SEND_DIRECT_REQ2
we populate an ASYNC command ID (0x0) along with the seq #. The seq #
is then used by the service to locate the request in the TX queue. We
define a separate queue for RX and TX so we don’t need to synchronize
between OS and secure partition.</p>
<p><img src="specs/ec_interface/media/image8.png" alt="" /></p>
<h3 id="acpi-structures-and-methods-for-asynchronous-1"><a class="header" href="#acpi-structures-and-methods-for-asynchronous-1">ACPI Structures and Methods for Asynchronous</a></h3>
<p>The SMTX is shared memory TX region definition</p>
<pre><code>// Shared memory regions and ASYNC implementation
OperationRegion (SMTX, SystemMemory, 0x10060000000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMTX, AnyAcc, NoLock, Preserve)
{
  TVER, 16,
  TCNT, 16,
  TRS0, 32,
  TB0, 64,
  TB1, 64,
  TB2, 64,
  TB3, 64,
  TB4, 64,
  TB5, 64,
  TB6, 64,
  TB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  TE0, 2048,
  TE1, 2048,
  TE2, 2048,
  TE3, 2048,
  TE4, 2048,
  TE5, 2048,
  TE6, 2048,
  TE7, 2048,
}
</code></pre>
<p>The QTXB method copies data into first available entry in the TX queue
and returns sequence number used.</p>
<pre><code>// Arg0 is buffer pointer
// Arg1 is length of Data
// Return Seq \#
Method(QTXB, 0x2, Serialized) {
  Name(TBX, 0x0)
  Store(Add(ShiftLeft(1,32),Add(ShiftLeft(Arg1,16),SEQN)),TBX)
  Increment(SEQN)
  // Loop until we find a free entry to populate
  While(One) {
    If(LEqual(And(TB0,0xFFFF),0x0)) {
      Store(TBX,TB0); Store(Arg0,TE0); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB1,0xFFFF),0x0)) {
      Store(TBX,TB1); Store(Arg0,TE1); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB2,0xFFFF),0x0)) {
      Store(TBX,TB2); Store(Arg0,TE2); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB3,0xFFFF),0x0)) {
      Store(TBX,TB3); Store(Arg0,TE3); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB4,0xFFFF),0x0)) {
      Store(TBX,TB4); Store(Arg0,TE4); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB5,0xFFFF),0x0)) {
      Store(TBX,TB5); Store(Arg0,TE5); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB6,0xFFFF),0x0)) {
      Store(TBX,TB6); Store(Arg0,TE6); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB7,0xFFFF),0x0)) {
      Store(TBX,TB7); Store(Arg0,TE7); Return( And(TBX,0xFFFF) )
    }

    Sleep(5)
  }
}
</code></pre>
<p>The SMRX is shared memory region for RX queues</p>
<pre><code>// Shared memory region
OperationRegion (SMRX, SystemMemory, 0x10060001000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMRX, AnyAcc, NoLock, Preserve)
{
  RVER, 16,
  RCNT, 16,
  RRS0, 32,
  RB0, 64,
  RB1, 64,
  RB2, 64,
  RB3, 64,
  RB4, 64,
  RB5, 64,
  RB6, 64,
  RB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  RE0, 2048,
  RE1, 2048,
  RE2, 2048,
  RE3, 2048,
  RE4, 2048,
  RE5, 2048,
  RE6, 2048,
  RE7, 2048,
}
</code></pre>
<p>The RXDB function takes sequence number as input and will keep looping
through all the entries until we see packet has completed. Sleeps for
5ms between each iteration to allow the OS to do other things and other
ACPI threads can run.</p>
<pre><code>// Allow multiple threads to wait for their SEQ packet at once
// If supporting packet \&gt; 256 bytes need to modify to stitch together packet
Method(RXDB, 0x1, Serialized) {
  Name(BUFF, Buffer(256){})
  // Loop forever until we find our seq
  While (One) {
    If(LEqual(And(RB0,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB0,16),0xFFFF),8), XB0)
      Store(RE0,BUFF); Store(0,RB0); Return( XB0 )
    }

    If(LEqual(And(RB1,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB1,16),0xFFFF),8), XB1)
      Store(RE1,BUFF); Store(0,RB1); Return( XB1 )
    }

    If(LEqual(And(RB2,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB2,16),0xFFFF),8), XB2)
      Store(RE2,BUFF); Store(0,RB2); Return( XB2 )
    }

    If(LEqual(And(RB3,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB3,16),0xFFFF),8), XB3)
      Store(RE3,BUFF); Store(0,RB3); Return( XB3 )
    }

    If(LEqual(And(RB4,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB4,16),0xFFFF),8), XB4)
      Store(RE4,BUFF); Store(0,RB4); Return( XB4 )
    }

    If(LEqual(And(RB5,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB5,16),0xFFFF),8), XB5)
      Store(RE5,BUFF); Store(0,RB5); Return( XB5 )
    }

    If(LEqual(And(RB6,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB6,16),0xFFFF),8), XB6)
      Store(RE6,BUFF); Store(0,RB6); Return( XB6 )
    }

    If(LEqual(And(RB7,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB7,16),0xFFFF),8), XB7)
      Store(RE7,BUFF); Store(0,RB7); Return( XB7 )
    }

    Sleep(5)
  }

  // If we get here didn't find a matching sequence number
  Return (Ones)
}
</code></pre>
<p>The following is sample code to transmit a ASYNC request and wait for
the data in the RX buffer.</p>
<pre><code>Method(ASYC, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
  Name(BUFF, Buffer(30){})
  CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
  CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
  CreateField(BUFF,16,128,UUID) // UUID of service
  CreateByteField(BUFF,18,CMDD) // Command register
  CreateWordField(BUFF,19,BSQN) // Sequence Number

  // x0 -\&gt; STAT
  Store(20, LENG)
  Store(0x0, CMDD) // EC_ASYNC command
  Local0 = QTXB(BUFF,20) // Copy data to our queue entry and get back SEQN
  Store(Local0,BSQN) // Sequence packet to read from shared memory
  Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
  Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

  If(LEqual(STAT,0x0) ) // Check FF-A successful?
  {
    Return (RXDB(Local0)) // Loop through our RX queue till packet completes
  }
}
</code></pre>
<h2 id="recovery-and-errors-1"><a class="header" href="#recovery-and-errors-1">Recovery and Errors</a></h2>
<p>The eSPI or bus driver is expected to detect if the EC is not responding
and retry. The FFA driver will report back in the status byte if it
cannot successfully talk to the secure world. If there are other
failures generally they should be returned back up through ACPI with a
value of (Ones) to indicate failure condition. This may cause some
features to work incorrectly.</p>
<p>It is also expected that the EC has a watchdog if something on the EC is
hung it should reset and reload on its own. The EC is also responsible
for monitoring that the system is running within safe parameters. The
thermal requests and queries are meant to be advisory in nature and EC
should be able to run independently and safely without any intervention
from the OS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-firmware-management"><a class="header" href="#ec-firmware-management">EC Firmware Management</a></h1>
<p>This service is to provide details about the security state, supported
features, debug, firmware version and firmware update functionality.</p>
<p>NIST SP 800-193 compliance requires failsafe update of primary and
backup EC FW images. EC should run from primary partition while writing
backup partitions and then change flag to indicate backup becomes
primary and primary becomes backup.</p>
<div class="table-wrapper"><table><thead><tr><th>Capability Command</th><th>Description</th></tr></thead><tbody>
<tr><td>EC_CAP_GET_FW_STATE = 0x1</td><td>Return details of FW in EC, DICE, Secure Boot, Version, etc</td></tr>
<tr><td>EC_CAP_GET_SVC_LIST = 0x2</td><td>Get list of services/features that this EC supports</td></tr>
<tr><td>EC_CAP_GET_BID = 0x3</td><td>Read Board ID that is used customized behavior</td></tr>
<tr><td>EC_CAP_TEST_NFY = 0x4</td><td>Create test notification event</td></tr>
</tbody></table>
</div>
<h2 id="get-firmware-state"><a class="header" href="#get-firmware-state">Get Firmware State</a></h2>
<p>Returns start of the overall EC if DICE and secure boot was enabled,
currently running firmware version, EC status like boot failures.</p>
<h3 id="secure-boot-and-dice"><a class="header" href="#secure-boot-and-dice">Secure Boot and DICE</a></h3>
<p>DICE is a specification from the Trusted Computing Group that allows the
MCU to verify the signature of the code that it is executing, thereby
establishing trust in the code. To do this, it has a primary bootloader
program that reads the firmware on flash and using a key that is only
accessible by the ROM bootloader, can verify the authenticity of the
firmware. </p>
<p><a href="https://trustedcomputinggroup.org/wp-content/uploads/Hardware-Requirements-for-Device-Identifier-Composition-Engine-r78_For-Publication.pdf"><span class="underline">Trusted Platform Architecture - Device Identity
Composition Engine
(trustedcomputinggroup.org)</span></a> </p>
<h3 id="input-parameters"><a class="header" href="#input-parameters">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters"><a class="header" href="#output-parameters">Output Parameters</a></h3>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Bits</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FWVersion</td>
<td>16</td>
<td>Version of FW running on EC</td>
</tr>
<tr class="even">
<td>SecureState</td>
<td>8</td>
<td><p>Bit mask representing the secure state of the device</p>
<p>0 – DICE is enabled</p>
<p>1 – Firmware is signed</p></td>
</tr>
<tr class="odd">
<td>BootStatus</td>
<td>8</td>
<td><p>Boot status and error codes</p>
<p>0 = SUCCESS</p></td>
</tr>
</tbody>
</table>
<h3 id="ffa-acpi-example"><a class="header" href="#ffa-acpi-example">FFA ACPI Example</a></h3>
<pre><code>Method (TFWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,32,FWSD) // Out – Raw data response (overlaps with CMDD)

    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID) // Management
    Store(20, LENG)
    Store(0x1, CMDD) // EC_CAP_GET_FW_STATE
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (FWSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="get-features-supported"><a class="header" href="#get-features-supported">Get Features Supported</a></h2>
<p>Get a list of services/features supported by this EC. Several features
like HID devices are optional and may not be present. OEM services may
also be added to this list as additional features supported.</p>
<h3 id="input-parameters-1"><a class="header" href="#input-parameters-1">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-1"><a class="header" href="#output-parameters-1">Output Parameters</a></h3>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Bits</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DebugMask</td>
<td>16</td>
<td><p>0 – Supports reset reason</p>
<p>1 – Supports debug tracing</p></td>
</tr>
<tr class="even">
<td>BatteryMask</td>
<td>8</td>
<td><p>0 – Battery 0 present</p>
<p>1 – Battery 1 present</p>
<p>…</p></td>
</tr>
<tr class="odd">
<td>FanMask</td>
<td>8</td>
<td><p>0 – FAN 0 present</p>
<p>1 – FAN 1 present</p>
<p>…</p></td>
</tr>
<tr class="even">
<td>ThermalMask</td>
<td>8</td>
<td>0 – Skin TZ present</td>
</tr>
<tr class="odd">
<td>HIDMask</td>
<td>8</td>
<td><p>0 – HID0 present</p>
<p>1 – HID1 present</p>
<p>…</p></td>
</tr>
<tr class="even">
<td>KeyMask</td>
<td>16</td>
<td><p>0 – Power key present</p>
<p>1 – LID switch present</p>
<p>2 – VolUp Key Present</p>
<p>3 – VolDown Key Present</p>
<p>4 – Camera Key Present</p></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ffa-acpi-example-1"><a class="header" href="#ffa-acpi-example-1">FFA ACPI Example</a></h3>
<pre><code>Method(TFET, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){})
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateField(BUFF,144,48,FETD) // Output Data

    Store(20, LENG)
    Store(0x2, CMDD) // EC_CAP_GET_SVC_LIST
    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) {
      Return (FETD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="get-board-id"><a class="header" href="#get-board-id">Get Board ID</a></h2>
<p>EC is often used to read pins or details to determine the HW
configuration based on GPIO’s or ADC values. This ID allows SW to change
behavior depending on this HW version information.</p>
<h3 id="input-parameters-2"><a class="header" href="#input-parameters-2">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-2"><a class="header" href="#output-parameters-2">Output Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Bits</th><th>Description</th></tr></thead><tbody>
<tr><td>BoardID</td><td>64</td><td>Vendor defined</td></tr>
</tbody></table>
</div>
<h3 id="ffa-acpi-example-2"><a class="header" href="#ffa-acpi-example-2">FFA ACPI Example</a></h3>
<pre><code>Method(TBID, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){})
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateDwordField(BUFF,18,BIDD) // Output Data
    Store(20, LENG)
    Store(0x3, CMDD) // EC_CAP_GET_BID
    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) {
      Return (BIDD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="firmware-update"><a class="header" href="#firmware-update">Firmware Update</a></h2>
<p>This should initiate update of a particular firmware in the backup
partition to provide NIST SP 800-193 failsafe compliance. EC firmware
update is planned to be handled through CFU. Further details are
available in CFU specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-power-service"><a class="header" href="#ec-power-service">EC Power Service</a></h1>
<h2 id="system-power-state"><a class="header" href="#system-power-state">System Power State</a></h2>
<p>OS calls in to notify EC or a change in system power state.</p>
<p>Perform appropriate power sequencing for the SoC from low power states
(S3, S4, S5) to S0, and from S0 to low power states</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-1"><a class="header" href="#battery-service-1">Battery Service</a></h1>
<p>Battery control is monitored through the Modern Power Thermal Framework
(MPTF). See this specification for further details on implementing
firmware for these features. This section outlines the interface
required in ACPI for this framework to function.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>EC_BAT_GET_BIX = 0x1</td><td>Returns information about battery, model, serial number voltage. Note this is a superset of BIF. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BST = 0x2</td><td>Get Battery Status, must also have notify event on state change. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_PSR = 0x3</td><td>Returns whether this power source device is currently online. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_PIF = 0x4</td><td>Returns static information about a power source. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BPS = 0x5</td><td>Power delivery capabilities of battery at present time. (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BTP = 0x6</td><td>Set battery trip point to generate SCI event (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BPT = 0x7</td><td>Set Battery Power Threshold (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BPC = 0x8</td><td>Returns static variables that are associated with system power characteristics on the battery path and power threshold support settings. (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BMC= 0x9</td><td>Battery Maintenance Control</td></tr>
<tr><td>EC_BAT_GET_BMD = 0xA</td><td>Returns battery information regarding charging and calibration</td></tr>
<tr><td>EC_BAT_GET_BCT = 0xB</td><td>Returns battery charge time.</td></tr>
<tr><td>EC_BAT_GET_BTM = 0xC</td><td>Get estimated runtime of battery while discharging</td></tr>
<tr><td>EC_BAT_SET_BMS = 0xD</td><td>Sets battery capacity sampling time in ms</td></tr>
<tr><td>EC_BAT_SET_BMA = 0xE</td><td>Battery Measurement Average Interval</td></tr>
<tr><td>EC_BAT_GET_STA = 0xF</td><td>Get battery availability</td></tr>
</tbody></table>
</div>
<h2 id="ec_bat_get_bix"><a class="header" href="#ec_bat_get_bix">EC_BAT_GET_BIX</a></h2>
<p>Returns information about battery, model, serial number voltage etc</p>
<h3 id="input-parameters-3"><a class="header" href="#input-parameters-3">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-3"><a class="header" href="#output-parameters-3">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bix-battery-information-extended">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-3"><a class="header" href="#ffa-acpi-example-3">FFA ACPI Example</a></h3>
<pre><code>Method (_BIX) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,1088,BIXD) // Out – Raw data response max length

    Store(20, LENG)
    Store(0x1, CMDD) // EC_BAT_GET_BIX
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)


    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BIXD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bst"><a class="header" href="#ec_bat_get_bst">EC_BAT_GET_BST</a></h2>
<p>This object returns the present battery status. Whenever the Battery
State value changes, the system will generate an SCI to notify the OS.</p>
<h3 id="input-parameters-4"><a class="header" href="#input-parameters-4">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-4"><a class="header" href="#output-parameters-4">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bst-battery-status">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-4"><a class="header" href="#ffa-acpi-example-4">FFA ACPI Example</a></h3>
<pre><code>Method (_BST) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(34){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,128,BSTD) // Out – Raw data response 4 DWords

    Store(20, LENG)
    Store(0x2, CMDD) // EC_BAT_GET_BST
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BSTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_psr"><a class="header" href="#ec_bat_get_psr">EC_BAT_GET_PSR</a></h2>
<p>Returns whether the power source device is currently in use. This can be
used to determine if system is running off this power supply or adapter.
On mobile systes this will report that the system is not running on the
AC adapter if any of the batteries in the system is being forced to
discharge. In systems that contains multiple power sources, this object
reports the power source’s online or offline status.</p>
<h3 id="input-parameters-5"><a class="header" href="#input-parameters-5">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-5"><a class="header" href="#output-parameters-5">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#battery-control-methods">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-5"><a class="header" href="#ffa-acpi-example-5">FFA ACPI Example</a></h3>
<pre><code>Method (_PSR) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,32,PSRD) // Out – Raw data response (overlaps with CMDD)
    
    Store(20, LENG)
    Store(0x3, CMDD) // EC_BAT_GET_PSR
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (PSRD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_pif"><a class="header" href="#ec_bat_get_pif">EC_BAT_GET_PIF</a></h2>
<p>This object returns information about the Power Source, which remains
constant until the Power Source is changed. When the power source
changes, the platform issues a Notify(0x0) (Bus Check) to the Power
Source device to indicate that OSPM must re-evaluate the _PIF object.</p>
<h3 id="input-parameters-6"><a class="header" href="#input-parameters-6">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-6"><a class="header" href="#output-parameters-6">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#pif-power-source-information">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-6"><a class="header" href="#ffa-acpi-example-6">FFA ACPI Example</a></h3>
<pre><code>Method (_PIF) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,1088,PIFD) // Out – Raw data response (overlaps with CMDD)
    Store(20, LENG)
    Store(0x4, CMDD) // EC_BAT_GET_PIF
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (PIFD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bps"><a class="header" href="#ec_bat_get_bps">EC_BAT_GET_BPS</a></h2>
<p>This optional object returns the power delivery capabilities of the
battery at the present time. If multiple batteries are present within
the system, the sum of peak power levels from each battery can be used
to determine the total available power.</p>
<h3 id="input-parameters-7"><a class="header" href="#input-parameters-7">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-7"><a class="header" href="#output-parameters-7">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-7"><a class="header" href="#ffa-acpi-example-7">FFA ACPI Example</a></h3>
<pre><code>Method (_BPS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,136,BPSD) // Out – BSP structure 5 integers

    Store(20, LENG)
    Store(0x5, CMDD) // EC_BAT_GET_BPS
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_btp"><a class="header" href="#ec_bat_set_btp">EC_BAT_SET_BTP</a></h2>
<p>This object is used to set a trip point to generate an SCI whenever the
Battery Remaining Capacity reaches or crosses the value specified in the
_BTP object. Required on systems supporting Modern Standby</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/platform-design-for-modern-standby">Platform design for modern standby | Microsoft
Learn</a></p>
<h3 id="input-parameters-8"><a class="header" href="#input-parameters-8">Input Parameters</a></h3>
<p>See ACPI documentation for details</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#btp-battery-trip-point">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-8"><a class="header" href="#output-parameters-8">Output Parameters</a></h3>
<p>None</p>
<h3 id="ffa-acpi-example-8"><a class="header" href="#ffa-acpi-example-8">FFA ACPI Example</a></h3>
<pre><code>Method (_BTP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDWordField(BUFF,19, BTP1) // In – Battery Trip Point

    Store(20, LENG)
    Store(0x6, CMDD) // EC_BAT_SET_BTP
    Store(Arg0, BTP1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bpc"><a class="header" href="#ec_bat_get_bpc">EC_BAT_GET_BPC</a></h2>
<p>This optional object returns static values that are used to configure
power threshold support in the platform firmware. OSPM can use the
information to determine the capabilities of power delivery and
threshold support for each battery in the system.</p>
<h3 id="input-parameters-9"><a class="header" href="#input-parameters-9">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-9"><a class="header" href="#output-parameters-9">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpc-battery-power-characteristics">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-9"><a class="header" href="#ffa-acpi-example-9">FFA ACPI Example</a></h3>
<pre><code>Method (_BPC) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,19,128, BPCD) // Out – BPC output Data

    Store(20, LENG)
    Store(0x8, CMDD) // EC_BAT_GET_BPC
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPCD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bpt"><a class="header" href="#ec_bat_set_bpt">EC_BAT_SET_BPT</a></h2>
<p>his optional object may be present under a battery device. OSPM must
read _BPC first to determine the power delivery capability threshold
support in the platform firmware and invoke this Method in order to
program the threshold accordingly. If the platform does not support
battery peak power thresholds, this Method should not be included in the
namespace.</p>
<h3 id="input-parameters-10"><a class="header" href="#input-parameters-10">Input Parameters</a></h3>
<p>See ACPI specification for input parameters</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpt-battery-power-threshold">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-10"><a class="header" href="#output-parameters-10">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpt-battery-power-threshold">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-10"><a class="header" href="#ffa-acpi-example-10">FFA ACPI Example</a></h3>
<pre><code>Method (_BPT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, BPT1) // In – Averaging Interval
    CreateDwordField(BUFF,23, BPT2) // In – Threshold ID
    CreateDwordField(BUFF,27, BPT3) // In – Threshold Value
    CreateField(BUFF,144,32,BPTD) // Out – BPT integer output

    Store(0x30, LENG)
    Store(0x7, CMDD) // EC_BAT_SET_BPT
    Store(Arg0,BPT1)
    Store(Arg1,BPT2)
    Store(Arg2,BPT3)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bmc"><a class="header" href="#ec_bat_set_bmc">EC_BAT_SET_BMC</a></h2>
<p>This object is used to initiate calibration cycles or to control the
charger and whether or not a battery is powering the system. This object
is only present under a battery device if the _BMD Capabilities Flags
field has bit 0, 1, 2, or 5 set.</p>
<h3 id="input-parameters-11"><a class="header" href="#input-parameters-11">Input Parameters</a></h3>
<p>See ACPI specification for input parameter definition</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bmc-battery-maintenance-control">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-11"><a class="header" href="#output-parameters-11">Output Parameters</a></h3>
<p>None</p>
<h3 id="ffa-acpi-example-11"><a class="header" href="#ffa-acpi-example-11">FFA ACPI Example</a></h3>
<pre><code>Method (_BMC) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDWordField(BUFF,19, BMCF) // In – Feature Control Flags

    Store(20, LENG)
    Store(0x9, CMDD) // EC_BAT_SET_BMC
    Store(Arg0,BMCF)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bmd"><a class="header" href="#ec_bat_get_bmd">EC_BAT_GET_BMD</a></h2>
<p>This optional object returns information about the battery’s
capabilities and current state in relation to battery calibration and
charger control features. If the _BMC object (defined below) is present
under a battery device, this object must also be present. Whenever the
Status Flags value changes, AML code will issue a
Notify(battery_device, 0x82). In addition, AML will issue a
Notify(battery_device, 0x82) if evaluating _BMC did not result in
causing the Status Flags to be set as indicated in that argument to
_BMC. AML is not required to issue Notify(battery_device, 0x82) if the
Status Flags change while evaluating _BMC unless the change does not
correspond to the argument passed to _BMC.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bmd-battery-maintenance-data">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-12"><a class="header" href="#input-parameters-12">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-12"><a class="header" href="#output-parameters-12">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-12"><a class="header" href="#ffa-acpi-example-12">FFA ACPI Example</a></h3>
<pre><code>Method (_BMD) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(40){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,160,BMDD) // Out – BMD structure 5 DWords

    Store(20, LENG)
    Store(0xA, CMDD) // EC_BAT_GET_BMD
    Store(Arg0,BMCF)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMDD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bct"><a class="header" href="#ec_bat_get_bct">EC_BAT_GET_BCT</a></h2>
<p>When the battery is charging, this optional object returns the estimated
time from present to when it is charged to a given percentage of Last
Full Charge Capacity.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bct-battery-charge-time">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-13"><a class="header" href="#input-parameters-13">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-13"><a class="header" href="#output-parameters-13">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-13"><a class="header" href="#ffa-acpi-example-13">FFA ACPI Example</a></h3>
<pre><code>Method (_BCT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDWordField(BUFF,19, CHLV) // In – ChargeLevel
    CreateField(BUFF,144,32,BCTD) // Out – Raw data response (overlaps with CMDD)

    Store(20, LENG)
    Store(0xB, CMDD) // EC_BAT_GET_BCT
    Store(Arg0,CHLV)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BCTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_btm"><a class="header" href="#ec_bat_get_btm">EC_BAT_GET_BTM</a></h2>
<p>This optional object returns the estimated runtime of the battery while
it is discharging.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#btm-battery-time">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-14"><a class="header" href="#input-parameters-14">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-14"><a class="header" href="#output-parameters-14">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h2 id="ec_bat_set_bms"><a class="header" href="#ec_bat_set_bms">EC_BAT_SET_BMS</a></h2>
<p>This object is used to set the sampling time of the battery capacity
measurement, in milliseconds.</p>
<p>The Sampling Time is the duration between two consecutive measurements
of the battery’s capacities specified in _BST, such as present rate and
remaining capacity. If the OSPM makes two succeeding readings through
_BST beyond the duration, two different results will be returned.</p>
<p>The OSPM may read the Max Sampling Time and Min Sampling Time with _BIX
during boot time, and set a specific sampling time within the range with
_BMS.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bms-battery-measurement-sampling-time">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-15"><a class="header" href="#input-parameters-15">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-15"><a class="header" href="#output-parameters-15">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-14"><a class="header" href="#ffa-acpi-example-14">FFA ACPI Example</a></h3>
<pre><code>Method (_BMS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, BMS1) // In – Sampling Time
    CreateField(BUFF,144,32,BMSD) // Out – BPT integer output

    Store(20, LENG)
    Store(0xD, CMDD) // EC_BAT_SET_BMS
    Store(Arg0,BMS1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bma"><a class="header" href="#ec_bat_set_bma">EC_BAT_SET_BMA</a></h2>
<p>This object is used to set the averaging interval of the battery
capacity measurement, in milliseconds. The Battery Measurement Averaging
Interval is the length of time within which the battery averages the
capacity measurements specified in _BST, such as remaining capacity and
present rate.</p>
<p>The OSPM may read the Max Average Interval and Min Average Interval with
_BIX during boot time, and set a specific average interval within the
range with _BMA.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bma-battery-measurement-averaging-interval">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-16"><a class="header" href="#input-parameters-16">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-16"><a class="header" href="#output-parameters-16">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-15"><a class="header" href="#ffa-acpi-example-15">FFA ACPI Example</a></h3>
<pre><code>Method (_BMA) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, BMA1) // In – Averaging Interval
    CreateField(BUFF,144,32,BMAD) // Out – BMA integer output
    
    Store(20, LENG)
    Store(0xE, CMDD) // EC_BAT_SET_BMA
    Store(Arg0,BMS1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMAD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_sta"><a class="header" href="#ec_bat_get_sta">EC_BAT_GET_STA</a></h2>
<p>Returns battery status to the OS along with any error conditions as defined by ACPI specification.</p>
<h3 id="input-parameters-17"><a class="header" href="#input-parameters-17">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-17"><a class="header" href="#output-parameters-17">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/06_Device_Configuration/Device_Configuration.html#sta-device-status">10. Power Source and Power Meter Devices — ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-16"><a class="header" href="#ffa-acpi-example-16">FFA ACPI Example</a></h3>
<pre><code>Method (_STA) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,32,STAD) // Out – Raw data with status

    Store(20, LENG)
    Store(0xF, CMDD) // EC_BAT_GET_STA
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)


    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (STAD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-zone-service"><a class="header" href="#thermal-zone-service">Thermal Zone Service</a></h1>
<p>Battery temperature and other temperatures are read through a modified
thermal interface called Microsoft Temperature Sensor that implements
the _TMP and _DSM functionality. There is also still a generic thermal
zone interface which has a few more entries for system outside of MPTF.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>EC_THM_GET_TMP = 0x1</td><td>Returns the thermal zone’s current temperature in tenths of degrees.</td></tr>
<tr><td>EC_THM_SET_THRS = 0x2</td><td>Sets the thresholds for high, low and timeout.</td></tr>
<tr><td>EC_THM_GET_THRS = 0x3</td><td>Get thresholds for low and high points</td></tr>
<tr><td>EC_THM_SET_SCP = 0x4</td><td>Set cooling Policy for thermal zone</td></tr>
<tr><td>EC_THM_GET_VAR = 0x5</td><td>Read DWORD variable related to thermal</td></tr>
<tr><td>EC_THM_SET_VAR = 0x6</td><td>Write DWORD variable related to thermal</td></tr>
</tbody></table>
</div>
<h2 id="ec_thm_get_tmp"><a class="header" href="#ec_thm_get_tmp">EC_THM_GET_TMP</a></h2>
<p>The Microsoft Thermal Sensor is a simplified <a href="https://uefi.org/specs/ACPI/6.5/11_Thermal_Management.html?highlight=_tmp">ACPI Thermal Zone
object</a>,
it only keeps the temperature input part of the thermal zone. It is used
as the interface to send temperatures from the hardware to the OS. Like
the thermal zone, Thermal Sensor also supports getting temperatures
through _TMP method.</p>
<h3 id="input-parameters-18"><a class="header" href="#input-parameters-18">Input Parameters</a></h3>
<p>Arg0 – Byte Thermal Zone Identifier</p>
<h3 id="output-parameters-18"><a class="header" href="#output-parameters-18">Output Parameters</a></h3>
<p>An Integer containing the current temperature of the thermal zone (in
tenths of degrees Kelvin)</p>
<p>The return value is the current temperature of the thermal zone in
tenths of degrees Kelvin. For example, 300.0K is represented by the
integer 3000.</p>
<h3 id="ffa-acpi-example-17"><a class="header" href="#ffa-acpi-example-17">FFA ACPI Example</a></h3>
<pre><code>Method (_TMP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateByteField(BUFF,19, TMP1) // In – Thermal Zone Identifier
    CreateField(BUFF,144,32,TMPD) // Out – temperature for TZ

    Store(20, LENG)
    Store(0x1, CMDD) // EC_THM_GET_TMP
    Store(1,TMP1)
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (TMPD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_thm_set_thrs"><a class="header" href="#ec_thm_set_thrs">EC_THM_SET_THRS</a></h2>
<p>Update thresholds for thermal zone</p>
<p>The platform should inform the OSPM to read _TMP method through
Notify(device, 0x80) when <strong><span class="underline">any</span></strong> of
below conditions is met: </p>
<ul>
<li>The <strong>Timeout</strong> has been met. </li>
</ul>
<!-- end list -->
<ul>
<li>The current temperature crosses the zone specified by
<strong>LowTemperature</strong> or <strong>HighTemperature</strong>. </li>
</ul>
<h3 id="input-parameters-19"><a class="header" href="#input-parameters-19">Input Parameters</a></h3>
<p>Arg0 – Byte Thermal Zone Identifier</p>
<p>Arg1 – Timeout // Integer (DWORD) in mS</p>
<p>Arg2 – LowTemperature // Integer (DWORD) in tenth deg Kelvin</p>
<p>Arg3 - HighTemperature // Integer (DWORD) in tenth deg Kelvin</p>
<h3 id="output-parameters-19"><a class="header" href="#output-parameters-19">Output Parameters</a></h3>
<p>Integer with status</p>
<ul>
<li>
<p>0x00000000: Succeed </p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter </p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision </p>
</li>
<li>
<p>0x00000003: Failure, hardware error </p>
</li>
<li>
<p>Others: Reserved </p>
</li>
</ul>
<h3 id="ffa-acpi-example-18"><a class="header" href="#ffa-acpi-example-18">FFA ACPI Example</a></h3>
<pre><code>Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj}) {
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(“1f0849fc-a845-4fcf-865c-4101bf8e8d79 ”)))
  {

  // Implement function 1 which is update threshold
  If(LEqual(Arg2,One)) {
    // Check to make sure FFA is available and not unloaded
    If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateByteField(BUFF,19, TID1) // In – Thermal Zone Identifier
    CreateDwordField(BUFF,20,THS1) // In – Timeout in ms
    CreateDwordField(BUFF,24,THS2) // In – Low threshold tenth Kelvin
    CreateDwordField(BUFF,28,THS3) // In – High threshold tenth Kelvin
    CreateField(BUFF,144,32,THSD) // Out – Status from EC

    Store(0x30, LENG)
    Store(0x2, CMDD) // EC_THM_SET_THRS
    Store(1,TID1)
    Store(Arg0,THS1)
    Store(Arg1,THS2)
    Store(Arg2,THS3)
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (THSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_thm_get_thrs"><a class="header" href="#ec_thm_get_thrs">EC_THM_GET_THRS</a></h2>
<p>Read back thresholds that have been set or default thresholds that exist
on the EC.</p>
<h3 id="input-parameters-20"><a class="header" href="#input-parameters-20">Input Parameters</a></h3>
<p>Arg0 - Thermal ID – Identifier to determine which TZ to read the
thresholds for</p>
<h3 id="output-parameters-20"><a class="header" href="#output-parameters-20">Output Parameters</a></h3>
<p>Arg0 – Status // 0 on success or neagtive error code</p>
<p>Arg1 – Timeout // Integer (DWORD) in mS</p>
<p>Arg2 – LowTemperature // Integer (DWORD) in tenth deg Kelvin</p>
<p>Arg3 - HighTemperature // Integer (DWORD) in tenth deg Kelvin</p>
<h3 id="ffa-acpi-example-19"><a class="header" href="#ffa-acpi-example-19">FFA ACPI Example</a></h3>
<pre><code>Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj}) {
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(“1f0849fc-a845-4fcf-865c-4101bf8e8d79 ”)))
  {
    // Implement function 2 which is update threshold
    If(LEqual(Arg2,Two)) {
      // Check to make sure FFA is available and not unloaded
      If(LEqual(\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(34){}) // Create buffer for send/recv data
        CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
        CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
        CreateField(BUFF,16,128,UUID) // UUID of service
        CreateByteField(BUFF,18, CMDD) // In – First byte of command
        CreateByteField(BUFF,19, TID1) // In – Thermal Zone Identifier
        CreateField(BUFF,144,128,THSD) // Out – Includes status, timeout, low/high
        
        Store(20, LENG)
        Store(0x3, CMDD) // EC_THM_GET_THRS
        Store(1,TID1)
        Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

        If(LEqual(STAT,0x0) ) // Check FF-A successful?
        {
          Return (THSD)
        } else {
          Return(Zero)
        }
    } else {
      Return(Zero)
    }
  }
}
</code></pre>
<h2 id="ec_thm_set_scp"><a class="header" href="#ec_thm_set_scp">EC_THM_SET_SCP</a></h2>
<p>This optional object is a control method that OSPM invokes to set the
platform’s cooling mode policy setting. </p>
<h3 id="input-parameters-21"><a class="header" href="#input-parameters-21">Input Parameters</a></h3>
<p>Arg0 - Identifier to determine which TZ to read the thresholds for</p>
<p>Arg1 - Mode An Integer containing the cooling mode policy code</p>
<p>Arg2 - AcousticLimit An Integer containing the acoustic limit</p>
<p>Arg3 - PowerLimit An Integer containing the power limit</p>
<h3 id="output-parameters-21"><a class="header" href="#output-parameters-21">Output Parameters</a></h3>
<p>Arg0 – Status from EC</p>
<ul>
<li>
<p>0x00000000: Succeed </p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter </p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision </p>
</li>
<li>
<p>0x00000003: Failure, hardware error </p>
</li>
<li>
<p>Others: Reserved </p>
</li>
</ul>
<h3 id="ffa-acpi-example-20"><a class="header" href="#ffa-acpi-example-20">FFA ACPI Example</a></h3>
<pre><code>Method (_SCP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateByteField(BUFF,19, SCP0) // In – Thermal Zone Identifier
    CreateDwordField(BUFF,20, SCP1) // In – Cooling mode policy
    CreateDwordField(BUFF,24, SCP2) // In – Acoustic Limit
    CreateDwordField(BUFF,28, SCP3) // In – Power Limit
    CreateField(BUFF,144,32, SCPD) // Out – temperature for TZ

    Store(0x30, LENG)
    Store(0x4, CMDD) // EC_THM_SET_SCP
    Store(1,SCP0)
    Store(Arg0,SCP1)
    Store(Arg1,SCP2)
    Store(Arg2,SCP3)
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (SCPD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_thm_get_var"><a class="header" href="#ec_thm_get_var">EC_THM_GET_VAR</a></h2>
<p>This API is to read a variable from the EC related to thermal. Variables
are defined as GUID’s and include length of variable to read. In the
case of default MPTF interface it is expecting a 32-bit variable.</p>
<h3 id="input-parameters-22"><a class="header" href="#input-parameters-22">Input Parameters</a></h3>
<p>Arg0 – 128-bit UUID the defines the variable</p>
<p>Arg1 – 16-bit Length field specifies the length of variable in bytes</p>
<h3 id="output-parameters-22"><a class="header" href="#output-parameters-22">Output Parameters</a></h3>
<p>Arg0 – 32-bit status field</p>
<ul>
<li>
<p>0x00000000: Succeed </p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter </p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision </p>
</li>
<li>
<p>0x00000003: Failure, hardware error </p>
</li>
<li>
<p>Others: Reserved </p>
</li>
</ul>
<p>Var – Variable length data must match requested length otherwise should
return error code</p>
<h3 id="ffa-acpi-example-21"><a class="header" href="#ffa-acpi-example-21">FFA ACPI Example</a></h3>
<pre><code>Method(GVAR,2,Serialized) {
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(38){})
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateByteField(BUFF,19,INST) // Instance ID
    CreateWordField(BUFF,20,VLEN) // 16-bit variable length
    CreateField(BUFF,176,128,VUID) // UUID of variable to read
    CreateField(BUFF,208,64,RVAL) // Output Data
  
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
    Store(38, LENG)
    Store(0x5, CMDD) // EC_THM_GET_VAR
    Store(Arg0,INST) // Save instance ID
    Store(4,VLEN) // Variable is always DWORD here
    Store(Arg1, VUID)
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
  
    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
     Return (RVAL)
    }
  }
  Return (Ones)
}
</code></pre>
<h2 id="ec_thm_set_var"><a class="header" href="#ec_thm_set_var">EC_THM_SET_VAR</a></h2>
<p>This API is to write a variable to the EC related to thermal. Variables
are defined as GUID’s and include length of variable to write. In the
case of default MPTF interface it is expecting a 32-bit variable.</p>
<h3 id="input-parameters-23"><a class="header" href="#input-parameters-23">Input Parameters</a></h3>
<p>Arg0 – 128-bit UUID the defines the variable</p>
<p>Arg1 – 16-bit Length field specifies the length of variable in bytes</p>
<p>Var - Variable length field of variable data</p>
<h3 id="output-parameters-23"><a class="header" href="#output-parameters-23">Output Parameters</a></h3>
<p>Arg0 – 32-bit status field</p>
<ul>
<li>
<p>0x00000000: Succeed </p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter </p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision </p>
</li>
<li>
<p>0x00000003: Failure, hardware error </p>
</li>
<li>
<p>Others: Reserved </p>
</li>
</ul>
<h3 id="ffa-acpi-example-22"><a class="header" href="#ffa-acpi-example-22">FFA ACPI Example</a></h3>
<pre><code>Method(SVAR,3,Serialized) {
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(42){})
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateByteField(BUFF,19,INST) // Instance ID
    CreateWordField(BUFF,20,VLEN) // 16-bit variable length
    CreateField(BUFF,176,128,VUID) // UUID of variable to read
    CreateDwordField(BUFF,38,DVAL) // Data value
    CreateField(BUFF,208,32,RVAL) // Ouput Data

    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
    Store(42, LENG)
    Store(0x6, CMDD) // EC_THM_SET_VAR
    Store(Arg0,INST) // Save instance ID
    Store(4,VLEN) // Variable is always DWORD here
    Store(Arg1, VUID)
    Store(Arg2,DVAL)
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (RVAL)
    }
  }
  Return (Ones)
}
</code></pre>
<h1 id="fan-service"><a class="header" href="#fan-service">Fan Service</a></h1>
<p>The new MBTF framework depends on reading and writing variables on the
EC to allow the EC to make the best decisions on cooling. The
recommendations from the OS are aggregated on the EC side and decisions
are made on setting FAN speed based on these.</p>
<p>All the control of fan and thermal parameters is done through variable
interface using EC_THM_GET_VAR and EC_THM_SET_VAR.</p>
<h2 id="fan-and-thermal-variables"><a class="header" href="#fan-and-thermal-variables">Fan and Thermal variables</a></h2>
<p>It is optional to implement Dba and Sones.</p>
<table>
<thead>
<tr class="header">
<th><strong>Variable</strong></th>
<th><strong>GUID</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<td>OnTemp</td>
<td>ba17b567-c368-48d5-bc6f-a312a41583c1</td>
<td>Lowest temperature at which the fan is turned on.</td>
</tr>
<td>RampTemp</td>
<td>3a62688c-d95b-4d2d-bacc-90d7a5816bcd</td>
<td>Temperature at which the fan starts ramping from min speed.</td>
</tr>
<td>MaxTemp</td>
<td>dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76</td>
<td>Temperature at top of fan ramp where fan is at maximum speed.</td>
</tr>
<td>CrtTemp</td>
<td>218246e7-baf6-45f1-aa13-07e4845256b8</td>
<td>Critical temperature at which we need to shut down the system.</td>
</tr>
<td>ProcHotTemp</td>
<td>22dc52d2-fd0b-47ab-95b8-26552f9831a5</td>
<td>Temperature at which the EC will assert the PROCHOT notification.</td>
</tr>
<td>MinRpm</td>
<td>db261c77-934b-45e2-9742-256c62badb7a</td>
<td>Minimum RPM FAN speed</td>
</tr>
<td>MinDba (Optional)</td>
<td>0457a722-58f4-41ca-b053-c7088fcfb89d</td>
<td>Minimum Dba from FAN</td>
</tr>
<td><p>MinSones (Optional)</td>
<td>311668e2-09aa-416e-a7ce-7b978e7f88be</td>
<td>Minimum Sones from FAN</td>
</tr>
<td>MaxRpm</td>
<td>5cf839df-8be7-42b9-9ac5-3403ca2c8a6a</td>
<td>Maximum RPM for FAN</td>
</tr>
<td>MaxDba (Optional)</td>
<td>372ae76b-eb64-466d-ae6b-1228397cf374</td>
<td>Maximum DBA for FAN</td>
</tr>
<td>MaxSones (Optional)</td>
<td>6deb7eb1-839a-4482-8757-502ac31b20b7</td>
<td>Maximum Sones for FAN</td>
</tr>
<td>ProfileType</td>
<td>23b4a025-cdfd-4af9-a411-37a24c574615</td>
<td>Set profile for EC, gaming, quiet, lap, etc</td>
</tr>
<td>CurrentRpm</td>
<td>adf95492-0776-4ffc-84f3-b6c8b5269683</td>
<td>The current RPM of FAN</td>
</tr>
<td>CurrentDba (Optional)</td>
<td>4bb2ccd9-c7d7-4629-9fd6-1bc46300ee77</td>
<td>The current Dba from FAN</td>
</tr>
<td>CurrentSones (Optional)</td>
<td>7719d686-02af-48a5-8283-20ba6ca2e940</td>
<td>The current Sones from FAN</td>
</tr>
</tbody>
</table>
<h2 id="acpi-example-of-inputoutput-_dsm"><a class="header" href="#acpi-example-of-inputoutput-_dsm">ACPI example of Input/Output _DSM</a></h2>
<pre><code>// Arg0 GUID
// 07ff6382-e29a-47c9-ac87-e79dad71dd82 - Input
// d9b9b7f3-2a3e-4064-8841-cb13d317669e - Output
// Arg1 Revision
// Arg2 Function Index
// Arg3 Function dependent

Method(_DSM, 0x4, Serialized) {
  // Input Variable
  If(LEqual(ToUuid("07ff6382-e29a-47c9-ac87-e79dad71dd82"),Arg0)) {
    Switch(Arg2) {
      Case(0) {
        // We support function 0-3
        Return(0xf)
      }
      Case(1) {
        Return(GVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"))) // OnTemp
      }
      Case(2) {
        Return(GVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"))) // RampTemp
      }
      Case(3) {
        Return(GVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"))) // MaxTemp
      }
    }
    Return(Ones)
  }

  // Output Variable
  If(LEqual(ToUuid("d9b9b7f3-2a3e-4064-8841-cb13d317669e"),Arg0)) {
    Switch(Arg2) {
      Case(0) {
        // We support function 0-3
        Return(0xf)
      }
      Case(1) {
        Return(SVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"),Arg3)) // OnTemp
      }

      Case(2) {
        Return(SVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"),Arg3)) // RampTemp
      }

      Case(3) {
        Return(SVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"),Arg3)) // MaxTemp
      }
    }
    Return(Ones)
  }
  Return (Ones)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ucsi-interface"><a class="header" href="#ucsi-interface">UCSI Interface</a></h1>
<p>EC must have the ability to interface with a discrete PD controller to
negotiate power contracts/alt-modes with port partner</p>
<p>See the UCSI specification for commands that are required in all UCSI
implementations.</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/ucsi">USB-C Connector System Software Interface (UCSI) Driver - Windows
drivers | Microsoft
Learn</a></p>
<p>In addition to the commands marked as <strong>Required</strong>, Windows requires
these commands:</p>
<ul>
<li>
<p>GET_ALTERNATE_MODES</p>
</li>
<li>
<p>GET_CAM_SUPPORTED</p>
</li>
<li>
<p>GET_PDOS</p>
</li>
<li>
<p>SET_NOTIFICATION_ENABLE: The system or controller must support the
following notifications within SET_NOTIFICATION_ENABLE:</p>
<ul>
<li>
<p>Supported Provider Capabilities Change</p>
</li>
<li>
<p>Negotiated Power Level Change</p>
</li>
</ul>
</li>
<li>
<p>GET_CONNECTOR_STATUS: The system or controller must support these
connector status changes within GET_CONNECTOR_STATUS:</p>
<ul>
<li>
<p>Supported Provider Capabilities Change</p>
</li>
<li>
<p>Negotiated Power Level Change</p>
</li>
</ul>
</li>
</ul>
<p><img src="specs/ec_interface/media/image10.png" alt="Diagram of USB Type-C software components." /></p>
<h2 id="ucsi-acpi-interface"><a class="header" href="#ucsi-acpi-interface">UCSI ACPI Interface</a></h2>
<p><img src="specs/ec_interface/media/image11.png" alt="A diagram of a memory Description automatically generated" /></p>
<h3 id="shared-mailbox-interface"><a class="header" href="#shared-mailbox-interface">Shared Mailbox Interface</a></h3>
<p>The following table is the reserved memory structure that must be
reserved and shared with the EC for communication. When using FF-A this
memory region must be statically carved out and 4K aligned and directly
accessible by secure world.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Offset (Bytes)</strong></th><th><strong>Mnemonic</strong></th><th><strong>Description</strong></th><th><strong>Direction</strong></th><th><strong>Size (bits)</strong></th></tr></thead><tbody>
<tr><td>0</td><td>VERSION</td><td>UCSI Version Number</td><td>PPM-&gt;OPM</td><td>16</td></tr>
<tr><td>2</td><td>RESERVED</td><td>Reserved</td><td>N/A</td><td>16</td></tr>
<tr><td>4</td><td>CCI</td><td>USB Type-C Command Status and Connector Change Indication</td><td>PPM-&gt;OPM</td><td>32</td></tr>
<tr><td>8</td><td>CONTROL</td><td>USB Type-C Control</td><td>OPM-&gt;PPM</td><td>64</td></tr>
<tr><td>16</td><td>MESSAGE IN</td><td>USB Type-C Message In</td><td>PPM-&gt;OPM</td><td>128</td></tr>
<tr><td>32</td><td>MESSAGE OUT</td><td>USB Type-C Message Out</td><td>OPM-&gt;PPM</td><td>128</td></tr>
</tbody></table>
</div>
<h3 id="acpi-definitions"><a class="header" href="#acpi-definitions">ACPI Definitions</a></h3>
<pre><code>Device(USBC) {
  Name(_HID,EISAID(“USBC000”))
  Name(_CID,EISAID(“PNP0CA0”))
  Name(_UID,1)
  Name(_DDN, “USB Type-C”)
  Name(_ADR,0x0)

  OperationRegion(USBC, SystemMemory, 0xFFFF0000, 0x30)
  Field(USBC,AnyAcc,Lock,Preserve)
  {
    // USB C Mailbox Interface
    VERS,16, // PPM-\&gt;OPM Version
    RES, 16, // Reservied
    CCI, 32, // PPM-\&gt;OPM CCI Indicator
    CTRL,64, // OPM-\&gt;PPM Control Messages
    MSGI,128, // OPM-\&gt;PPM Message In
    MSGO,128, // PPM-\&gt;OPM Message Out
  }

  Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
  {
    // Compare passed in UUID to Supported UUID
    If(LEqual(Arg0,ToUUID(“6f8398c2-7ca4-11e4-ad36-631042b5008f”)))
    {
      // Use FFA to send Notification event down to copy data to EC
      If(LEqual(\\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
        CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
        CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
        CreateField(BUFF,16,128,UUID) // UUID of service
        CreateByteField(BUFF,18, CMDD) // In – First byte of command
        CreateField(BUFF,144,1024,FIFD) // Out – Msg data

        CreateField(BUFF,0x0,128,UUID)
        // Create USCI Doorbell Event

        Store(20, LENG)
        Store(0x0, CMDD) // UCSI set doorbell
        Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID) // UCSI
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

        If(LEqual(STAT,0x0) ) // Check FF-A successful?
        {
          Return (FIFD)
        } else {
          Return(error)?
        }
      } // End AVAL
    } // End UUID
  } // End DSM
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-input-management"><a class="header" href="#ec-input-management">EC Input Management</a></h1>
<p>An EC may have several input devices including LID, Power key, touch and
keyboard. HID based devices requiring low latency input, are recommended
to be connected directly through a non-secure BUS interface such as I2C
or I3C for performance reasons.</p>
<h2 id="lid-state"><a class="header" href="#lid-state">LID State</a></h2>
<p>Monitor sensors that indicate lid state. If lid is opened, potentially
boot the system. If lid is closed, potentially shut down or hibernate
the system.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>ACPI</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>_LID</td><td>Get state of LID device for clamshell designs</td></tr>
</tbody></table>
</div>
<h3 id="acpi-example-for-lid-notificiation"><a class="header" href="#acpi-example-for-lid-notificiation">ACPI Example for LID notificiation</a></h3>
<p>Assuming that LID is managed by the EC during registration we register
for Input Management service for a Virtual ID = 1</p>
<pre><code>Method(_RNY, 0, Serialized) {
  Return( Package() {
    Package(0x2) {
      ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),
      Buffer() {0x1,0x0} // Register event 0x1 for LID
    }
    } )
  }

  Method(_NFY, 2, Serialized) {
    // Arg0 == UUID
    // Arg1 == Notify ID
    If(LEqual(ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),Arg0)) {
      Switch(Arg1) {
      Case(1) {
        Notify(\\_SB._LID,0x80)
      }
    }
  }
}
</code></pre>
<h2 id="system-wake-event"><a class="header" href="#system-wake-event">System Wake Event</a></h2>
<p>Ability to wake the system from various external events. This is for
more complicated events that aren’t a simple GPIO for LID/Power button
that require EC monitoring.</p>
<h2 id="hid-descriptor-interface"><a class="header" href="#hid-descriptor-interface">HID descriptor Interface</a></h2>
<p>Communication with EC must have packet sent/received in HID format so
the OS HIDClass driver can properly understand requests. At this time
HID packets will go over HIDI2C but in future these HID packets could be
included over a single interface.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>HID IOCTL</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>IOCTL_HID_GET_DEVICE_DESCRIPTOR</td><td>Retrieves the device's HID descriptor</td></tr>
<tr><td>IOCTL_HID_GET_DEVICE_ATTRIBUTES</td><td>Retrieves a device's attributes in a HID_DEVICE_ATTRIBUTES structure</td></tr>
<tr><td>IOCTL_HID_GET_REPORT_DESCRIPTOR</td><td>Obtains the report descriptor for the HID device</td></tr>
<tr><td>IOCTL_HID_READ_REPORT</td><td>Returns a report from the device into a class driver-supplied buffer</td></tr>
<tr><td>IOCTL_HID_WRITE_REPORT</td><td>Transmits a class driver-supplied report to the device</td></tr>
<tr><td>IOCTL_HID_GET_FEATURE</td><td>Get capabilities of a feature from the device</td></tr>
<tr><td>IOCTL_HID_SET_FEATURE</td><td>Set/Enable a specific feature on device</td></tr>
<tr><td>IOCTL_HID_GET_INPUT_REPORT</td><td>Get input report from HID device if input device</td></tr>
<tr><td>IOCTL_HID_SET_OUTPUT_REPORT</td><td>Send output HID report to device</td></tr>
<tr><td>IOCTL_HID_GET_STRING</td><td>Get a specific string from device</td></tr>
<tr><td>IOCTL_HID_GET_INDEXED_STRING</td><td>Get a string from device based on index</td></tr>
<tr><td>IOCTL_HID_SEND_IDLE_NOTIFICATION</td><td>Notification to idle device into idle/sleep state</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ec-time-alarm-service"><a class="header" href="#ec-time-alarm-service">EC Time Alarm Service</a></h1>
<p>The following sections define the operation and definition of the
optional control method-based Time and Alarm device, which provides a
hardware independent abstraction and a more robust alternative to the
Real Time Clock (RTC)</p>
<p>ACPI specification details are in version 6.5 Chapter 9.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#time-and-alarm-device">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5 documentation
(uefi.org)</a></p>
<div class="table-wrapper"><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>EC_TAS_GET_GCP = 0x1</td><td>Get the capabilities of the time and alarm device</td></tr>
<tr><td>EC_TAS_GET_GRT = 0x2</td><td>Get the Real Time</td></tr>
<tr><td>EC_TAS_SET_SRT = 0x3</td><td>Set the Real Time</td></tr>
<tr><td>EC_TAS_GET_GWS = 0x4</td><td>Get Wake Status</td></tr>
<tr><td>EC_TAS_SET_CWS = 0x5</td><td>Clear Wake Status</td></tr>
<tr><td>EC_TAS_SET_STV = 0x6</td><td>Set Timer value for given timer</td></tr>
<tr><td>EC_TAS_GET_TIV = 0x7</td><td>Get Timer value remaining for given timer</td></tr>
</tbody></table>
</div>
<h2 id="ec_tas_get_gcp"><a class="header" href="#ec_tas_get_gcp">EC_TAS_GET_GCP</a></h2>
<p>This object is required and provides the OSPM with a bit mask of the
device capabilities.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#gcp-get-capability">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-24"><a class="header" href="#input-parameters-24">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-24"><a class="header" href="#output-parameters-24">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi"><a class="header" href="#ffa-acpi">FFA ACPI</a></h3>
<pre><code>Method (_GCP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,32,GCPD) // Out – 32-bit integer described above
  
    Store(20, LENG)
    Store(0x1, CMDD) // EC_TAS_GET_GCP
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GCDD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_get_grt"><a class="header" href="#ec_tas_get_grt">EC_TAS_GET_GRT</a></h2>
<p>This object is required if the capabilities bit 2 is set to 1. The OSPM
can use this object to get time. The return value is a buffer containing
the time information as described below.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#grt-get-real-time">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-25"><a class="header" href="#input-parameters-25">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-25"><a class="header" href="#output-parameters-25">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-23"><a class="header" href="#ffa-acpi-example-23">FFA ACPI Example</a></h3>
<pre><code>Method (_GRT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,144,128,GRTD) // Out – 128-bit output structure above

    Store(20, LENG)
    Store(0x2, CMDD) // EC_TAS_GET_GRT
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GRTD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_srt"><a class="header" href="#ec_tas_set_srt">EC_TAS_SET_SRT</a></h2>
<p>This object is required if the capabilities bit 2 is set to 1. The OSPM
can use this object to set the time.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#srt-set-real-time">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-26"><a class="header" href="#input-parameters-26">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-26"><a class="header" href="#output-parameters-26">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-24"><a class="header" href="#ffa-acpi-example-24">FFA ACPI Example</a></h3>
<pre><code>Method (_SRT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateField(BUFF,152,128,GRTD) // In – 128-bit output structure above

    Store(20, LENG)
    Store(0x3, CMDD) // EC_TAS_SET_SRT
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    }
  }
  Return(Zero)}
}
</code></pre>
<h2 id="ec_tas_get_gws"><a class="header" href="#ec_tas_get_gws">EC_TAS_GET_GWS</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
enables the OSPM to read the status of wake alarms</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#gws-get-wake-alarm-status">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-27"><a class="header" href="#input-parameters-27">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-27"><a class="header" href="#output-parameters-27">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-25"><a class="header" href="#ffa-acpi-example-25">FFA ACPI Example</a></h3>
<pre><code>Method (_GWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, GWS1) // In – Dword for timer type AC/DC
    CreateField(BUFF,144,32,GWSD) // Out – Dword timer state

    Store(20, LENG)
    Store(0x4, CMDD) // EC_TAS_GET_GWS
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GWSD)
    } 
  } 
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_cws"><a class="header" href="#ec_tas_set_cws">EC_TAS_SET_CWS</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
enables the OSPM to clear the status of wake alarms</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#cws-clear-wake-alarm-status">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-28"><a class="header" href="#input-parameters-28">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-28"><a class="header" href="#output-parameters-28">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-26"><a class="header" href="#ffa-acpi-example-26">FFA ACPI Example</a></h3>
<pre><code>Method (_CWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, GWS1) // In – Dword for timer type AC/DC
    CreateField(BUFF,144,32,CWSD) // Out – Dword timer state
 
    Store(20, LENG)
    Store(0x5, CMDD) // EC_TAS_SET_CWS
    Store(Arg0,GWS1)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (CWSD)
    }
  } 
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_stv"><a class="header" href="#ec_tas_set_stv">EC_TAS_SET_STV</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It sets
the timer to the specified value. </p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#stv-set-timer-value">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-29"><a class="header" href="#input-parameters-29">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-29"><a class="header" href="#output-parameters-29">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-27"><a class="header" href="#ffa-acpi-example-27">FFA ACPI Example</a></h3>
<pre><code>Method (_STV) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, GWS1) // In – Dword for timer type AC/DC
    CreateDwordField(BUFF,23, GWS2) // In – Dword Timer Value
    CreateField(BUFF,144,32,STVD) // Out – Dword timer state

    Store(20, LENG)
    Store(0x6, CMDD) // EC_TAS_SET_STV
    Store(Arg0,GWS1)
    Store(Arg1,GWS2)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
  
    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (STVD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_get_tiv"><a class="header" href="#ec_tas_get_tiv">EC_TAS_GET_TIV</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
returns the remaining time of the specified timer before that expires.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#tiv-timer-values">9. ACPI-Defined Devices and Device-Specific Objects — ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-30"><a class="header" href="#input-parameters-30">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-30"><a class="header" href="#output-parameters-30">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-28"><a class="header" href="#ffa-acpi-example-28">FFA ACPI Example</a></h3>
<pre><code>Method (_TIV) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In – First byte of command
    CreateDwordField(BUFF,19, GWS1) // In – Dword for timer type AC/DC
    CreateField(BUFF,144,32,TIVD) // Out – Dword timer state

    Store(20, LENG)
    Store(0x7, CMDD) // EC_TAS_GET_TIV
    Store(Arg0,GWS1)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (TIVD)
    }
  }
  Return(Zero)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-debug-service"><a class="header" href="#ec-debug-service">EC Debug Service</a></h1>
<p>The debug service is used for telemetry, debug logs, system reset
information etc.</p>
<h2 id="recovery-mode"><a class="header" href="#recovery-mode">Recovery Mode</a></h2>
<p>Put EC into recovery mode for development flashing and debugging.</p>
<h2 id="dump-debug-state"><a class="header" href="#dump-debug-state">Dump Debug State</a></h2>
<p>EC should be able to support typical engineering requests, such as
getting detailed subsystem information, setting/getting GPIOs, etc, for
design verification and benchtop testing.</p>
<h2 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h2>
<p>Ability to communicate with the HLOS event logging system, and record EC
critical events for later analysis.</p>
<h2 id="system-boot-state"><a class="header" href="#system-boot-state">System Boot State</a></h2>
<p>In many designs, OEMs will desire indication that the system is
responding to a power on request. This could be a logo display on the
screen or a bezel LED. EC should be able to control these devices during
the boot sequence.</p>
<p>During first boot sequence EC may also be initialized and setup its
services. Needs to know when OS is up to send notification for events
that are only used by OS.</p>
<h2 id="memory-mapped-transactions"><a class="header" href="#memory-mapped-transactions">Memory Mapped Transactions</a></h2>
<p>There are two cases where you may want to use the memory mapped
transactions. The first is if you have a large buffer you need to
transfer data between EC and HLOS like a debug buffer. The second use
case is if you want to emulate an eSPI memory mapped interface for
compatibility with legacy devices.</p>
<p>For this mode to work you will need memory carved out which is dedicated
and shared between HLOS and secure world. In your UEFI memory map this
memory should be marked as EfiMemoryReservedType so that the OS will not
use or allocate the memory. In your SP manifest file you will also need
to add access to this physical memory range. It needs to be aligned on a
4K boundary and a multiple of 4K. This memory region is carved out and
must never be used for any other purpose. Since the memory is shared
with HLOS there is also no security surrounding accesses to the memory.</p>
<h3 id="example-memory-mapped-interface"><a class="header" href="#example-memory-mapped-interface">Example Memory Mapped Interface</a></h3>
<pre><code>// Map 4K memory region
OperationRegion(ABCD, SystemMemory, 0xFFFF0000, 0x1000)

// Map fields in region if you want to access or set via ACPI
Field(ABCD,AnyAcc,Lock,Preserve) {
  VER,16, // Version
  RES, 16, // Reserved
  VAR1,32, // 32-bit variable1
  VAR2,64, // 64-bit variable1
  VAR3,128, // 128-bit variable1
}

// DSM Method to send sync event
Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
{
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(“6f8398c2-7ca4-11e4-ad36-631042b5008f”)))
  {
    // Use FFA to send Notification event down to copy data to EC
    If(LEqual(\\_SB.FFA0.AVAL,One)) {

      Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
      CreateByteField(BUFF,0,STAT) // Out – Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out – Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18, CMDD) // In – First byte of command
      CreateField(BUFF,144,1024,FIFD) // Out – Msg data

      // Create Doorbell Event
      Store(20, LENG)
      Store(0x0, CMDD) // UCSI set doorbell
      Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID)
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (Zero)
      } else {
        Return(One)
      }
    } // End AVAL
  } // End UUID
} // End DSM

</code></pre>
<p>Any updates from the EC come back through a notification event
registered in the FFA for this particular service.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-manufacturing-service"><a class="header" href="#ec-manufacturing-service">EC Manufacturing Service</a></h1>
<p>This service should contain all the functionality that is need to
perform self test, validation of the EC and special manufacturing modes.
This service should be disabled on retail devices or at least protected
to prevent unwanted modes.</p>
<h2 id="self-test"><a class="header" href="#self-test">Self Test</a></h2>
<p>EC should perform self test and return results/details of test
validation</p>
<h2 id="set-calibration-data"><a class="header" href="#set-calibration-data">Set Calibration Data</a></h2>
<p>Have ability to store factory calibrations and setup information into EC
non-volatile memory. For instance keyboard language information, or
thermistor calibration values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-oem-service"><a class="header" href="#ec-oem-service">EC OEM Service</a></h1>
<p>Any OEM special custom features should be put in their own service
sandbox to support OEM specific features. This will prevent definitions
from colliding with other services.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
