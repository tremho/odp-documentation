<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ODP Documentation Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODP Documentation Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="open-device-partnership-documentation-guide"><a class="header" href="#open-device-partnership-documentation-guide">Open Device Partnership documentation guide</a></h1>
<p>The purpose of this document is to guide you through an understanding of ODP regardless of where you are starting from or where your interest may lie.</p>
<p>The overall ODP umbrella is quite large and encompassing, and can be tricky to navigate through, so we will try to simplify that journey a little as well as giving direction on which path along the journey might best fit your interest or involvmement.</p>
<p>This document will briefly review the value proposition of ODP and why it is the right technology for the future of firmware development, at the right time.</p>
<p>Then the different 'tracks' of ODP will be explained.  Here, you may find you are interested in only one of these tracks, or you may find you want to learn more about all of them.</p>
<p>Then, what is inside ODP and where to find it is detailed further - this is a good resource for those simply wishing to navigate the maze of contributed repositories that are available and which ones fit together for a given task.</p>
<p>Finally, for developers wishing to know more about how all of this comes together, a series of example implementation exercises are detailed. These can be explored in themselves or toward the end of the example's goal to create a complete virtual laptop that integrates the product of each of the individual exercises into a practical working end result.</p>
<p>You are in control of how you navigate through this guide, whether you proceed through it all one step at a time, or jump into the paths you find most compelling to your interest is entirely up to you.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-odp"><a class="header" href="#why-odp">Why ODP?</a></h1>
<p>Modern computing devices are ubiquitous in our lives.  They are integral to multiple aspects of our lives, from our workplace, to our finances, our creative endeavors, and our personal lifestyles.</p>
<p>Computer technology seemingly lept from its cradle a half century ago and never slowed its pace. It is easy to take much of it for granted.</p>
<p>We marvel as the new applications show us increasingly amazing opportunities.  We also recognize and guard against the threats these applications pose to ourselves and society.</p>
<p>And in this heady environment, it is sometimes easy to forget that the "hidden parts" of these computers we use -- the lower-level hardware and firmware -- is often built upon languages and processes that, although having evolved to meet the demands of the time, are reaching the end of their practical sustainability for keeping up with the accelerating pace of the world around us.</p>
<p>What was originally just a "boot layer" and a few K of code for key hardware interfacing is now shouldering the responsibility of securing personal information and behavior patterns that a malicious intruder could use for nefarious purposes.</p>
<p>High-value proprietary algorithms and Artificial Intelligence models are now built into the firmware and must be locked down. An increasing number of "always ready" peripherals, such as the battery and charger, biometric identification mechanisms, network connections, and other concerns are being increasingly handled by independent MCUs that must coordinate with one another and with the host system in a responsive, increasingly complex, yet highly secure manner.</p>
<p>Trying to manage all of this with what has been the status-quo for these concerns in past decades, without memory-safe languages and with a loosely-federated collection of standards and patterns agreed upon by an ad-hoc consortium of vendors is increasingly dangerous and costly.</p>
<hr />
<div class="table-wrapper"><table><thead><tr><th><strong>Legacy Approach</strong></th><th><strong>ODP Approach</strong></th></tr></thead><tbody>
<tr><td>üêú Many vendor-specific hacks ‚ùå</td><td>üß© Cross-platform modularity üîí</td></tr>
<tr><td>‚ùÑÔ∏è Weak component isolation ü©∏</td><td>üîê Secure runtime services ü§ñ</td></tr>
<tr><td>üî© Proprietary tool building ‚öîÔ∏è</td><td>üõ†Ô∏è Rust-based build tools, Stuart üßë‚Äçüîß</td></tr>
</tbody></table>
</div>
<blockquote>
<p><em>The firmware we once almost ignored is now the front line of platform security</em></p>
</blockquote>
<hr />
<p>The Open Device Partnership offers an alternative and a way forward to a more sustainable future that, while still built upon the proven paradigms of the past, boldly rejects the patterns that are known to be costly and ineffective in favor of future-ready, portable, sustainable, and expandable alternatives.</p>
<p>Key to this is the adoption of the programming language Rust as the successor to C. This immediately brings confidence that the code will not be susceptible to programming-error related vulnerabilities that may lead to either costly performance behaviors or be maliciously exploited by opportunistic bad actors. Furthermore, it provides the confidence that code from outside of one's immediate provenance of control may be audited and trusted and ready to join into a firmware construction built upon industry standards.</p>
<p>In the pages ahead, we'll look a little more closely at the advantages of ODP one at a time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Reduce firmware attack surface significantly, and meet modern security expectations using proven tools and patterns.</p>
<h2 id="security-and-trustworthiness-from-the-ground-up"><a class="header" href="#security-and-trustworthiness-from-the-ground-up">Security and Trustworthiness from the Ground Up</a></h2>
<blockquote>
<p><em>‚ÄúIf the foundation is weak, nothing built on top can be trusted.‚Äù</em></p>
</blockquote>
<p>Rust is a modern, memory-safe language that mitigates entire classes of vulnerabilities endemic to C memory management, buffer overflows, use-after-free, and so forth by detecting and addressing these issues at compile time -- so there are few if any unpleasant surprises at runtime.</p>
<p>ODP is foundationally centered around Rust and not only embraces these philosophies, it defines patterns that further enhance the memory-safe paradigm, by preventing unauthorized access between ownership domains and guarding against possible malicious intrusions while implementing the proven industry-standard patterns proven in the industry.</p>
<pre class="mermaid">flowchart LR
  Start[Power On] --&gt; ROM
  ROM --&gt; FirmwareCheck[Validate Firmware Signature]
  FirmwareCheck --&gt; DXECore[Load DXE Core]
  DXECore --&gt; OSLoader[Invoke Bootloader]
  OSLoader --&gt; OSVerify[Validate OS Signature]
  OSVerify --&gt; OSBoot[Launch OS]
  OSBoot --&gt; Ready[Platform Ready]
</pre>
<p>Adoption of standards and patterns of DICE and EL2 Hypervisor supported architectures -- from a Rust-driven baseline - enables a hardware-rooted chain of trust across boot phases, aligning with NIST and platform security goals and requirements.</p>
<p>ODP makes component modularity and portability with a transparent provenance a practical and safe proposition by making it feasiable to audit and verify firmware behavior in specifically constrained ways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modular-and-composable-firmware-architecture"><a class="header" href="#modular-and-composable-firmware-architecture">Modular and Composable Firmware Architecture</a></h1>
<p>ODP offers Modularity and agility not normally found in the firmware domain.</p>
<p>The buzz and the headlines generated by advances in the computer world typically belong to those
who have created magic at the application layer. As such, this portion of the development community has seen exponential advances in the tooling and languages at their disposal.  This has provided a high level of modulariy and with it, agility, that has become synonymous with the market responsiveness we see in the evolution of our favorite applications.</p>
<p>Firmware development, on the other hand, has generally been mired in the processes of the past, and has
not enjoyed this same level of modularity and agility.</p>
<blockquote>
<p><em>‚ÄúSystems scale better when their parts can evolve independently.‚Äù</em></p>
</blockquote>
<h2 id="composable-and-portable-component-modules"><a class="header" href="#composable-and-portable-component-modules">Composable and portable component modules</a></h2>
<p>ODP changes that paradigm and raises the tide. It is inspired by modern software engineering practices: composability, dependency injection, testability.</p>
<p>Components (e.g., battery service, serial logging, boot policies) are decoupled and swappable, enabling faster iteration and better maintainability.</p>
<pre class="mermaid">graph LR
  PowerPolicy --&gt; BatteryService
  PowerPolicy --&gt; ChargerService
  PowerPolicy --&gt; ThermalService
  BatteryService --&gt; MockBattery
  ChargerService --&gt; SMbusDriver
</pre>
<p>Because Rust enforces its memory and safety management guarantees at compile time, tooling such as that found in ODP Patina for example will build a DXE Core monolithically, without the need for an RTOS, and supports a composed modularity paradigm by design, streamlining certification and troubleshooting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-domain-coherence"><a class="header" href="#cross-domain-coherence">Cross-Domain Coherence</a></h1>
<p>ODP is not just a patch atop of old layers.  It is explicitly aligning system layers to reduce duplication, ambiguity, and failure points.</p>
<p>ODP is not just a firmware stack, but a vision that unites the embedded controller, main firmware, and even secure services under a coherent design and tooling approach.</p>
<h2 id="common-patterns-with-clearly-defined-lanes"><a class="header" href="#common-patterns-with-clearly-defined-lanes">Common patterns with clearly defined lanes</a></h2>
<blockquote>
<p><em>‚ÄúSecure systems require secure interfaces ‚Äî everywhere.‚Äù</em></p>
</blockquote>
<p>Shared services and conventions allow clear division of responsibility between firmware, EC, and OS‚Äîwhile promoting reuse and coordination.</p>
<pre class="mermaid">graph LR
    Host[Host Domain] --&gt; HostServiceA
  Host --&gt; HostServiceB

  HostServiceA --&gt; HostDriverA
  HostServiceB --&gt; HostDriverB

  EC[Embedded Controller Domain] --&gt; ECServiceA
  EC --&gt; ECServiceB

  subgraph Shared Interface
    HostServiceA &lt;---&gt; ECServiceA
    HostServiceB &lt;---&gt; ECServiceB
  end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="improved-developer-experience"><a class="header" href="#improved-developer-experience">Improved Developer Experience</a></h1>
<p>ODP reduces developer friction and increases confidence, thus shortening the time to value for the development effort.</p>
<blockquote>
<p><em>"Firmware development shouldn‚Äôt feel like archaeology."</em></p>
</blockquote>
<p>Developers can build and test components in isolation (e.g., battery, GPIO, boot timer), aided by QEMU emulation, mocks, and test harnesses.</p>
<p><img src="why/./media/dev-then-now.png" alt="Then and Now" /></p>
<p>ODP can improve developer engagement and productivity by:</p>
<ul>
<li>üöÄ Reducing developer friction</li>
<li>üõ†Ô∏è Supporting tooling that‚Äôs approachable and efficient</li>
<li>üß™ Enabling fast iteration and confident change</li>
<li>üí¨ Reinforcing that firmware development is not arcane magic, just solid coding.</li>
</ul>
<p>The Rust ecosystem brings built-in unit testing, logging, dependency control (Cargo), and static analysis.</p>
<pre class="mermaid">timeline
  title Developer Workflow Evolution
  2000 : Edit ASM/C, guess BIOS behavior
  2010 : Use UEFI drivers, painful debug cycle
  2023 : Rust-based firmware prototypes emerge
  2024 : ODP introduces modular build + Stuart tools
  2025 : Fully testable DXE + EC code in Rust with shared tooling
</pre>
<pre class="mermaid">flowchart LR
  Idea[&quot;üí° Idea&quot;] --&gt; Dev[&quot;üß© Create Service Component&quot;]
  Dev --&gt; Test[&quot;üß™ Unit &amp; Desktop Test&quot;]
  Test --&gt; Build[&quot;üîß Cross-target Build&lt;br/&gt;(host &amp; EC)&quot;]
</pre>
<pre class="mermaid">flowchart LR
  Build --&gt; Sim[&quot;üñ•Ô∏è Simulate with Mock Devices&quot;]
  Sim --&gt; Flash[&quot;üöÄ Build &amp; Flash&quot;]
  Flash --&gt; Log[&quot;üìÑ Review Logs / Debug&quot;]
  Log --&gt; Iterate[&quot;üîÅ Iterate with Confidence&quot;]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sustainability-and-long-term-cost-reduction"><a class="header" href="#sustainability-and-long-term-cost-reduction">Sustainability and Long-Term Cost Reduction</a></h1>
<p>ODP can help cut tech debt at its root by investing in sustainable design by enabling leaner teams and cleaner codebases.</p>
<blockquote>
<p><em>‚ÄúTechnical debt is financial debt ‚Äî just hidden in your firmware.‚Äù</em></p>
</blockquote>
<h2 id="build-right-and-reuse"><a class="header" href="#build-right-and-reuse">Build right and reuse</a></h2>
<p>Replacing legacy code with safer, testable, and reusable modules means lower maintenance costs over time.</p>
<pre class="mermaid">flowchart LR
  Legacy[&quot;Legacy Stack&quot;] --&gt; Duplication[&quot;üí• Code Duplication&quot;]
  Legacy --&gt; Debugging[&quot;üêõ Opaque Bugs&quot;]
  Legacy --&gt; Porting[&quot;üîß Costly Platform Bring-up&quot;]
  Legacy --&gt; Compliance[&quot;‚öñÔ∏è Expensive Security Reviews&quot;]
  Legacy --&gt; Waste[&quot;üóëÔ∏è Rewrite Instead of Reuse&quot;]
</pre>
<h3 id="hal-separation"><a class="header" href="#hal-separation">HAL separation</a></h3>
<p>The ability to reuse and recompose across product lines (via ODP libraries) reduces the need to "reinvent the wheel" for each board/platform, as Hardware Abstraction Layers can be cleanly isolated from the business logic of a component design, and easily expanded upon for new features.</p>
<h4 id="more-than-hal"><a class="header" href="#more-than-hal">More than HAL</a></h4>
<p>This component philosophy extends much further than replaceable HAL layers -- it permeates throughout the component and service structure patterns ODP exposes. This allows agile modularity, greater re-useability, and shorter development cycles.</p>
<pre class="mermaid">sequenceDiagram
  participant Dev as Developer
  participant Repo as Shared Component Repo
  participant DeviceA as Platform A
  participant DeviceB as Platform B

  Dev-&gt;&gt;Repo: Build &amp; Test Component
  DeviceA-&gt;&gt;Repo: Pull Component A
  DeviceB-&gt;&gt;Repo: Pull Component A
  Dev-&gt;&gt;DeviceA: Customize Config
  Dev-&gt;&gt;DeviceB: Customize Config
  Note right of Dev: One codebase, many targets
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alignment-with-industry-trends-and-standards"><a class="header" href="#alignment-with-industry-trends-and-standards">Alignment with Industry Trends and Standards</a></h1>
<p>ODP is forward-facing from its original concept, and embodied in its design.  Adoption of ODP positions you at the forefront of secure, future-facing firmware innovation.</p>
<blockquote>
<p><em>‚ÄúODP doesn‚Äôt rewrite the rules ‚Äî it implements them with confidence.‚Äù</em></p>
</blockquote>
<h3 id="perfectly-timed"><a class="header" href="#perfectly-timed">Perfectly Timed</a></h3>
<p>ODP taps into the growing ecosystem momentum around Rust and embedded standards. Rust adoption at Microsoft, Google, and the Linux kernel reflects a broader industry shift.</p>
<h3 id="open-source-and-collaborative"><a class="header" href="#open-source-and-collaborative">Open Source and Collaborative</a></h3>
<p>ODP Encourages upstream contributions and compliance with modern firmware interfaces (UEFI, ACPI, DICE).</p>
<p>An open collaboration model invites cross-vendor reuse and innovation while building upon existing standards known to the industry.</p>
<pre class="mermaid">graph TD
  A1[UEFI Spec] --&gt; B1[DXE Core]
  A2[ACPI] --&gt; B2[Runtime Services]
  A3[DICE] --&gt; B3[Secure Boot]
  A4[SPDM] --&gt; B3
  A5[DMTF] --&gt; B4[Mgmt Layer]

  B1 --&gt; C[ODP Framework]
  B2 --&gt; C
  B3 --&gt; C
  B4 --&gt; C
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Welcome! If you're new to the Open Device Partnership, this is the right place to begin.</p>
<p>If you're also new to the world of Embedded Controllers and the software that drives them, don't worry‚Äîyou're still in the right place.</p>
<div class="table-wrapper"><table><thead><tr><th>¬†</th><th>¬†</th></tr></thead><tbody>
<tr><td><img src="intro/./media/odp.png" alt="ODP Logo" /></td><td>The Open Device Partnership introduces concepts that are game-changing when it comes to enabling <strong>reuse</strong> and <strong>interchangeability</strong> of Embedded Controller components‚Äîespecially those found in modern laptops. Just as importantly, it brings a <em>revolutionary focus on security and code safety from the ground up</em>.</td></tr>
</tbody></table>
</div>
<p>¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†<img src="intro/./media/rust_logo.png" alt="ODP Logo" /></p>
<p>To support this, ODP is designed to use <strong>Rust</strong> as the implementation language.</p>
<p>If you're coming from a C or assembly background, you may feel some initial resistance to learning a new language and unfamiliar patterns. That‚Äôs understandable.</p>
<p>But let‚Äôs face it: while it's <em>certainly possible</em> to write memory-safe and secure code in C, it's also very easy to make mistakes. With Rust, you'd have to work pretty hard to write unsafe code that even compiles.</p>
<p>As new standards‚Äîand potentially even government regulations‚Äîbegin to push for memory-safe languages in critical systems, the Open Device Partnership aims to be ahead of the curve by bringing that future into the present.</p>
<p>Let's start by familiarizing ourselves with Rust (if you are not already),
then we will get a high-level understanding of ODP Concepts in the <a href="intro/./Concepts.html">Concepts</a> section, which explains how the various pieces fit together.</p>
<p>One you've familiarized yourself with the fundamentals of Rust and the concepts and scope of ODP, you are ready to explore the ODP tracks and the repositories that support each track or to dive deep into practical examples in building your own firmware components that you can later use to build your own laptop.</p>
<p>Continue on to learn the concepts, or jump ahead to choose which <a href="intro/../tracks.html">ODP track</a> you will follow next.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>The core firmware of a modern computing device is much more sophisticated than it was a couple of decades ago.
What started out on early computers as the Basic Input-Output System (BIOS) firmware that allowed keyboard input, clock support, and maybe serial terminal output designed to give the most rudimentary of control to a system before it has the opportunity to load the operating system, as well as the initial bootstrap loader to bring that onboard, has grown into an orchestration of individual microcontroller-driven subsystems that manage a variety of input devices, cryptography subsystems,
basic networking, power management, and even proprietary AI models.</p>
<p>Beyond handling the boot-time tasks, some of this lower-level firmware is meant to run autonomously in the background to monitor and adjust to operating conditions.  For example, a thermal control subsystem will take measures to cool the computer if the CPU temperature exceeds optimal levels, or a battery charging subsystem must correctly detect when the power cord has been plugged in or removed and execute the steps necessary to charge the system.  Such tasks are generally controlled by one or more Embedded Controllers, oftentimes found as a single System-on-Chip (SOC) construction.</p>
<p>Embedded Controllers are the unsung heroes of the modern laptop, quietly handling power management, thermal control,
battery charging, lid sensors, keyboard scan matrices, and sometimes even security functions.
There's a surprising amount of complexity tucked away in that little chip.</p>
<p>The drivers and handlers responsible for managing these subsystems must be secure, reliable, and easy to adopt with confidence.
This calls for a standardized, community-moderated approach‚Äîone that still leaves room for innovation and platform-specific
differentiation.</p>
<p>There are many proven standards that define and govern the development of this firmware.
For example, <strong>UEFI</strong> (<em>Unified Extensible Firmware Interface</em>) defines a standard for boot-level firmware in a series of layers, and <strong>DICE</strong> (Device Identity Composition Engine) defines a standard for cryptographic verification of firmware components for a security layer.</p>
<p>Hardware components issue events or respond to signals transmitted over data buses such as eSPI,UART, I2C/I3C. These signals
are monitored or driven by firmware, forming the basis for orchestrating and governing hardware behavior</p>
<p>Historically, much of this firmware has been vendor-supplied and tightly coupled to specific EC or boot hardware. It's often written in C or even assembly, and may be vulnerable to memory-unsafe operations or unintended behavior introduced by seemingly harmless changes.</p>
<p>The Open Device Partnership doesn't replace the former standards, but it defines a pattern for implementing this architecture in Rust.</p>
<p>As computing devices grow more complex and user data becomes increasingly sensitive, the need for provable safety
and security becomes critical.</p>
<p>Rust offers a compelling alternative. As a systems programming language with memory safety at its core, Rust enables secure,
low-level code without the tradeoffs typically associated with manual memory management.
It‚Äôs a natural fit for Embedded Controller development‚Äîtoday and into the future.</p>
<p>Abstraction and normalization are key goals. OEMs often integrate components from multiple vendors and must adapt quickly
when supply chains change. Rewriting integration logic for each vendor‚Äôs firmware is costly and error-prone.</p>
<p>By adopting ODP‚Äôs patterns, only the HAL layer typically needs to be updated when switching hardware components.
The higher-level logic‚Äîwhat the system does with the component‚Äîremains unchanged</p>
<p>Instead, if the ODP patterns have been adopted, all that really needs to change is the HAL mapping layers that describe how the hardware action and data signals are defined
and the higher-level business logic of handling that component can remain the same.</p>
<p>ODP is independent of any runtime or RTOS dependency.  Asynchronous support is provided by packages such as
the <a href="https://embassy.dev/">Embassy</a> framework for embedded systems.
Embassy provides key building blocks like Hardware Abstraction Layers (HALs), consistent timing models, and support for both asynchronous and blocking execution modes.</p>
<h3 id="so-how-does-this-work"><a class="header" href="#so-how-does-this-work">So how does this work?</a></h3>
<p>A Rust crate defines the component behavior by implementing hardware pin traits provided by the target microcontroller's HAL
(possibly via Embassy or a compatible interface). These traits are optionally normalized to <a href="https://en.wikipedia.org/wiki/ACPI">ACPI</a> (Advanced Configuration and
Power Interface) and ASL (ACPI Source Language) standards to align with common host-side expectations.</p>
<p>From there, the system moves into a familiar abstraction pattern. The HAL exposes actions on those pins
(such as read() or write()), and the service logic builds higher-level operations (like read_temperature() or set_fan_speed(x))
using those primitives.</p>
<pre class="mermaid">flowchart LR
Controller(Controller) --&gt; PinTrait(Pin Traits) --&gt; ASL(ASL) --&gt; HAL(HAL interface) --&gt; Fun(Functional Interface) --&gt; Code(Code action)
style Controller fill:#8C8
style PinTrait fill:#8C8
</pre>
<p>In the case of a controller being switched out, assuming both controllers perform the same basic
functionality (e.g. read temperature, set fan speed) only the pin traits specific to the controller
likely need to be changed to implement with similar behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-quick-look-at-rust"><a class="header" href="#a-quick-look-at-rust">A quick look at Rust</a></h1>
<p>If you are new to Rust, the venerable "Rust Book" is probably your best bet:
<a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Language</a></p>
<p>and a great sandbox to play in while learning can be found at <a href="https://play.rust-lang.org/">The Rust Playground</a></p>
<h3 id="but-before--you-run-off-to-do-that"><a class="header" href="#but-before--you-run-off-to-do-that">But before  you run off to do that...</a></h3>
<p>Let's look a little at what Rust has to offer first.</p>
<p><em><strong>The basics are very important to learn because Rust builds on itself and the advanced features are made possible by
leveraging the advantages of the basic ones.  Most of these have to do with the type and memory safety models that are fundamental to the Rust proposition.</strong></em></p>
<p>There are several parts to the rust toolchain that you should be aware of to start.</p>
<h3 id="cargo"><a class="header" href="#cargo">cargo</a></h3>
<p>Cargo is an all-around utility player for the rust environment.  It is many things:</p>
<ul>
<li>a build manager</li>
<li>a package manager</li>
<li>a linter / static analyzer</li>
<li>a documentation engine</li>
<li>a test runner</li>
<li>an extensible system driven by installed modules</li>
</ul>
<h3 id="rustup"><a class="header" href="#rustup">rustup</a></h3>
<p>While Cargo is your go-to player for building with a toolchain, <code>rustup</code> is used to setup and modify the toolchain for different needs.</p>
<p>Among its other uses, you may want to familiarize yourself with <code>rustup doc</code> which will open a locally-sourced web book for Rust documentation that can be used offline.</p>
<h3 id="rustc"><a class="header" href="#rustc">rustc</a></h3>
<p>Rust is a highly optimized compiled language. It's compiler is called <code>rustc</code>.</p>
<p>Typically <code>rustc</code> is not invoked directly; it is usually invoked with <code>cargo build</code></p>
<p>The compiler is thorough and strict by design.  Clean code is required on your part. Unused variables or mis-assigned variable types will result in compile errors.</p>
<ul>
<li>The compiler controls and understands memory allocation and deallocation</li>
<li>It tracks borrows/references (borrow checking)</li>
<li>Expands macros</li>
</ul>
<p>Although some might accuse the Rust compiler of being deliberately unforgiving and opinionated, it is not heartless.  It will tell you when you've done something wrong, and it will ask for additional information if it can't figure it out on its own (type, lifetime of borrowed values, etc)</p>
<h4 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h4>
<pre><code>- Like many languages, Rust is primarily an expression-based language, where an expression produces a result or an effect.
- Multiple expression types:
    - Literal
    - Path
    - Block
    - Operator
    - Struct
    - Tuple
    - Method
    - Closure
    - etc
- Expressions may be nested and obey an evaluation ordering

```
let y = 5;
let y = { let x = 5; x + 6; };
```
</code></pre>
<h4 id="variable-binding-and-ownership"><a class="header" href="#variable-binding-and-ownership">Variable binding and ownership</a></h4>
<p>In other languages, a "let" statement specifies an assignment.
In Rust, a "let" statement creates a variable binding. At first glance, this may seem the same, but there are important differences. A variable binding includes:</p>
<ul>
<li>Name of the binding</li>
<li>Whether or not the value is mutable (default is false)</li>
<li>The type of the value (based on type annotations, inferred by the compiler
or default associated with literal expression)‚Äã</li>
<li>A value or backing resource (memory allocated on stack or heap)‚Äã</li>
<li>Whether or not this binding "owns" the value.</li>
</ul>
<h4 id="binding-examples-primitive-types"><a class="header" href="#binding-examples-primitive-types">Binding examples (Primitive types)</a></h4>
<pre><code>fn main() {‚Äã
   // name: x, mutable: false, type: i32, value: 5 (stack), owner: true‚Äã
   let _x = 5;‚Äã
‚Äã
   // same result except with explicit type annotation of i32‚Äã
   let _x: i32 = 5; ‚Äã
‚Äã
   // now with unsigned integer‚Äã
   let _x: u32 = 5; ‚Äã
‚Äã
   //now mutable‚Äã
   let mut _x: u32 = 5; ‚Äã

   // creates 2 immutable variable bindings for x and y ‚Äã
   // using a tuple expression with integer literal expressions 1 and 2‚Äã
   let (_x, _y) = (1, 2); ‚Äã
‚Äã
   // now x &amp; y are mutable‚Äã
   let (mut _x, mut _y) = (1, 2); ‚Äã
}
</code></pre>
<h4 id="copy-semantics-and-move-semantics"><a class="header" href="#copy-semantics-and-move-semantics">Copy semantics and Move semantics</a></h4>
<p>Consider this code:</p>
<pre><code>fn copy_semantics() {‚Äã
    let x = 5;‚Äã
    let y = x;‚Äã
}
</code></pre>
<p>This binds the value 5 to 'x' and then binds the value of 'x' to 'y'.  So, in the end x == 5 and y == 5.
No surprise there, but it should be understood that this is true because the primitive types for this implement the "Copy" trait that allows this.</p>
<p>Now let's look at another bit of code</p>
<pre><code>fn move_semantics() {
    // String does not implement the copy trait... ‚Äã

    let message = String::from("hello Rustaceans");
    let mut _hello = message;


    println!("{}", message);
}
</code></pre>
<p>If your run this code in the Rust Playground you will see the following output:</p>
<pre><code>Exited with status 101

error[E0382]: borrow of moved value: `message`
 --&gt; src/main.rs:8:20
  |
4 |     let message = String::from("hello Rustaceans");
  |         ------- move occurs because `message` has type `String`, which does not implement the `Copy` trait
5 |     let mut _hello = message;
  |                      ------- value moved here
...
8 |     println!("{}", message);
  |                    ^^^^^^^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider cloning the value if the performance cost is acceptable
  |
5 |     let mut _hello = message.clone();
  |                             ++++++++

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground` (bin "playground") due to 1 previous error

</code></pre>
<p>Types that implement the Copy trait (like integers and booleans) are duplicated on assignment. For other types, ownership is transferred.</p>
<p>Simple primitive types implement the Copy trait ‚Äî a marker trait indicating that values of a type can be duplicated with a simple bitwise copy</p>
<p>So you can see, the rust compiler, despite being picky, is very helpful.  It explains exactly what is happening here:</p>
<p>String does not implement the "Copy" trait, so an assignent 'moves' the value from 'message' to '_hello' so that when we try to
reference 'message' later in the print macro, we see the value is no longer there.  It even suggests some possible alternatives we might try.</p>
<h4 id="allocating-deallocating-and-scope"><a class="header" href="#allocating-deallocating-and-scope">Allocating, Deallocating, and scope</a></h4>
<ul>
<li>Memory is allocated when the result of an expression is assigned to a variable binding</li>
<li>Memory is deallocated when the variable binding that is the owner of the value goes out of scope</li>
<li>For non-primitive types (on the heap), you may call the <code>drop</code> function (trait) for resources that <em>you</em> control the lifetime scope for.</li>
<li>The drop trait should be custom implemented for resource types that have specific destructor needs.</li>
<li>Rust calls drop() automatically when a value goes out of scope, but you can override it via the Drop trait if your type needs custom cleanup logic (e.g. closing a file or freeing a resource).</li>
</ul>
<h4 id="rust-ownership-rules"><a class="header" href="#rust-ownership-rules">Rust ownership rules</a></h4>
<ul>
<li>Each value in rust has an owner (from a variable binding)</li>
<li>There can only be <strong>one</strong> owner at a time</li>
<li>When an owner goes out of scope, the value will be dropped.</li>
</ul>
<h4 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h4>
<p>Borrowing is the term used for a copy-by-reference. For example:</p>
<pre><code>fn borrowing() {‚Äã
    let mut x: String = String::from("asdf");‚Äã
‚Äã
    // Borrow is a verb‚Ä¶ Borrowing a value from the owner‚Äã
    // The result of a borrow is a reference; below an immutable reference‚Äã
    let _y: &amp;String = &amp;x; ‚Äã
    // name: y, mutable: false, type: String, value: -&gt; x, owner: false; an immutable reference‚Äã

    // Mutable borrow... the variable binding you are borrowing must be mutable‚Äã
    let _z: &amp;mut String = &amp;mut x;‚Äã
    // name: z, mutable: true, type: String, value: -&gt; x, owner: false; a mutable reference‚Äã

    // You can borrow values stored on the heap or on the stack‚Äã
    let n: i32 = 5;‚Äã
    let _z: &amp;i32 = &amp;n; //is valid‚Ä¶ same rules apply as for complex types‚Äã
}
</code></pre>
<h5 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h5>
<ul>
<li>Only 1 <em>mutable</em> borrow/reference at a time</li>
<li>As many <em>immutable</em> borrows as you like</li>
<li>If you have 1 or more immutable borrows and 1 mutable borrow, attempting to use any of the immutable borrows <em>after the value
has changed</em> will result in a compile error</li>
</ul>
<p>Rust uses lifetimes to ensure that borrowed references don‚Äôt outlive the data they point to. While often inferred by the compiler, they become important in more advanced usage.</p>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<p>Rust functions look much like function definitions from other languages.  Here's some examples:</p>
<pre><code>// A function that takes no parameters returns no useable result (unit type)‚Äã
fn do_something() -&gt; () {}‚Äã

// equivalent to above‚Ä¶ more typical‚Äã
fn do_something() {} ‚Äã

// this returns an i32 with value 3‚Ä¶ ‚Äã
// remember return statement is not needed‚Ä¶ just leave off the semi-colon‚Äã
fn get_three()-&gt; i32 {‚Äã
    3‚Äã
}‚Äã
</code></pre>
<ul>
<li>The function starts with <code>fn</code>.</li>
<li>Rust style conventions prefer "snake case" (underscore separated lowercase words) style for the function name.</li>
<li>Functions take parameters which are listed within parenthesis following the function name.</li>
<li>Functions that return a type denote their return type with -&gt; <code>&lt;type&gt;</code> after the parameter list.</li>
<li>The function body is within { } brackets.</li>
<li>The result of the last expression executed becomes the return value if no 'return' keyword is encountered.</li>
<li>The return type () is called the unit type ‚Äî it‚Äôs like void in C/C++, representing ‚Äòno meaningful value‚Äô.</li>
</ul>
<h4 id="function-parameters"><a class="header" href="#function-parameters">Function parameters</a></h4>
<ul>
<li>parameters must have a type annotation</li>
<li>all parameters will be copied, moved, or borrowed from their origins and delivered into the scope of the function (the parameter definition should indicate if they expect a borrow/reference, or an actual value).</li>
</ul>
<pre><code>fn do_some_things(x: i32, y: String, z: &amp;String, a: &amp;mut String) {}‚Äã
</code></pre>
<ul>
<li>x will be a copied value (from i32 primitive)</li>
<li>y will be a moved value (from the string)</li>
<li>z will be an immutable borrowed reference</li>
<li>a will be a mutable borrowed reference</li>
</ul>
<h4 id="tuples"><a class="header" href="#tuples">Tuples</a></h4>
<ul>
<li>Tuples are primitive types that contain a finite sequence ‚Äã</li>
<li>Tuples are heterogenous, the sequence does not need to be of the same type‚Äã</li>
<li>Tuples are a convenient way of returning multiple results from a function‚Äã</li>
<li>Tuples are often used with enums to associate one or more values with an enum variant‚Äã</li>
</ul>
<p><em>example:</em></p>
<pre><code>let x: (&amp;str,i32, char) = ("hello", 42, 'c')
</code></pre>
<p>In the example we define a tuple consisting of three element types: A string reference, a 32-bit integer, and a character. Then we assign literal values for this tuple definition to the binding variable 'x'.</p>
<h4 id="struct"><a class="header" href="#struct">Struct</a></h4>
<p>A Struct (structure) in Rust is much like a structure definition in several other languages.</p>
<p>For example:</p>
<pre><code>struct Example
{
    foo: String,
    bar: i32,
    baz: bool
}
</code></pre>
<p>There is also the concept of a 'tuple struct' which is a convenient way to give a name to a tuple that can be treated like a structure, such as the Tuple example we visited above:</p>
<pre><code>struct MyTupleStruct(&amp;String, i32, char)
</code></pre>
<p>Remember, tuples can have any number of elements in the sequence.</p>
<h4 id="enum-option-and-result"><a class="header" href="#enum-option-and-result">Enum, Option, and Result</a></h4>
<p>An enum is a way of saying that a value is one from a set of possible values.  Most languages have some form of enum, but Rust
has an particularly robust level of support around this construct.</p>
<p>Consider this example from the "Rust Book":</p>
<pre><code>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
<p>One can imagine "Message" being used to direct some operation to do one of the four listed things.  But note that each of these "directives" has annotations to describe the associated data type that accompany it.  "Quit" needs no parameters, "Move" comes with structured data for x and y, "Write" is passed a String, and "ChangeColor" gets a Tuple.</p>
<h5 id="option"><a class="header" href="#option">Option</a></h5>
<p>Option is a way to handle Null values in a way a little different from some other languages.  An Option is basically a way to say that something has a value or it has no value (Some or None). Option is an enum that is part of the standard Rust library.
Since <code>Option&lt;T&gt;</code> is not the same type as <code>T</code>, the compiler will not allow an evaluation of a possible Null value.
You can also use the <code>is_some()</code> and <code>is_none()</code> functions of an option to determine if it has a value.</p>
<h5 id="result"><a class="header" href="#result">Result</a></h5>
<p>Where Option is the state of "Some or None" Result is the state of "Ok or Err".</p>
<p><code>Option&lt;T&gt;</code> is used when a value may or may not be present. <code>Result&lt;T, E&gt;</code> is used when a function may succeed (Ok) or fail (Err). Both are enums and must be handled explicitly.</p>
<p>Any operation or function that is executed
may potentially fail, and Rust does not employ any sort of try/catch or "on_error" redirections found in other languages.
Error conditions are a fact of life and as such are part of the result of doing something. Getting used to evaluating the return value of a function operation may seem annoying at first, but it is actually pretty liberating because it generally simplifies error handling.</p>
<p>Let's consider this function:</p>
<pre><code>fn do_something() -&gt; Result&lt;String, std::io::Error&gt; {
    let x:String = "hooray".to_string();
    return Ok(x);
}
</code></pre>
<p>We can see this function returns the "Ok" result (we don't create an error case in this example).
Of course, unless we explicitly documented it, the caller has no idea there will not be an error, so it handles it like so:</p>
<pre><code>fn main() {
    
    let x = do_something();
    let y = match x {
        Ok(s) =&gt; s,
        Err(_e) =&gt; panic!("Oh noes!")
    };
    println!("{}", y);
}
</code></pre>
<p>The error case never occurs, but if it did, it would probably be inadvisable to simply call panic! as a result. Of course, sometimes
there are no good choices, but especially in firmware driver code, casually throwing panic! exceptions is not a good idea.</p>
<p>On that note, you will encounter a lot of sample code from the web and elsewhere that simply advise calling <code>.unwrap()</code> on an option or a result. While often used in examples or quick scripts, relying on .unwrap() in production firmware is discouraged. Define errors explicitly and handle them deliberately.</p>
<h4 id="functions-and-methods-for-user-defined-types"><a class="header" href="#functions-and-methods-for-user-defined-types">Functions and methods for user defined types</a></h4>
<p>User define types include enums, structs, and  union</p>
<pre><code>impl Student {‚Äã

    fn new_with_username_email(username: String, email: String) -&gt; Self {‚Äã
        Student {‚Äã
            active_enrollment: true,‚Äã
            username,‚Äã
            email‚Äã
        }‚Äã
    }‚Äã
    //method ‚Äì with methods you add special parameter‚Ä¶  ‚Äã
    //a variable binding to ‚Äúself‚Äù.  This binding can be mutable or //immutable‚Äã\
    fn get_username(&amp;self) -&gt; String { self.username }‚Äã
    fn get_student(email: &amp;str) -&gt; Student { //query db, return student }‚Äã
}
</code></pre>
<p><code>impl</code> blocks let you associate methods with a type. Methods that take &amp;self or &amp;mut self operate on an instance, while functions without self are typically constructors or associated functions.</p>
<h4 id="common-construction--initialization-patterns"><a class="header" href="#common-construction--initialization-patterns">Common construction / initialization patterns</a></h4>
<ul>
<li>"new" function</li>
<li>Default trait</li>
</ul>
<pre><code>impl Default for Student {‚Äã
    fn default() -&gt; Self {‚Äã
        Student {‚Äã
            active_enrollment: true, ‚Äã
            username: String::default(), ‚Äã
            email: String::new()‚Äã
        }‚Äã
    }‚Äã
}
</code></pre>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>This introduction to key concepts of Rust just touches the surface of the Rust language itself, not to mention the extended ecosystem and community that surrounds it.</p>
<p>The goal of this introduction has been to introduce the <em>fundamental safety and ownership guarantees</em> Rust builds into its core design to alleviate some of the shortcomings that other languages often suffer from.  These fundamentals are keystones to understanding the logic behind the rest of the language.</p>
<p><strong>Don't stop here</strong>:</p>
<ul>
<li>visit <a href="intro/concepts/rust-lang.org">Learn Rust - Rust Programming Language</a> and learn the language!</li>
<li>check out <a href="https://crates.io/">crates.io</a> for a taste of the many thousand 3rd-party packages (crates) that you can import for your project</li>
<li>Use the <a href="https://play.rust-lang.org">playground</a> to experiment as you learn.</li>
<li>for fun extended learning, visit <a href="https://github.com/rust-lang/rustlings">Rustlings</a>, where you get hands-on exercises to break in your muscle memory for writing solid Rust code.</li>
<li>Since you are here, you undoubtedly have an interest in using Rust to write firmware, so you should visit <a href="https://docs.rust-embedded.org/book/">Rust Embedded Book</a> for a relevant introduction to using Rust in an Embedded Development Environment.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina"><a class="header" href="#patina">Patina</a></h1>
<h2 id="boot-firmware"><a class="header" href="#boot-firmware">(Boot Firmware)</a></h2>
<p><em><strong>Patina</strong></em> is the codename for ODP's Rust-based SDK and framework for UEFI-compliant boot firmware development.</p>
<p>It is based upon the venerable <strong>UEFI</strong> standard and doesn't seek to reinvent the process of this well-known
framework, as it necessarily re-implements these familiar patterns in Rust instead of C.</p>
<h3 id="a-review-of-uefi"><a class="header" href="#a-review-of-uefi">A review of UEFI</a></h3>
<p><strong>UEFI</strong> stands for <em>Unified Extensible Firmware Interface</em> and can be described as broken into a series of layers, as this diagram shows:</p>
<p><img src="intro/concepts/./images/PI_Boot_Phases.jpg" alt="PI_Boot_phases" />
<em>(diagram source: TianoCore, , illustrating the PI Boot Flow from SEC to RT phase)</em></p>
<p>This boot-time firmware is executed by the platform main CPU on startup/reset and proceeds through the stages shown in the diagram.  As part of its initialization, it may communicate with the embedded system microcontrollers that are also under the control of ODP rust drivers to initiate and orchestrate them to a starting state.</p>
<p>While the majority of ODP development focuses on the <strong>DXE</strong> phase, Patina also supports implementation in the <strong>PEI</strong>, <strong>SEC</strong> and other phases.</p>
<p>Some aspects of UEFI, especially those that have already been deprecated, may not be supported under ODP.  These are legacy services, UI facilitators, and some Runtime Support components that either no longer serve a core purpose or can more effectively be implemented in other ways within ODP.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-evolution-of-uefi-into-patina-with-rust-and-odp"><a class="header" href="#the-evolution-of-uefi-into-patina-with-rust-and-odp">The Evolution of UEFI into Patina with Rust and ODP</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Firmware and UEFI firmware in particular has long been written in C. Firmware operates in a unique environment to other
system software. It is written to bootstrap a system often at the host CPU reset vector and as part of a chain of
trust established by a hardware rooted immutable root of trust. Modern PC firmware is extraordinarily complex with
little room for error.</p>
<h3 id="firmware-evolution"><a class="header" href="#firmware-evolution">Firmware Evolution</a></h3>
<p>From a functional perspective, firmware must initialize the operating environment of a device. To do so involves
integrating vendor code for dedicated microcontrollers, security engines, individual peripherals, SOC initialization,
and so on. Individual firmware blobs may be located on a number of non-volatile media with very limited capacity. The
firmware must perform its functional tasks successfully or risk difficult to diagnose errors in higher levels of the
software stack that may impede overall device usability and debuggability.</p>
<p>These properties have led to slow but incremental expansion of host firmware advancements over time.</p>
<p><img src="intro/concepts/./images/uefi_evolution.png" alt="Host FW Evolution" /></p>
<h3 id="importance-of-security-in-firmware"><a class="header" href="#importance-of-security-in-firmware">Importance of Security in Firmware</a></h3>
<p>From a security perspective, firmware is an important component in the overall system Trusted Computing Base (TCB).
Fundamental security features taken for granted in later system software such as kernels and hypervisors are often
based on secure establishment in a lower layer of firmware. At the root is a concept of "trust".</p>
<p>While operating systems are attractive targets due to their ubiquity across devices and scale, attackers are
are increasingly viewing firmware as an attack surface in response to increasingly effective security measures
being applied in modern operating systems. While significant research has been devoted across the entire boot process,
UEFI firmware on the host CPU presents a unique opportunity to gain more visibility into early code execution details
and intercept the boot process before essential activities take place such as application of important security register
locks, cache/memory/DMA protections, isolated memory regions, etc. The result is code executed in this timeframe must
carry forward proper verification and measurement of future code while also ensuring it does not introduce a
vulnerability in its own execution.</p>
<h3 id="performance-reliability-in-firmware"><a class="header" href="#performance-reliability-in-firmware">Performance Reliability in Firmware</a></h3>
<p>From a performance perspective, firmware code is often expected to execute exceedingly fast. The ultimate goal is for
an end user to not even be aware such code is present. In a consumer device scenario, a user expects to press a power
button and immediately receive confirmation their system is working properly. In a server scenario, fleet uptime is
paramount. Poorly written firmware can lead to long boot times that impact virtual machine responsiveness and workload
scaling or, even worse, Denial of Service if the system fails to boot entirely. In an embedded scenario, government
regulations may require firmware to execute fast enough to show a backup camera within a fixed amount of time.</p>
<p>All of this is to illustrate that firmware must perform important work in a diverse set of hardware states with code
that is as small as possible and do so quickly and securely. In order to transition implementation spanning millions of
lines of code written in a language developed over 50 years ago requires a unique and compelling alternative.</p>
<h2 id="rust-and-firmware"><a class="header" href="#rust-and-firmware">Rust and Firmware</a></h2>
<p>For these reasons, modern PC firmware necessitates a powerful language that can support low-level programming with
maximum performance, reliability, and safety. While C has provided the flexibility needed to implement relatively
efficient firmware code, it has failed to prevent recurring problems around memory safety.</p>
<h3 id="stringent-safety"><a class="header" href="#stringent-safety">Stringent Safety</a></h3>
<p>Common pitfalls in C such as null pointer dereferences, buffer and stack overflows, and pointer mismanagement continue
to be at the root of high impact firmware vulnerabilities. These issues are especially impactful if they compromise
the system TCB. Rust is compelling for UEFI firmware development because it is designed around strong memory safety
without the usual overhead of a garbage collector. In addition, it enforces stringent type safety and concurrency rules
that prevent the types of issues that often lead to subtle bugs in low-level software development.</p>
<p>Languages aside, UEFI firmware has greatly fallen behind other system software in its adoption of basic memory
vulnerability mitigation techniques. For example, data execution protection, heap and stack guards, stack cookies,
and null pointer dereference detection is not present in the vast majority of UEFI firmware today. More advanced
(but long time) techniques such as Address Space Layout Randomization (ASLR), forward-edge control flow integrity
technologies such as x86 Control Flow Enforcement (CET) Indirect Branch Tracking (IBT) or Arm Branch Target
Identification (BTI) instructions, structured exception handling, and similar technologies are completely absent in
most UEFI firmware today. This of course exacerbates errors commonly made as a result of poor language safety.</p>
<p>Given firmware code also runs in contexts with high privilege level such as System Management Mode (SMM) in x86,
implementation errors can be elevated by attackers to gain further control over the system and subvert other
protections.</p>
<h3 id="developer-productivity"><a class="header" href="#developer-productivity">Developer Productivity</a></h3>
<p>The Rust ecosystem brings more than just safety. As a modern language firmware development can now participate
in concepts and communities typically closed to firmware developers. For example:</p>
<ul>
<li>
<p>Higher level multi-paradigm programming concepts such as those borrowed from functional programming in addition to
productive polymorphism features such as generics and traits.</p>
</li>
<li>
<p>Safety guarantees that prevent errors and reduce the need for a myriad of static analysis tools with flexibility to
still work around restrictions when needed in an organized and well understood way (unsafe code).</p>
</li>
</ul>
<h3 id="modern-tooling"><a class="header" href="#modern-tooling">Modern Tooling</a></h3>
<p>Rust includes a modern toolchain that is well integrated with the language and ecosystem. This standardizes tooling
fragmented across vendors today and lends more time to firmware development. Examples of tools and community support:</p>
<ul>
<li>
<p>An official package management system with useful tools such as first-class formatters and linters that reduce
project-specific implementations and focus discussion on functional code changes.</p>
</li>
<li>
<p>High quality reusable bundles of code in the form of crates that increase development velocity and engagement with
other domain experts.</p>
</li>
<li>
<p>Useful compilation messages and excellent documentation that can assist during code development.</p>
</li>
</ul>
<p>Rust's interoperability with C code is also useful. This enables a phased adoption pathway where codebases can start
incorporating Rust while still relying upon its extensive pre-existing code. At the same time, Rust has been conscious
of low-level needs and can precisely structure data for C compatibility.</p>
<h2 id="uefi-rust-in-odp"><a class="header" href="#uefi-rust-in-odp">UEFI Rust in ODP</a></h2>
<p>UEFI code in ODP plans to participate within the open Rust development community by:</p>
<ol>
<li>Engaging with the broader Rust community to learn best practices and share low-level system programming knowledge.</li>
<li>Leveraging and contributing back to popular crates and publishing new crates that may be useful to other projects.
<ul>
<li>A general design strategy is to solve common problems in a generic crate that can be shared and then integrate it
back into firmware.</li>
</ul>
</li>
<li>Collaborating with other firmware vendors and the UEFI Forum to share knowledge and best practices and
incorporate elements of memory safety languages like Rust into industry standard specifications where appropriate.
Some specifications have interfaces defined around concepts and practices common in unsafe lanuages that could
be improved for safety and reliability.</li>
</ol>
<p>Looking forward, we're continuing to expand the coverage of our firmware code written in Rust. We are excited to
continue learning more about Rust in collaboration with the community and our partners.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="odp-resources-for-uefi"><a class="header" href="#odp-resources-for-uefi">ODP Resources for UEFI</a></h3>
<p>For traditional UEFI development, an SDK called <strong>EDK II</strong> is often used to supply much of the common functionality.</p>
<p>However, the <strong>EDK II</strong> presumes the use of C, and ODP is seeking to replace this potentially insecure code base with Rust for future devices.</p>
<p>ODP features a subproject body of code that represents the elements one might traditionally find within the EDK II, but designed for  Rust.</p>
<p>The official documentation for the Patina track of ODP can be found here:</p>
<p><a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Official Patina Documentation</a></p>
<p>This document covers</p>
<ul>
<li>How to use materials from and contribute to the Open Device Partnership</li>
<li>Development tools you will need, including Rust and other supporting tools</li>
<li>Platform configuration and comparisons to EDK II (which may be familar to experienced UEFI developers)</li>
<li>Coding patterns and standards</li>
<li>Dependencies</li>
<li>Industry background and current state assessments</li>
</ul>
<h3 id="how-patina-compares-to-traditional-uefi-approaches"><a class="header" href="#how-patina-compares-to-traditional-uefi-approaches">How Patina compares to traditional UEFI approaches</a></h3>
<p>There are differences in the ODP approach here in a few areas.  For example, one significant departure is that in ODP there is no traditional SMM (System Management Mode).</p>
<p>SMM is a special-purpose operating mode provided by x86 CPUs (and compatible architectures) for executing highly privileged system-level code, independently of the operating system.</p>
<ul>
<li>
<p>It is triggered by a System Management Interrupt (SMI).</p>
</li>
<li>
<p>Code running in SMM has full control over the system, including memory, I/O, and other hardware.</p>
</li>
<li>
<p>It is isolated: the OS (and even hypervisors) cannot access or interfere with SMM execution or memory (SMRAM).</p>
</li>
</ul>
<p>This may seem more than a little significant at first because SMM is used in key EDK II contexts, including:</p>
<ul>
<li>SmmCore</li>
<li>SmmDriver</li>
<li>SmmCommunication</li>
<li>SmmVariable</li>
</ul>
<p>But there is good reason for this omission:</p>
<p>Traditional SMM is not supported to prevent coupling between the DXE and MM environments. This exclusion extends to so-called 'combined' DXE modules also.
These patterns are error-prone, increase DXE module complexity, and elevate the risk of security vulnerabilities.</p>
<p>Standalone MM should be used instead. The combined drivers have not gained traction in actual implementations due to their lack of compatibility for most practical purposes and further increase the likelihood of coupling between core environments and user error when authoring those modules. The Rust DXE Core focuses on modern use cases and simplification of the overall DXE environment.</p>
<h3 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h3>
<p>In upcoming sections we'll explore how Patina components interact within the DXE Core, how to define UEFI services in Rust, and how to develop real-world DXE drivers using ODP tools. First, we are going to discuss the role of ODP in an Embedded Controller context.  If you are not interested in the EC side of things, you may want to jump directly to the Patina material from the <a href="intro/concepts/../../tracks.html">ODP tracks</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller"><a class="header" href="#embedded-controller">Embedded Controller</a></h1>
<p><img src="intro/concepts/./images/simplified_layers.png" alt="ODP Architecture" /></p>
<p>An Embedded Controller is typically a single SOC (System on Chip) design capable of managing a number of low-level tasks.</p>
<p>These individual tasked components of the SOC are represented by the gold boxes in the diagram. The ODP Support for Embedded Controller development is represented in the diagram in the green boxes, whereas third party support libraries are depicted in blue.</p>
<h2 id="component-modularity"><a class="header" href="#component-modularity">Component modularity</a></h2>
<p>A Component can be thought of as a stack of functionality defined by traits (A trait in Rust is analogous to an interface in other common languages).
For the functionality defined by the trait definition to interact with the hardware, there must be a HAL (hardware abstraction layer) defined that implements key actions required by the hardware to conduct these tasks.  These HAL actions are then controlled by the functional interface of the component definition.<br />
The component definition is part of a <em>Subsystem</em> of functionality that belongs to a <em>Service</em>.
For example, a Power Policy Service may host several related Subsystems for Battery, Charger, etc.  Each of these Subsystems have Controllers to interact with their corresponding components.  These Controllers are commanded by the Service their Subsystem belongs to, so for example, the power policy service may interrogate the current charge state of the battery. It does so by interrogating the Subsystem Controller which in turn relies upon the interface defined by the component Trait, which finally calls upon the hardware HAL to retrieve the necessary data from the hardware.  This chain of stacked concerns forms a common pattern that allows for agile modularity and flexible portability of components between target contexts.</p>
<pre class="mermaid">flowchart TD
    A[e.g. Power Policy Service&lt;br&gt;&lt;i&gt;Service initiates query&lt;/i&gt;]
    B[Subsystem Controller&lt;br&gt;&lt;i&gt;Orchestrates component behavior&lt;/i&gt;]
    C[Component Trait Interface&lt;br&gt;&lt;i&gt;Defines the functional contract&lt;/i&gt;]
    D[HAL Implementation&lt;br&gt;&lt;i&gt;Implements trait using hardware-specific logic&lt;/i&gt;]
    E[EC / Hardware Access&lt;br&gt;&lt;i&gt;Performs actual I/O operations&lt;/i&gt;]

    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E

    subgraph Service Layer
        A
    end

    subgraph Subsystem Layer
        B
    end

    subgraph Component Layer
        C
        D
    end

    subgraph Hardware Layer
        E
    end
</pre>
<h2 id="secure-vs-non-secure"><a class="header" href="#secure-vs-non-secure">Secure vs Non-Secure</a></h2>
<p>Communication between Subsystems may be considered to be either a "Secure" channel for data communication or a "Non-Secure" channel. An implementation may use more than one transport for different controller and controller service needs.</p>
<p>Data communication with the embedded controller can be considered an <em>owned interface</em> because it is implemented within the EC architecture itself.  It may also tie into an external communication bus such as SPI or I2C for data exhanges between other MCUs or the host, but for purposes of communicating between its own subsystems, it is an internally implemented construct.</p>
<p>A "Secure" transport is one that can validate and trust the data from the channel, using cryptographic signatures and hypervisor isolation to insure the integrity of the data exchanged between subsystems.
Not all such channels must necessarily be secure, and indeed in some cases depending upon the components used it may not even be possible to secure a channel.  The ODP approach is agnostic to these decisions, and can support either or both patterns of
implementation.</p>
<p>Depending upon the hardware architecture and available supporting features, a secure channel may incorporate strong isolation between individual component subsystems through memory access and paging mechanisms and/or hypervisor control.</p>
<p>Two similar sounding, but different models become known here.  One is SMM, or "System Management Mode". SMM is a high-privilege CPU mode for x86 microcontrollers that EC services can utilize to gain access. To facilitate this, the SMM itself must be secured. This is done as part of the boot time validation and attestation of SMM access policies.  With this in place, EC Services may be accessed by employing a SMM interrupt.</p>
<p>For A deeper dive into what SMM is, see <a href="https://www.microsoft.com/en-us/security/blog/2020/11/12/system-management-mode-deep-dive-how-smm-isolation-hardens-the-platform/?msockid=1c8509b122806f6b2c281c61233a6e3e">How SMM isolation hardens the platform</a></p>
<p>Another term seen about will be "SMC", or "Secure Memory Control", which is a technology often found in ARM-based architectures. In this scheme, memory is divided into secure and non-secure areas that are mutally exclusive of each other,  as well as a narrow section known as "Non-Secure Callable" which is able to call into the "Secure" area from the "Non-Secure" side.</p>
<p>Secure Memory Control concepts are discussed in detail with this document:
<a href="https://developer.arm.com/documentation/100690/0201">TrustZone Technology for Armv8-M Architecture</a></p>
<p>SMM or SMC adoption has design ramifications for EC Services exchanges, but also affects the decisions made around boot firmware, and we'll see these terms again when we look at ODP Patina implementations.</p>
<h3 id="hypervisor-context-multiplexing"><a class="header" href="#hypervisor-context-multiplexing">Hypervisor context multiplexing</a></h3>
<p>Another component of a Secure EC design is the use of a hypervisor to constrain the scope of any given component service to a walled-off virtualization context. One such discussion of such use is detailed <a href="https://www.microsoft.com/en-us/security/blog/2018/06/05/virtualization-based-security-vbs-memory-enclaves-data-protection-through-isolation/?msockid=1c8509b122806f6b2c281c61233a6e3e">in this article</a></p>
<h3 id="the-open-device-partnership-defines"><a class="header" href="#the-open-device-partnership-defines">The Open Device Partnership defines:</a></h3>
<ul>
<li>An "owned interface" that communicates with the underlying hardware via the available data transport .</li>
<li>We can think of this transport as being a channel that is considered either "Secure" or "Non-Secure".</li>
<li>This interface supports business logic for operational abstractions and concrete implementations to manipulate or interrogate the connected hardware component.</li>
<li>The business logic code may rely upon other crates to perform its functions. There are several excellent crates available in the Rust community that may be leveraged, such as <a href="https://embassy.dev/">Embassy</a>.</li>
<li>Synchronous and asynchronous patterns are supported.</li>
<li>No runtime or RTOS dependencies.</li>
</ul>
<p>An implementation may look a little like this:</p>
<p><img src="intro/concepts/./images/odp_arch.png" alt="ODP Arch" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-services"><a class="header" href="#ec-services">EC Services</a></h1>
<p>Embedded controller services are available for the operating system to call for various higher-level purposes dictated by specification.
The Windows Operating system defines some of these standard services for its platform.</p>
<p>These service interfaces include those for:</p>
<ul>
<li>debug services</li>
<li>firmware management services</li>
<li>input management services</li>
<li>oem services</li>
<li>power services</li>
<li>time services</li>
</ul>
<p>Services may be available for operating systems other than Windows.</p>
<p>OEMs may wish to implement their own services as part of their product differentiation.</p>
<h3 id="ec-service-communication-protocols"><a class="header" href="#ec-service-communication-protocols">EC Service communication protocols</a></h3>
<p>With a communication channel protocol established between OS and EC, operating system agents and applications are able to monitor and operate peripheral controllers from application space.</p>
<p>This scope comes with some obvious security ramifications that must be recognized.</p>
<p>Implementations of ODP may be architected for both Secure and Non-Secure system firmware designs, as previously discussed.</p>
<p><img src="intro/concepts/./images/image1.png" alt="Secure Architecture" /></p>
<p>In the diagram above, the dark blue sections are those elements that are part of normal (non-secure) memory space and may be called
from a service interface directly.  As we can see on the Non-Secure side, the ACPI transport channel has access to the EC component implementations either directly or through the FF-A (Firmware Framework Memory Management Protocol).</p>
<h3 id="ff-a"><a class="header" href="#ff-a">FF-A</a></h3>
<p>The Firmware Framework Memory Management Protocol <a href="https://developer.arm.com/documentation/den0140/latest/">(Spec)</a>
describes the relationship of a hypervisor controlling a set of secure memory partitions with configurable access and ownership attributes and the protocol for exchanging information between these virtualized contexts.</p>
<p>FF-A is available for Arm devices only.  A common solution for x64 is still in development. For x64 implementations, use of SMM is employed to orchestrate hypervisor access using the [Hafnium] Rust product.</p>
<p>In a Non-Secure implementation <em>without</em> a hyperviser, the ACPI connected components can potentially change the state within any accessible memory space.  An implementation with a hypervisor cannot.  It may still be considered a "Non-Secure" implementation, however, as the ACPI data itself is unable to be verified for trust.</p>
<p>In a fully "Secure" implementation, controller code is validated at boot time to insure the trust of the data it provides. Additionally, for certain types of data, digital signing and/or encryption may be used on the data exchanged to provide an additional level of trust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-system-implementation"><a class="header" href="#sample-system-implementation">Sample System Implementation</a></h1>
<p>This is short sample implementing a thermal control service interface.
This sample assumes one thermal sensor and one thermal control device accessible via ACPI.
For an ARM implementation, FF-A and Hafnium is assumed.  For x86/x64, an eSPI transport is assumed and direct (Non-Secure) access is made from there.</p>
<h3 id="ffa-device-definition"><a class="header" href="#ffa-device-definition">FFA Device Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(\\_SB_.FFA0) {
  Name(_HID, "MSFT000C")
  OperationRegion(AFFH, FFixedHw, 4, 144)
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }

  // Other components check this to make sure FFA is available
  Method(AVAL, 0, Serialized) {
    Return(One)
  }

  // Register notification events from FFA
  Method(_RNY, 0, Serialized) {
    Return( Package() {
      Package(0x2) { // Events for Management Service
        ToUUID("330c1273-fde5-4757-9819-5b6539037502"),
        Buffer() {0x1,0x0} // Register event 0x1
      },
      Package(0x2) { // Events for Thermal service
        ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"),
        Buffer() {0x1,0x0,0x2,0x0,0x3,0x0} // Register events 0x1, 0x2, 0x3
      },
      Package(0x2) { // Events for input device
        ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),
        Buffer() {0x1,0x0} // Register event 0x1 for LID
      }
    } )
  }

  Method(_NFY, 2, Serialized) {
    // Arg0 == UUID
    // Arg1 == Notify ID
    // Management Service Events

    If(LEqual(ToUUID("330c1273-fde5-4757-9819-5b6539037502"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // Test Notification Event
          Notify(\\_SB.ECT0,0x20)
        }
      }
    }

    // Thermal service events
    If(LEqual(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // Temp crossed low threshold
          Notify(\\_SB.SKIN,0x80)
        }
        Case(2) { // Temp crossed high threshold
          Notify(\\_SB.SKIN,0x81)
        }
        Case(3) { // Critical temperature event
          Notify(\\_SB.SKIN,0x82)
        }
      }
    }

    // Input Device Events
    If(LEqual(ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),Arg0)) {
      Switch(Arg1) {
        Case(1) { // LID event
          Notify(\\_SB._LID,0x80)
        }
      }
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-mapped-interface-via-ffa-for-ucsi"><a class="header" href="#memory-mapped-interface-via-ffa-for-ucsi">Memory Mapped Interface via FFA for UCSI</a></h3>
<p>Note for this implementation of memory mapped interface to work the
memory must be marked as reserved by UEFI and not used by the OS and
direct access also given to the corresponding service in secure world.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(USBC) {
  Name(_HID,EISAID(‚ÄúUSBC000‚Äù))
  Name(_CID,EISAID(‚ÄúPNP0CA0‚Äù))
  Name(_UID,1)
  Name(_DDN, ‚ÄúUSB Type-C‚Äù)
  Name(_ADR,0x0)
  OperationRegion(USBC, SystemMemory, UCSI_PHYS_MEM, 0x30)
  Field(USBC,AnyAcc,Lock,Preserve)
  {
    // USB C Mailbox Interface
    VERS,16, // PPM-\&gt;OPM Version
    RES, 16, // Reservied
    CCI, 32, // PPM-\&gt;OPM CCI Indicator
    CTRL,64, // OPM-\&gt;PPM Control Messages
    MSGI,128, // OPM-\&gt;PPM Message In
    MSGO,128, // PPM-\&gt;OPM Message Out
  }

  Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
  {

    // Compare passed in UUID to Supported UUID
    If(LEqual(Arg0,ToUUID(‚Äú6f8398c2-7ca4-11e4-ad36-631042b5008f‚Äù)))
    {
      // Use FFA to send Notification event down to copy data to EC
      If(LEqual(\\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
        CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
        CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
        CreateField(BUFF,16,128,UUID) // UUID of service
        CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
        CreateField(BUFF,144,1024,FIFD) // Out ‚Äì Msg data

        // Create Doorbell Event
        Store(20, LENG)
        Store(0x0, CMDD) // UCSI set doorbell
        Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID)
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
      } // End AVAL
    } // End UUID
  } // End DSM
}
<span class="boring">}</span></code></pre></pre>
<h3 id="thermal-acpi-interface-for-ffa"><a class="header" href="#thermal-acpi-interface-for-ffa">Thermal ACPI Interface for FFA</a></h3>
<p>This sample code shows one Microsoft Thermal zone for SKIN and then a
thermal device THRM for implementing customized IO.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sample Definition of FAN ACPI
Device(SKIN) {
  Name(_HID, "MSFT000A")

  Method(_TMP, 0x0, Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(30){})
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,TZID) // Temp Sensor ID
      CreateDWordField(BUFF,26,RTMP) // Output Data

      Store(20, LENG)
      Store(0x1, CMDD) // EC_THM_GET_TMP
      Store(0x2, TZID) // Temp zone ID for SKIIN
      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (RTMP)
      }
    }
    Return (Ones)
  }

  // Arg0 Temp sensor ID
  // Arg1 Package with Low and High set points
  Method(THRS,0x2, Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(32){})
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,TZID) // Temp Sensor ID
      CreateDwordField(BUFF,20,VTIM) // Timeout
      CreateDwordField(BUFF,24,VLO) // Low Threshold
      CreateDwordField(BUFF,28,VHI) // High Threshold
      CreateDWordField(BUFF,18,TSTS) // Output Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(32, LENG)
      Store(0x2, CMDD) // EC_THM_SET_THRS
      Store(Arg0, TZID)
      Store(DeRefOf(Index(Arg1,0)),VTIM)
      Store(DeRefOf(Index(Arg1,1)),VLO)
      Store(DeRefOf(Index(Arg1,2)),VHI)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (TSTS)
      }
    }
    Return (0x3) // Hardware failure
  }

  // Arg0 GUID 1f0849fc-a845-4fcf-865c-4101bf8e8d79
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    If(LEqual(ToUuid("1f0849fc-a845-4fcf-865c-4101bf8e8d79"),Arg0)) {
      Switch(Arg2) {
        Case (0) {
          Return(0x3) // Support Function 0 and Function 1
        }
        Case (1) {
          Return( THRS(0x2, Arg3) ) // Call to function to set threshold
        }
      }
    }
    Return(0x3)
  }
}

Device(THRM) {
  Name(_HID, "MSFT000B")

  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(GVAR,2,Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(38){})
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,INST) // Instance ID
      CreateWordField(BUFF,20,VLEN) // 16-bit variable length
      CreateField(BUFF,176,128,VUID) // UUID of variable to read
      CreateField(BUFF,208,64,RVAL) // Output Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(38, LENG)
      Store(0x5, CMDD) // EC_THM_GET_VAR
      Store(Arg0,INST) // Save instance ID
      Store(4,VLEN) // Variable is always DWORD here
      Store(Arg1, VUID)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (RVAL)
      }
    }
    Return (0x3)
  }

  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(SVAR,3,Serialized) {
    If(LEqual(\\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(42){})
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18,CMDD) // Command register
      CreateByteField(BUFF,19,INST) // Instance ID
      CreateWordField(BUFF,20,VLEN) // 16-bit variable length
      CreateField(BUFF,176,128,VUID) // UUID of variable to read
      CreateDwordField(BUFF,38,DVAL) // Data value
      CreateField(BUFF,208,32,RVAL) // Ouput Data

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(42, LENG)
      Store(0x6, CMDD) // EC_THM_SET_VAR
      Store(Arg0,INST) // Save instance ID
      Store(4,VLEN) // Variable is always DWORD here
      Store(Arg1, VUID)
      Store(Arg2,DVAL)
      Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
      Return (RVAL)
      }
    }
    Return (0x3)
  }

  // Arg0 GUID
  // 07ff6382-e29a-47c9-ac87-e79dad71dd82 - Input
  // d9b9b7f3-2a3e-4064-8841-cb13d317669e - Output
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    // Input Variable
    If(LEqual(ToUuid("07ff6382-e29a-47c9-ac87-e79dad71dd82"),Arg0)) {
      Switch(Arg2) {
        Case(0) {
          // We support function 0-3
          Return(0xf)
        }
        Case(1) {
          Return(GVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"))) // OnTemp
        }
        Case(2) {
          Return(GVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"))) // RampTemp
        }
        Case(3) {
          Return(GVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"))) // MaxTemp
        }
      }
      Return(0x1)
    }

    // Output Variable
    If(LEqual(ToUuid("d9b9b7f3-2a3e-4064-8841-cb13d317669e"),Arg0)) {
      Switch(Arg2) {
        Case(0) {
          // We support function 0-3
          Return(0xf)
        }
        Case(1) {
          Return(SVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"),Arg3)) // OnTemp
        }
        Case(2) {
          Return(SVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"),Arg3)) // RampTemp
        }
        Case(3) {
          Return(SVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"),Arg3)) // MaxTemp
        }
      }
    }
    Return (0x1)
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="call-flows-for-secure-and-non-secure-implementation"><a class="header" href="#call-flows-for-secure-and-non-secure-implementation">Call Flows for secure and non-secure Implementation</a></h2>
<p>Depending on system requirements the ACPI calls may go directly to the
EC or through secure world then through to EC.</p>
<p>When using non-secure interface the ACPI functions must define protocol
level which is the Embedded controller for eSPI. For I2C/I3C or SPI
interfaces the corresponding ACPI device must define the bus dependency
and build the packet directly that is sent to the EC.</p>
<p>For secure communication all data is sent to the secure world via FF-A
commands described in this document and the actual bus protocol and data
sent to the EC is defined in the secure world in Hafnium. All support
for FF-A is inboxed in the OS by default so EC communication will always
work in any environment. However, FF-A is not supported in x86/x64
platforms so direct EC communication must be used on these platforms.</p>
<h3 id="non-secure-espi-access"><a class="header" href="#non-secure-espi-access">Non-Secure eSPI Access</a></h3>
<p>This call flow assumes using Embedded controller definition with
independent ACPI functions for MPTF support</p>
<h4 id="non-secure-espi-read"><a class="header" href="#non-secure-espi-read">Non-Secure eSPI READ</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC

  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    Memory32Fixed (ReadWrite, 0x100000, 0x10) // Used for simulated port access
    Memory32Fixed (ReadWrite, 0x100010, 0x10)
    // Interrupt defined for eSPI event signalling
    GpioInt(Edge, ActiveHigh, ExclusiveAndWake,PullUp 0,"\\_SB.GPI2"){43} 
  })

  Name(_GPE, 0) // GPE index for this EC

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
    BST1, 32, // Battery State
    BST2, 32, // Battery Present Rate
    BST3, 32, // Battery Remaining capacity
    BST4, 32, // Battery Present Voltage
  }

  Method (_BST) {
    Name (BSTD, Package (0x4)
    {
      \\_SB.PCI0.ISA0.EC0.BST1, // Battery State
      \\_SB.PCI0.ISA0.EC0.BST2, // Battery Present Rate
      \\_SB.PCI0.ISA0.EC0.BST3, // Battery Remaining Capacity
      \\_SB.PCI0.ISA0.EC0.BST4, // Battery Present Voltage
    })
    Return(BSTD)
  }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
  OSPM-&gt;&gt;ACPI: call _BST method
  ACPI-&gt;&gt;ACPI: Map to EC0 fields in EC operation Region
  ACPI-&gt;&gt;ACPI: EC0 accesses change to eSPI Peripheral accesses
  ACPI-&gt;&gt;eSPI: Each field acccess changed to peripheral read/write
  ACPI-&gt;&gt;ACPI: ACI handles SCI, port IO, MMIO, serialized
  ACPI-&gt;&gt;ACPI: eSPI read/writes complete
  ACPI-&gt;&gt;ACPI: Data is reorganized to _BST structure
  ACPI-&gt;&gt;OSPM: Return _BST structure with status
</pre>
<h4 id="non-secure-espi-notifications"><a class="header" href="#non-secure-espi-notifications">Non-Secure eSPI Notifications</a></h4>
<p>All interrupts are handled by the ACPI driver. When EC needs to send a
notification event the GPIO is asserted and traps into IRQ. ACPI driver
reads the EC_SC status register to determine if an SCI is pending. DPC
callback calls and reads the EC_DATA port to determine the _Qxx event
that is pending. Based on the event that is determined by ACPI the
corresponding _Qxx event function is called.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_Q07) {
  // Take action for event 7
  Notify(\\_SB._LID, 0x80)
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
  EC-&gt;&gt;SCI ISR: EC asserts alert (IRQ)
  SCI ISR-&gt;&gt;SCI DPC: Schedule DPC if EC_SC indicates SCI
  SCI DPC-&gt;&gt;EC: Read EC_DATA to determine event
  EC-&gt;&gt;SCI DPC: Send Qxx event
  SCI DPC-&gt;&gt;ACPI: Call _Qxx function in EC0
</pre>
<h3 id="secure-espi-access"><a class="header" href="#secure-espi-access">Secure eSPI Access</a></h3>
<p>The following flow assumes ARM platform using FF-A for secure calls.
Note if you want to use the same EC firmware on both platforms with
secure and non-secure access the EC_BAT_GET_BST in this case should
be convert to a peripheral access with the same IO port and offset as
non-secure definition.</p>
<h4 id="secure-espi-read"><a class="header" href="#secure-espi-read">Secure eSPI READ</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_BST) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, BMA1) // In ‚Äì Averaging Interval
    CreateField(BUFF,144,128,BSTD) // Out ‚Äì 4 DWord BST data

    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(42, LENG)
    Store(0x6, CMDD) // EC_BAT_GET_BST
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
    Return (BMAD)
    } 
  } 
  Return(Zero)
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
 OSPM-&gt;&gt;ACPI: call_BST method
 ACPI-&gt;&gt;FFA: Send EC_BAT_GET_BST_request
 FFA-&gt;&gt;EC Service: Forward EC_BAT_GET_BST_request
 EC Service-&gt;&gt;EC Service: Convert to eSPI peripheral read/write
 EC Service-&gt;&gt;eSPI: send peripheral read/write access
 EC Service-&gt;&gt;FFA: FFA_YIELD (as needed)
 FFA-&gt;&gt;EC Service: FFA_RESUME (check for complete)
 eSPI-&gt;&gt;EC Service: Return peripheral read data
 EC Service-&gt;&gt;EC Service: Convert to EC_BAT_GET_BST response
 EC Service-&gt;&gt;FFA: FFA response to original request
 FFA-&gt;&gt;ACPI: return FFA status and _BST response
 ACPI-&gt;OSPM: return _BST structure

</pre>
<h4 id="secure-espi-notification"><a class="header" href="#secure-espi-notification">Secure eSPI Notification</a></h4>
<p>When EC communication is done through Secure world we assert FIQ which
is handled as eSPI interrupt. eSPI driver reads EC_SC and EC_DATA to
retrieve the notification event details. On Non-secure implementation
ACPI converts this to Qxx callback. On secure platform this is converted
to a virtual ID and sent back to the OS via _NFY callback and a virtual
ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method(_NFY, 2, Serialized) {
  // Arg0 == UUID
  // Arg1 == Notify ID
  If(LEqual(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"),Arg0)) {
    If(LEqual(0x2,Arg1)) {
      Store(Arg1, \\_SB.ECT0.NEVT)
      Notify(\\_SB._LID, 0x80)
    }
  }
}
<span class="boring">}</span></code></pre></pre>
<pre class="mermaid">sequenceDiagram
   EC-&gt;&gt;eSPI: EC asserts Alert (FIQ)
   eSPI-&gt;&gt;EC: Read EC_SC to check for SCI
   eSPI-&gt;&gt;EC: Read EC_DATA for SCI event
   EC-&gt;&gt;eSPI: SCI Qxx event
   
   eSPI-&gt;&gt;EC Service: Notification callback Qxx
   EC Service-&gt;&gt;EC Service: Convert qxx to Virtual ID
   EC Service-&gt;&gt;EC Nfy Service: Notify Virtual ID
   EC Nfy Service-&gt;&gt;FFA:Send Physical ID
   FFA-&gt;&gt;ACPI:Call_NFY with Virtual ID
   ACPI-&gt;&gt;ACPI: Read SMEM notify details
   ACPI--)EC Service: Clear event (optional)

   
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-ec-interface"><a class="header" href="#legacy-ec-interface">Legacy EC Interface</a></h1>
<p>ACPI specification has a definition for an embedded controller, however
this implementation is tied very closely to the eSPI bus and x86
architecture.</p>
<p>The following is an example of legacy EC interface definition from ACPI</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/11_Thermal_Management/thermal-zone-examples.html">11.7. Thermal Zone Examples ‚Äî ACPI Specification 6.4
documentation</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Scope(\\_SB.PCI0.ISA0) {
  Device(EC0) {
    Name(_HID, EISAID("PNP0C09")) // ID for this EC

    // current resource description for this EC
    Name(_CRS, ResourceTemplate() {
      IO(Decode16,0x62,0x62,0,1)
      IO(Decode16,0x66,0x66,0,1)
    })

    Name(_GPE, 0) // GPE index for this EC
    
    // create EC's region and field for thermal support
    OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
    Field(EC0, ByteAcc, Lock, Preserve) {
      MODE, 1, // thermal policy (quiet/perform)
      FAN, 1, // fan power (on/off)
      , 6, // reserved
      TMP, 16, // current temp
      AC0, 16, // active cooling temp (fan high)
      , 16, // reserved
      PSV, 16, // passive cooling temp
      HOT 16, // critical S4 temp
      CRT, 16 // critical temp
    }

    // following is a method that OSPM will schedule after
    // it receives an SCI and queries the EC to receive value 7
    Method(_Q07) {
      Notify (\\_SB.PCI0.ISA0.EC0.TZ0, 0x80)
    } // end of Notify method

    // fan cooling on/off - engaged at AC0 temp
    PowerResource(PFAN, 0, 0) {
      Method(_STA) { Return (\\_SB.PCI0.ISA0.EC0.FAN) } // check power state
      Method(_ON) { Store (One, \\\\_SB.PCI0.ISA0.EC0.FAN) } // turn on fan
      Method(_OFF) { Store ( Zero, \\\\_SB.PCI0.ISA0.EC0.FAN) }// turn off
fan
    }

    // Create FAN device object
    Device (FAN) {
    // Device ID for the FAN
    Name(_HID, EISAID("PNP0C0B"))
    // list power resource for the fan
    Name(_PR0, Package(){PFAN})
    }

    // create a thermal zone
    ThermalZone (TZ0) {
      Method(_TMP) { Return (\\_SB.PCI0.ISA0.EC0.TMP )} // get current temp
      Method(_AC0) { Return (\\_SB.PCI0.ISA0.EC0.AC0) } // fan high temp
      Name(_AL0, Package(){\\_SB.PCI0.ISA0.EC0.FAN}) // fan is act cool dev
      Method(_PSV) { Return (\\_SB.PCI0.ISA0.EC0.PSV) } // passive cooling
temp
      Name(_PSL, Package (){\\_SB.CPU0}) // passive cooling devices
      Method(_HOT) { Return (\\_SB.PCI0.ISA0.EC0.HOT) } // get critical S4
temp
      Method(_CRT) { Return (\\_SB.PCI0.ISA0.EC0.CRT) } // get critical temp
      Method(_SCP, 1) { Store (Arg1, \\\\_SB.PCI0.ISA0.EC0.MODE) } // set
cooling mode

      Name(_TSP, 150) // passive sampling = 15 sec
      Name(_TZP, 0) // polling not required
      Name (_STR, Unicode ("System thermal zone"))
    } // end of TZ0
  } // end of ECO
} // end of \\\\_SB.PCI0.ISA0 scope-
<span class="boring">}</span></code></pre></pre>
<p>On platforms that do not support IO port access there is an option to
define MMIO regions to simulate the IO port transactions.</p>
<p>In the above example you can see that the operation region directly maps
to features on the EC and you can change the EC behavior by writing to a
byte in the region or reading the latest data from the EC.</p>
<p>For a system with the EC connected via eSPI and that needs a simple
non-secure interface to the EC the above mapping works very well and
keeps the code simple. The eSPI protocol itself has details on port
accesses and uses the peripheral channel to easily read/write memory
mapped regions.</p>
<p>As the EC features evolve there are several requirements that do no work
well with this interface:</p>
<ul>
<li>
<p>Different buses such as I3C, SPI, UART target a packet
request/response rather than a memory mapped interface</p>
</li>
<li>
<p>Protected or restricted access and validation of request/response</p>
</li>
<li>
<p>Firmware update, large data driven requests that require larger data
response the 256-byte region is limited</p>
</li>
<li>
<p>Discoverability of features available and OEM customizations</p>
</li>
<li>
<p>Out of order completion of requests, concurrency, routing and
priority handling</p>
</li>
</ul>
<p>As we try to address these limitations and move to a more packet based
protocol described in this document. The following section covers
details on how to adopt existing operation region to new ACPI
functionality.</p>
<h2 id="adopting-ec-operation-region"><a class="header" href="#adopting-ec-operation-region">Adopting EC Operation Region</a></h2>
<p>The new OS frameworks such as MPTF still use ACPI methods as primary
interface. Instead of defining devices such as FAN or ThermalZone in the
EC region you can simply define the EC region itself and then map all
the other ACPI functions to operate on this region. This will allow you
to maintain backwards compatibility with existing EC definitions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC
  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    IO(Decode16,0x62,0x62,0,1)
    IO(Decode16,0x66,0x66,0,1)
  })

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
  }
}

Device(SKIN) {
¬† Name(_HID, "MSFT000A") // New MPTF HID Temperature Device
¬† Method(_TMP, 0x0, Serialized) {
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇReturn( \\_SB.PCI0.ISA0.EC0.TMP)
¬† }
}
<span class="boring">}</span></code></pre></pre>
<p>For more complicated functions that take a package some of the data may
be constructed within ACPI and some of the data pulled from the
OperationRegion. For example BIX for battery information may have a
combination of static and dynamic data like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method (_BIX) {
  Name (BAT0, Package (0x12)
  {
    0x01, // Revision
    0x02, // Power Unit
    0x03, // Design Capacity
    \\_SB.PCI0.ISA0.EC0.BFCC, // Last Full Charge Capacity
    0x05, // Battery Technology
    0x06, // Design Voltage
    0x07, // Design capacity of Warning
    0x08, // Design Capacity of Low
    \\_SB.PCI0.ISA0.EC0.BCYL, // Cycle Count
    0x0A, // Measurement Accuracy
    0x0B, // Max Sampling Time
    0x0C, // Min Sampling Time
    0x0D, // Max Averaging Interval
    0x0E, // Min Averaging Interval
    0x0F, // Battery Capacity Granularity 1
    0x10, // Battery Capacity Granularity 2
    "Model123", // Model Number
    "Serial456", // Serial Number
    "Li-Ion", // Battery Type
    "OEMName" // OEM Information
  })
  Return(BAT0)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="limitations-for-using-legacy-ec"><a class="header" href="#limitations-for-using-legacy-ec">Limitations for using Legacy EC</a></h2>
<p>Before using the Legacy EC definition OEM‚Äôs should be aware of several
use cases that may limit you ability to use it.</p>
<h3 id="acpi-support-for-espi-master"><a class="header" href="#acpi-support-for-espi-master">ACPI support for eSPI master</a></h3>
<p>In the case of Legacy EC the communication to the EC is accomplished
directly by the ACPI driver using PORT IO and eSPI Peripheral Bus
commands. On ARM platforms there is no PORT IO and these must be
substituted with MMIO regions. The ACPI driver needs changes to support
MMIO which is being evaluated and support is not yet available. Some
Silicon Vendors also do not implement the full eSPI specification and as
such the ACPI driver cannot handle all the communication needs. On these
platforms using Legacy EC interface is not an option.</p>
<h3 id="security-of-espi-bus"><a class="header" href="#security-of-espi-bus">Security of eSPI bus</a></h3>
<p>When non-secure world is given access to the eSPI bus it can send
commands to device on that bus. Some HW designs have the TPM or SPINOR
on the same physical bus as the EC. On these designs allowing non-secure
world to directly sends commands to EC can break the security
requirements of other devices on the bus. In these cases the eSPI
communication must be done in the secure world over FF-A as covered in
this document and not use the Legacy EC channel. Since non-secure world
has complete access to the EC operation region there is no chance for
encryption of data. All data in the operation region is considered
non-secure.</p>
<h3 id="functional-limitations-of-legacy-ec"><a class="header" href="#functional-limitations-of-legacy-ec">Functional limitations of Legacy EC</a></h3>
<p>The peripheral region that is mapped in the Legacy EC in ACPI is limited
to 256 bytes and notification events to the ones that are defined and
handled in ACPI driver. To create custom solutions, send large packets
or support encryption of data the Legacy EC interface has limitations in
this area.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-ec-services-overview"><a class="header" href="#secure-ec-services-overview">Secure EC Services Overview</a></h1>
<p>In this section we review a system design where the EC communication is
in the secure world running in a dedicated SP. In a system without
secure world or where communication to EC is not desired to be secure
all the ACPI functions can be mapped directly to data from the EC
operation region.</p>
<p>The following github projects provide sample implementations of this interface:</p>
<p><a href="https://github.com/opendevicepartnership/ec-test-app">ACPI EC samples, Kernel mode test driver, User mode test driver</a><br>
<a href="https://github.com/opendevicepartnership/haf-ec-service">Sample Secure Partition Service for EC services in RUST</a><br>
<a href="https://github.com/opendevicepartnership/ffa">RUST crate for FFA implementation in secure partition</a><br></p>
<p>The following GUID‚Äôs have been designed to represent each service
operating in the secure partition for EC.</p>
<table>
<thead>
<tr class="header">
<th>EC Service Name</th>
<th>Service GUID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<td>EC_SVC_MANAGEMENT</td>
<td>330c1273-fde5-4757-9819-5b6539037502</td>
<td>Used to query EC functionality, Board info, version, security state, FW update</td>
</tr>
<td>EC_SVC_POWER</td>
<td>7157addf-2fbe-4c63-ae95-efac16e3b01c</td>
<td>Handles general power related requests and OS Sx state transition state notification</td>
</tr>
<td>EC_SVC_BATTERY</td>
<td>25cb5207-ac36-427d-aaef-3aa78877d27e</td>
<td>Handles battery info, status, charging</td>
</tr>
<td>EC_SVC_THERMAL</td>
<td>31f56da7-593c-4d72-a4b3-8fc7171ac073</td>
<td>Handles thermal requests for skin and other thermal events</td>
</tr>
<td>EC_SVC_UCSI</td>
<td>65467f50-827f-4e4f-8770-dbf4c3f77f45</td>
<td>Handles PD notifications and calls to UCSI interface</td>
</tr>
<td>EC_SVC_INPUT</td>
<td>e3168a99-4a57-4a2b-8c5e-11bcfec73406</td>
<td>Handles wake events, power key, lid, input devices (HID separate instance)</td>
</tr>
<td>EC_SVC_TIME_ALARM</td>
<td>23ea63ed-b593-46ea-b027-8924df88e92f</td>
<td>Handles RTC and wake timers.</td>
</tr>
<td>EC_SVC_DEBUG</td>
<td>0bd66c7c-a288-48a6-afc8-e2200c03eb62</td>
<td>Used for telemetry, debug control, recovery modes, logs, etc</td>
</tr>
<td>EC_SVC_TEST</td>
<td>6c44c879-d0bc-41d3-bef6-60432182dfe6</td>
<td>Used to send commands for manufacturing/factory test</td>
</tr>
<td>EC_SVC_OEM1</td>
<td>9a8a1e88-a880-447c-830d-6d764e9172bb</td>
<td>Sample OEM custom service and example piping of events</td>
</tr>
</tbody>
</table>
<h2 id="ffa-overview"><a class="header" href="#ffa-overview">FFA Overview</a></h2>
<p>This section covers the components involved in sending a command to EC
through the FFA flow in windows. This path is specific to ARM devices
and a common solution with x64 is still being worked out. Those will
continue through the non-secure OperationRegion in the near term.</p>
<p><img src="intro/concepts/ec_services_example/media/image1.png" alt="A diagram of a computer security system Description automatically generated" /></p>
<p>ARM has a standard for calling into the secure world through SMC‚Äôs and
targeting a particular service running in secure world via a UUID. The
full specification and details can be found here: <a href="https://developer.arm.com/Architectures/Firmware%20Framework%20for%20A-Profile">Firmware Framework
for A-Profile</a></p>
<p>The windows kernel provides native ability for ACPI to directly send and
receive FFA commands. It also provides a driver ffadrv.sys to expose a
DDI that allows other drivers to directly send/receive FFA commands
without needing to go through ACPI.</p>
<p>Hyper-V forwards the SMC‚Äôs through to EL3 to Hafnium which then uses the
UUID to route the request to the correct SP and service. From the
corresponding EC service it then calls into the eSPI or underlying
transport layer to send and receive the request to the physical EC.</p>
<h3 id="ffa-device-definition-1"><a class="header" href="#ffa-device-definition-1">FFA Device Definition</a></h3>
<p>The FFA device is loaded from ACPI during boot and as such requires a
Device entry in ACPI</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Name(_HID, "MSFT000C")

  OperationRegion(AFFH, FFixedHw, 4, 144) 
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }     
    

  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              2, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
              Package () {
                     ToUUID("b510b3a3-59f6-4054-ba7a-ff2eb1eac765"), // Service2 UUID
                     Package () {
                          0x01,     //Cookie1
                          0x03,     //Cookie2
                      }
             }
         }
      }
    }
  }) // _DSD()

  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }

  Method(AVAL,0x0, Serialized)
  {
    Return(One)
  }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="hid-definition"><a class="header" href="#hid-definition">HID definition</a></h4>
<p>The _HID ‚ÄúMSFT000C‚Äù is reserved for FFA devices. Defining this HID for
your device will cause the FFA interface for the OS to be loaded on this
device.</p>
<h4 id="operation-region-definition"><a class="header" href="#operation-region-definition">Operation Region Definition</a></h4>
<p>The operation region is marked as FFixedHw type 4 which lets the ACPI
interpreter know that any read/write to this region requires special
handling. The length is 144 bytes because this region operates on
registers X0-X17 each of which are 8 bytes 18*8 = 144 bytes. This is
mapped to FFAC is 1152 bits (144*8) and this field is where we act
upon.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>OperationRegion(AFFH, FFixedHw, 4, 144)
Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1),FFAC, 1152 }
<span class="boring">}</span></code></pre></pre>
<p>When reading and writing from this operation region the FFA driver does
some underlying mapping for X0-X3</p>
<pre><code>X0 = 0xc400008d // FFA_DIRECT_REQ2
X1 = (Receiver Endpoint ID) | (Sender Endpoint ID \&lt;\&lt; 16)
X2/X3 = UUID
</code></pre>
<p>The following is the format of the request and response packets that are
sent via ACPI</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FFA_REQ_PACKET
{
  uint8 status; // Not used just populated so commands are symmetric
  uint8 length; // Number of bytes in rawdata
  uint128 UUID;
  uint8 reqdata[];
}

FFA_RSP_PACKET
{
  uint8 status; // Status from ACPI if FFA command was sent successfully
  uint8 length;
  uint128 UUID;
  uint64 ffa_status; // Status returned from the service of the FFA command
  uint8 rspdata[];
}

CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // In/Out - UUID of service
CreateDwordField(BUFF,18,FFST)// Out - FFA command status
<span class="boring">}</span></code></pre></pre>
<h4 id="register-notification"><a class="header" href="#register-notification">Register Notification</a></h4>
<p>During FFA driver initialization it calls into secure world to get a
list of all available services for each secure partition. After this we
send a NOTIFICATION_REGISTRATION request to each SP that has a service
which registers for notification events</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              1, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
         }
      }
    }
  }) // _DSD()
<span class="boring">}</span></code></pre></pre>
<p><img src="intro/concepts/ec_services_example/media/image2.png" alt="A diagram of a application Description automatically generated" /></p>
<p>In the above example we indicate that the OS will handle 2 different
notification events for UUID 330c1273-fde5-4757-9819-5b6539037502 which
is our EC management UUID. FFA knows which secure partition this maps to
based on the list of services for each SP it has retrieved. Rather than
having to keep track of all the physical bits in the bitmask that are
used the FFA driver keeps track of this and allows each service to
create a list of virtual ID‚Äôs they need to handle. The FFA driver then
maps this to one of the available bits in the hardware bitmask and
passes this mapping down to the notification service running in a given
SP.</p>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<table>
<thead>
<tr class="header">
<th><strong>Parameter¬†</strong></th>
<th><strong>Register¬†</strong></th>
<th><strong>Value¬†</strong></th>
</tr>
</thead>
<tbody>
<td>Function<strong>¬†</strong></td>
<td>X4¬†</td>
<td>0x1¬†</td>
</tr>
<td>UUID Lo<strong>¬†</strong></td>
<td>X5¬†</td>
<td>Bytes [0..7] for the service UUID.¬†</td>
</tr>
<td>UUID Hi<strong>¬†</strong></td>
<td>X6¬†</td>
<td>Bytes [8..16] for the service UUID.¬†</td>
</tr>
<td>Mappings Count<strong>¬†</strong></td>
<td>X7¬†</td>
<td>The number of notification mappings¬†</td>
</tr>
<td>Notification Mapping1<strong>¬†</strong></td>
<td>X8¬†</td>
<td><p>Bits [0..16] ‚Äì Notification ID. --&gt; 0,1,2,3,...¬†</p>
<p>¬†</p>
<p>Bits [16..32] ‚Äì Notification Bitmap bit number (0-383).¬†¬†</p></td>
</tr>
<td>Notification Mapping2<strong>¬†</strong></td>
<td>X9¬†</td>
<td><p>Bits [0..16] ‚Äì Notification ID. --&gt; 0,1,2,3,...¬†</p>
<p>¬†</p>
<p>Bits [16..32] ‚Äì Notification Bitmap bit number (0-383).¬†</p>
<p>¬†</p></td>
</tr>
<td>...<strong>¬†</strong></td>
<td>...¬†</td>
<td>...¬†</td>
</tr>
</tbody>
</table>
<p>¬†</p>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter¬†</th><th>Register¬†</th><th>Value¬†</th></tr></thead><tbody>
<tr><td>Result</td><td>X4</td><td>0 on success. Otherwise, Failure</td></tr>
</tbody></table>
</div>
<p>¬†</p>
<p>Note this NOTIFICATION_REGISTER request is sent to the
Notification Service UUID in the SP. The UUID of the service that the
notifications are for are stored in X5/X6 registers shown above.</p>
<p>The UUID for notification service is
{B510B3A3-59F6-4054-BA7A-FF2EB1EAC765} which is stored in X2/X3.</p>
<h4 id="notification-events"><a class="header" href="#notification-events">Notification Events</a></h4>
<p>All notification events sent from all secure partitions are passed back
through the FFA driver. The notification calls the _DSM method. Function 0
is always a bitmap of all the other functions supported. We must support at
least a minium of the Query and Notify.
The UUID is stored in Arg0 and the notification cookie is stored in Arg3 when Arg2 is 11.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(Index(Arg3,1), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }
<span class="boring">}</span></code></pre></pre>
<p>The following is the call flow showing a secure interrupt arriving to
the EC service which results in a notification back to ACPI. The
notification payload can optionally be written to a shared buffer or
ACPI can make another call back into EC service to retrieve the
notification details.</p>
<p>The _NFY only contains the ID of the notification and no other payload,
so both ACPI and the EC service must be designed either with shared
memory buffer or a further notify data packet.</p>
<p><img src="intro/concepts/ec_services_example/media/image3.png" alt="A diagram of a service Description automatically generated" /></p>
<h2 id="runtime-requests"><a class="header" href="#runtime-requests">Runtime Requests</a></h2>
<p>During runtime the non-secure side uses FFA_MSG_SEND_DIRECT_REQ2
requests to send requests to a given service within an SP. Any request
that is expected to take longer than 500 uSec should yield control back
to the OS by calling FFA_YIELD within the service. When FFA_YIELD is
called it will return control back to the OS to continue executing but
the corresponding ACPI thread will be blocked until the original FFA
request completes with DIRECT_RSP2. Note this creates a polling type
interface where the OS will resume the SP thread after the timeout
specified. The following is sample call sequence.</p>
<p><img src="intro/concepts/ec_services_example/media/image4.png" alt="A diagram of a company&#39;s process Description automatically generated" /></p>
<h3 id="ffa-example-data-flow"><a class="header" href="#ffa-example-data-flow">FFA Example Data Flow</a></h3>
<p>For an example let‚Äôs take the battery status request _BST and follow
data through.</p>
<p><img src="intro/concepts/ec_services_example/media/image5.png" alt="A screenshot of a computer Description automatically generated" /></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>FFA_REQ_PACKET req = {
  0x0, // Initialize to no error
  0x1, // Only 1 byte of data is sent after the header
  {0x25,0xcb,0x52,0x07,0xac,0x36,0x42,0x7d,0xaa,0xef,0x3a,0xa7,0x88,0x77,0xd2,0x7e},
  0x2 // EC_BAT_GET_BST
}
<span class="boring">}</span></code></pre></pre>
<p>The equivalent to write this data into a BUFF in ACPI is as follows</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // UUID of service
CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
CreateField(BUFF,144,128,BSTD) // Out ‚Äì Raw data response 4 DWords
Store(20,LENG)
Store(0x2, CMDD)
Store(ToUUID ("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID)
Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)
<span class="boring">}</span></code></pre></pre>
<p>The ACPI interpreter when walking through this code creates a buffer and
populates the data into buffer. The last line indicates to send this
buffer over FFA interface.</p>
<p>ACPI calls into the FFA interface to send the data over to the secure
world EC Service</p>
<pre><code>typedef struct _FFA_INTERFACE {
¬† ¬† ULONG Version;
¬† ¬† PFFA_MSG_SEND_DIRECT_REQ2 SendDirectReq2;
} FFA_INTERFACE, \*PFFA_INTERFACE;
</code></pre>
<h3 id="ffa-parsing"><a class="header" href="#ffa-parsing">FFA Parsing</a></h3>
<p>FFA is in charge of sending the SMC over to the secure world and routing
to the correct service based on UUID.</p>
<p><img src="intro/concepts/ec_services_example/media/image6.png" alt="A diagram of a computer Description automatically generated" /></p>
<pre><code>X0 = SEND_DIRECT_REQ2 SMC command ID
X1 = Source ID and Destination ID
X2 = UUID Low
X3 = UUID High
X4-X17 = rawdata
</code></pre>
<p><strong>Note:</strong> The status and length are not passed through to the secure
world they are consumed only be ACPI.</p>
<p>HyperV and Monitor have a chance to filter or deny the request, but in
general just pass the SMC request through to Hafnium</p>
<p>Hafnium extracts the data from the registers into an sp_msg structure
which is directly mapping contents from x0-x17 into these fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FfaParams {
¬† ¬† pub x0: u64,
¬† ¬† pub x1: u64,
¬† ¬† pub x2: u64,
¬† ¬† pub x3: u64,
¬† ¬† pub x4: u64,
¬† ¬† pub x5: u64,
¬† ¬† pub x6: u64,
¬† ¬† pub x7: u64,
¬† ¬† pub x8: u64,
¬† ¬† pub x9: u64,
¬† ¬† pub x10: u64,
¬† ¬† pub x11: u64,
¬† ¬† pub x12: u64,
¬† ¬† pub x13: u64,
¬† ¬† pub x14: u64,
¬† ¬† pub x15: u64,
¬† ¬† pub x16: u64,
¬† ¬† pub x17: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>In our SP we receive the raw FfaParams structure and we convert this to
an FfaMsg using our translator. This pulls out the function_id,
source_id, destination_id and uuid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn from(params: FfaParams) -&gt; FfaMsg {
  FfaMsg {
¬†   function_id: params.x0, ¬† ¬† ¬† ¬† ¬† ¬† ¬†// Function id is in lower 32 bits of x0
¬† ¬† source_id: (params.x1 &gt;&gt; 16) as u16, // Source in upper 16 bits
¬† ¬† destination_id: params.x1 as u16, ¬† ¬†// Destination in lower 16 bits
¬† ¬† uuid: u64_to_uuid(params.x2, params.x3),
¬† ¬† args64: [
¬† ¬†   params.x4, params.x5, params.x6, params.x7, params.x8, params.x9, params.x10,
¬† ¬† ¬† params.x11, params.x12, params.x13, params.x14, params.x15, params.x16, params.x17,
¬† ¬† ¬† ¬† ¬† ¬† ],
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The destination_id is used to route the message to the correct SP, this
is based on the ID field in the DTS description file. Eg: id =
&lt;0x8001&gt;;</p>
<h3 id="ec-service-parsing"><a class="header" href="#ec-service-parsing">EC Service Parsing</a></h3>
<p>Within the EC partition there are several services that run, the routing
of the FF-A request to the correct services is done by the main message
handling loop for the secure partition. After receiving a message we
call into ffa_msg_handler and based on the UUID send it to the
corresponding service to handle the message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut next_msg = ffa.msg_wait();
loop {
  match next_msg {
 ¬†  Ok(ffamsg) =&gt; match ffa_msg_handler(&amp;ffamsg) {
¬† ¬†   Ok(msg) =&gt; next_msg = ffa.msg_resp(\&amp;msg),
¬† ¬†   Err(_e) =&gt; panic!("Failed to handle FFA msg"),
¬†   },
¬†   Err(_e) =&gt; {
  ¬†   panic!("Error executing msg_wait");
¬†   }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>The main message loop gets the response back from ffa_msg_handler and
returns to non-secure world so the next incoming message after the
response is a new message to handle.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ffa_msg_handler(msg: &amp;FfaMsg) -&gt; Result&lt;FfaMsg&gt; {
¬† ¬† println!(
¬† ¬† ¬† ¬† "Successfully received ffa msg:
¬† ¬† ¬† ¬† function_id = {:08x}
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†uuid = {}",
¬† ¬† ¬† ¬† msg.function_id, msg.uuid
¬† ¬† );

¬† ¬† match msg.uuid {
¬† ¬† ¬† ¬† UUID_EC_SVC_MANAGEMENT =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let fwmgmt = fw_mgmt::FwMgmt::new();
¬† ¬† ¬† ¬† ¬† ¬† fwmgmt.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_NOTIFY =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let ntfy = notify::Notify::new();
¬† ¬† ¬† ¬† ¬† ¬† ntfy.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_POWER =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let pwr = power::Power::new();
¬† ¬† ¬† ¬† ¬† ¬† pwr.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_BATTERY =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let batt = battery::Battery::new();
¬† ¬† ¬† ¬† ¬† ¬† batt.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_THERMAL =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let thm = thermal::ThmMgmt::new();
¬† ¬† ¬† ¬† ¬† ¬† thm.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_UCSI =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let ucsi = ucsi::UCSI::new();
¬† ¬† ¬† ¬† ¬† ¬† ucsi.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_TIME_ALARM =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let alrm = alarm::Alarm::new();
¬† ¬† ¬† ¬† ¬† ¬† alrm.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_DEBUG =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let dbg = debug::Debug::new();
¬† ¬† ¬† ¬† ¬† ¬† dbg.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_OEM =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let oem = oem::OEM::new();
¬† ¬† ¬† ¬† ¬† ¬† oem.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† _ =&gt; panic!("Unknown UUID"),
¬† ¬† }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="large-data-transfers"><a class="header" href="#large-data-transfers">Large Data Transfers</a></h3>
<p>When making an FFA_MSG_SEND_DIRECT_REQ2 call the data is stored in
registers X0-X17. X0-X3 are reserved to store the Function Id, Source
Id, Destination Id and UUID. This leaves X4-X17 or 112 bytes. For larger
messages they either need to be broken into multiple pieces or make use
of a shared buffer between the OS and Secure Partition.</p>
<h4 id="shared-buffer-definitions"><a class="header" href="#shared-buffer-definitions">Shared Buffer Definitions</a></h4>
<p>To create a shared buffer you need to modify the dts file for the secure
partition to include mapping to your buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ns_comm_buffer {
  description = "ns-comm";
  base-address = &lt;0x00000100 0x60000000&gt;;
  pages-count = &lt;0x8&gt;;
  attributes = &lt;NON_SECURE_RW&gt;;
};
<span class="boring">}</span></code></pre></pre>
<p>During UEFI Platform initialization you will need to do the following
steps, see the FFA specification for more details on these commands</p>
<ul>
<li>FFA_MAP_RXTX_BUFFER</li>
<li>FFA_MEM_SHARE</li>
<li>FFA_MSG_SEND_DIRECT_REQ2 (EC_CAP_MEM_SHARE)</li>
<li>FFA_UNMAP_RXTX_BUFFER</li>
</ul>
<p>The RXTX buffer is used during larger packet transfers but can be
overridden and updated by the framework. The MEM_SHARE command uses the
RXTX buffer so we first map that buffer then populate our memory
descriptor requests to the TX_BUFFER and send to Hafnium. After sending
the MEM_SHARE request we need to instruct our SP to retrieve this
memory mapping request. This is done through our customer
EC_CAP_MEM_SHARE request where we describe the shared memory region
that UEFI has donated. From there we call FFA_MEM_RETRIEVE_REQ to map
the shared memory that was described to Hafnium. After we are done with
the RXTX buffers we must unmap them as the OS will re-map new RXTX
buffers. From this point on both Non-secure and Secure side will have
access to this shared memory buffer that was allocated.</p>
<h3 id="async-transfers"><a class="header" href="#async-transfers">Async Transfers</a></h3>
<p>All services are single threaded by default. Even when doing FFA_YIELD
it does not allow any new content to be executed within the service. If
you need your service to be truly asynchronous you must have commands
with delayed responses.</p>
<p>There is no packet identifier by default and tracking of requests and
completion by FFA, so the sample solution given here is based on shared
buffers defined in previous section and existing ACPI and FFA
functionality.</p>
<p><img src="intro/concepts/ec_services_example/media/image7.png" alt="A diagram of a service Description automatically generated" /></p>
<p>Inside of our FFA functions rather than copying our data payload into
the direct registers we define a queue in shared memory and populate the
actual data into this queue entry. In the FFA_MSG_SEND_DIRECT_REQ2
we populate an ASYNC command ID (0x0) along with the seq #. The seq #
is then used by the service to locate the request in the TX queue. We
define a separate queue for RX and TX so we don‚Äôt need to synchronize
between OS and secure partition.</p>
<p><img src="intro/concepts/ec_services_example/media/image8.png" alt="" /></p>
<h3 id="acpi-structures-and-methods-for-asynchronous"><a class="header" href="#acpi-structures-and-methods-for-asynchronous">ACPI Structures and Methods for Asynchronous</a></h3>
<p>The SMTX is shared memory TX region definition</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shared memory regions and ASYNC implementation
OperationRegion (SMTX, SystemMemory, 0x10060000000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMTX, AnyAcc, NoLock, Preserve)
{
  TVER, 16,
  TCNT, 16,
  TRS0, 32,
  TB0, 64,
  TB1, 64,
  TB2, 64,
  TB3, 64,
  TB4, 64,
  TB5, 64,
  TB6, 64,
  TB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  TE0, 2048,
  TE1, 2048,
  TE2, 2048,
  TE3, 2048,
  TE4, 2048,
  TE5, 2048,
  TE6, 2048,
  TE7, 2048,
}
<span class="boring">}</span></code></pre></pre>
<p>The QTXB method copies data into first available entry in the TX queue
and returns sequence number used.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Arg0 is buffer pointer
// Arg1 is length of Data
// Return Seq \#
Method(QTXB, 0x2, Serialized) {
  Name(TBX, 0x0)
  Store(Add(ShiftLeft(1,32),Add(ShiftLeft(Arg1,16),SEQN)),TBX)
  Increment(SEQN)
  // Loop until we find a free entry to populate
  While(One) {
    If(LEqual(And(TB0,0xFFFF),0x0)) {
      Store(TBX,TB0); Store(Arg0,TE0); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB1,0xFFFF),0x0)) {
      Store(TBX,TB1); Store(Arg0,TE1); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB2,0xFFFF),0x0)) {
      Store(TBX,TB2); Store(Arg0,TE2); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB3,0xFFFF),0x0)) {
      Store(TBX,TB3); Store(Arg0,TE3); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB4,0xFFFF),0x0)) {
      Store(TBX,TB4); Store(Arg0,TE4); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB5,0xFFFF),0x0)) {
      Store(TBX,TB5); Store(Arg0,TE5); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB6,0xFFFF),0x0)) {
      Store(TBX,TB6); Store(Arg0,TE6); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB7,0xFFFF),0x0)) {
      Store(TBX,TB7); Store(Arg0,TE7); Return( And(TBX,0xFFFF) )
    }

    Sleep(5)
  }
}
<span class="boring">}</span></code></pre></pre>
<p>The SMRX is shared memory region for RX queues</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Shared memory region
OperationRegion (SMRX, SystemMemory, 0x10060001000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMRX, AnyAcc, NoLock, Preserve)
{
  RVER, 16,
  RCNT, 16,
  RRS0, 32,
  RB0, 64,
  RB1, 64,
  RB2, 64,
  RB3, 64,
  RB4, 64,
  RB5, 64,
  RB6, 64,
  RB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  RE0, 2048,
  RE1, 2048,
  RE2, 2048,
  RE3, 2048,
  RE4, 2048,
  RE5, 2048,
  RE6, 2048,
  RE7, 2048,
}
<span class="boring">}</span></code></pre></pre>
<p>The RXDB function takes sequence number as input and will keep looping
through all the entries until we see packet has completed. Sleeps for
5ms between each iteration to allow the OS to do other things and other
ACPI threads can run.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allow multiple threads to wait for their SEQ packet at once
// If supporting packet \&gt; 256 bytes need to modify to stitch together packet
Method(RXDB, 0x1, Serialized) {
  Name(BUFF, Buffer(256){})
  // Loop forever until we find our seq
  While (One) {
    If(LEqual(And(RB0,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB0,16),0xFFFF),8), XB0)
      Store(RE0,BUFF); Store(0,RB0); Return( XB0 )
    }

    If(LEqual(And(RB1,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB1,16),0xFFFF),8), XB1)
      Store(RE1,BUFF); Store(0,RB1); Return( XB1 )
    }

    If(LEqual(And(RB2,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB2,16),0xFFFF),8), XB2)
      Store(RE2,BUFF); Store(0,RB2); Return( XB2 )
    }

    If(LEqual(And(RB3,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB3,16),0xFFFF),8), XB3)
      Store(RE3,BUFF); Store(0,RB3); Return( XB3 )
    }

    If(LEqual(And(RB4,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB4,16),0xFFFF),8), XB4)
      Store(RE4,BUFF); Store(0,RB4); Return( XB4 )
    }

    If(LEqual(And(RB5,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB5,16),0xFFFF),8), XB5)
      Store(RE5,BUFF); Store(0,RB5); Return( XB5 )
    }

    If(LEqual(And(RB6,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB6,16),0xFFFF),8), XB6)
      Store(RE6,BUFF); Store(0,RB6); Return( XB6 )
    }

    If(LEqual(And(RB7,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB7,16),0xFFFF),8), XB7)
      Store(RE7,BUFF); Store(0,RB7); Return( XB7 )
    }

    Sleep(5)
  }

  // If we get here didn't find a matching sequence number
  Return (Ones)
}
<span class="boring">}</span></code></pre></pre>
<p>The following is sample code to transmit a ASYNC request and wait for
the data in the RX buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Method(ASYC, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
  Name(BUFF, Buffer(30){})
  CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
  CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
  CreateField(BUFF,16,128,UUID) // UUID of service
  CreateByteField(BUFF,18,CMDD) // Command register
  CreateWordField(BUFF,19,BSQN) // Sequence Number

  // x0 -\&gt; STAT
  Store(20, LENG)
  Store(0x0, CMDD) // EC_ASYNC command
  Local0 = QTXB(BUFF,20) // Copy data to our queue entry and get back SEQN
  Store(Local0,BSQN) // Sequence packet to read from shared memory
  Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
  Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

  If(LEqual(STAT,0x0) ) // Check FF-A successful?
  {
    Return (RXDB(Local0)) // Loop through our RX queue till packet completes
  }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="recovery-and-errors"><a class="header" href="#recovery-and-errors">Recovery and Errors</a></h2>
<p>The eSPI or bus driver is expected to detect if the EC is not responding
and retry. The FFA driver will report back in the status byte if it
cannot successfully talk to the secure world. If there are other
failures generally they should be returned back up through ACPI with a
value of (Ones) to indicate failure condition. This may cause some
features to work incorrectly.</p>
<p>It is also expected that the EC has a watchdog if something on the EC is
hung it should reset and reload on its own. The EC is also responsible
for monitoring that the system is running within safe parameters. The
thermal requests and queries are meant to be advisory in nature and EC
should be able to run independently and safely without any intervention
from the OS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<h4 id="ready-to-go-hands-on"><a class="header" href="#ready-to-go-hands-on"><em>Ready to go hands-on?</em></a></h4>
<p>Later in this book we will be writing real embedded code for real hardware, using one of many easily sourced and affordable development boards, such as the <a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3Discovery Board</a>, which is used in the Rust Embedded Book and is suitable for the exercises we will conduct here.</p>
<p>If you have a different development board, that's fine -- the examples are not really tied to any particular piece of  hardware, and only minor adjustments may be needed to adapt the instructions here to different hardware.</p>
<p>If you are new to embedded programming in Rust, you may find the guide and excercises in the
<a href="https://doc.rust-lang.org/stable/embedded-book/start">Rust Embedded Book</a> to be a great introduction.</p>
<p>Once we have learned the basic principles of how to use the Rust language in an embedded environment, and have set up the tooling, we are ready to move into the ODP framework to structure our designs.</p>
<p>Continue your journey with the <a href="intro/tutorial/./tutorial/Discovery.html">Discovery board</a>, which bridges familiar embedded projects and EC-style service structure.</p>
<h4 id="not-ready-to-go-hands-on"><a class="header" href="#not-ready-to-go-hands-on"><em><strong>Not</strong> ready to go hands-on?</em></a></h4>
<p>That's okay -- but you might want to look through this quick tutorial anyway because it contains key examples of the ODP construction patterns in practice.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="our-first-odp-style-handler-pair-with-faked-bus-semantics"><a class="header" href="#our-first-odp-style-handler-pair-with-faked-bus-semantics">Our first ODP-Style handler pair (with faked bus semantics)</a></h2>
<p>The microcontrollers used for Embedded Controller purposes are not the same ones used
in the example resources referenced by the Rust Book, but if you've started there then
you may already have a STM32F3 microcontroller Discovery board and you may have even played with it to blink the LED lights or some other exercises.</p>
<p>Let's build on what we already know from experimenting with the STM32F3 exercises from the Rust Book.</p>
<p>We already know we can use the tooling setup we have to write code for the STM32F3 that will light one of its LED displays when the user button is pressed.<br />
Code to do exactly that can be found in <a href="intro/tutorial/stm32f3-discovers/examples/button.rs">stm32f3-discovers/examples/button.rs</a> of the development board resources.</p>
<p>That code looks like this:</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;
use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::delay::Delay;
use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;

use stm32f3_discovery::button::UserButton;
use stm32f3_discovery::leds::Leds;
use stm32f3_discovery::switch_hal::{InputSwitch, OutputSwitch};

#[entry]
fn main() -&gt; ! {
    let device_periphs = pac::Peripherals::take().unwrap();
    let mut reset_and_clock_control = device_periphs.RCC.constrain();

    let core_periphs = cortex_m::Peripherals::take().unwrap();
    let mut flash = device_periphs.FLASH.constrain();
    let clocks = reset_and_clock_control.cfgr.freeze(&amp;mut flash.acr);
    let mut delay = Delay::new(core_periphs.SYST, clocks);

    // initialize user leds
    let mut gpioe = device_periphs.GPIOE.split(&amp;mut reset_and_clock_control.ahb);
    let leds = Leds::new(
        gpioe.pe8,
        gpioe.pe9,
        gpioe.pe10,
        gpioe.pe11,
        gpioe.pe12,
        gpioe.pe13,
        gpioe.pe14,
        gpioe.pe15,
        &amp;mut gpioe.moder,
        &amp;mut gpioe.otyper,
    );
    let mut status_led = leds.ld3;

    // initialize user button
    let mut gpioa = device_periphs.GPIOA.split(&amp;mut reset_and_clock_control.ahb);
    let button = UserButton::new(gpioa.pa0, &amp;mut gpioa.moder, &amp;mut gpioa.pupdr);

    loop {
        delay.delay_ms(50u16);

        match button.is_active() {
            Ok(true) =&gt; {
                status_led.on().ok();
            }
            Ok(false) =&gt; {
                status_led.off().ok();
            }
            Err(_) =&gt; {
                panic!("Failed to read button state");
            }
        }
    }
}</code></pre></pre>
<p>Of course, the STM32F3 is <em>not</em> an EC and we certainly would have little use for flashing lights on one if it were, but the basic process and principles are the same, and since we already know how to flash the lights, we can use this as a good way to show how and why the ODP framework fits into the scheme.</p>
<p>Let's first posit that the LED and the user button are two separate peripheral components.  As such, we probably want two separate ODP handlers to address these, and then some business logic to tie them together.  Let's start with the user button.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="addressing-the-user-button"><a class="header" href="#addressing-the-user-button">Addressing the user button</a></h3>
<p>The user button of the STM32F3 will trigger an interrupt signal that can be intercepted
by code to react to the button being pressed.</p>
<p>In the environment of an EC attached to an ACPI (or other transport) bus, the controller would be listening to / contributing to signals on that bus.</p>
<p>Recall our diagram of how EC components are attached to the bus through abstraction layers:</p>
<pre class="mermaid">flowchart TB
HW(Hardware) --&gt; ACPI(ACPI) --&gt; HAL(HAL) --&gt; Listener(Listener)
</pre>
<p>In this example, we‚Äôre not using an actual ACPI or I¬≤C bus, but we can simulate the idea of signal propagation and component decoupling using shared memory and interrupts.</p>
<p>We'll listen to the button interrupt and place a signal into a memory address that is accessible by both our button producer and our LED consumer.  This will take the place
of the ACPI for us here.  In later excercises we'll explore the mappings to the ACPI and the ASL layers in a real Embedded Controller environment.</p>
<p>So let's create that button producer code.  It will wait for the interrupt that signals the button action and it will set an
AtomicBool at a location in memory named USER_BUTTON_PRESSED that we can interrogate at the listener side.</p>
<h6 id="buttonhandlerrs"><a class="header" href="#buttonhandlerrs">ButtonHandler.rs</a></h6>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;

use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::interrupt;
use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;
use stm32f3_discovery::wait_for_interrupt;

use core::sync::atomic::{AtomicBool, Ordering};
use stm32f3_discovery::button;
use stm32f3_discovery::button::interrupt::TriggerMode;

use stm32f3_discovery::leds::Leds;
use stm32f3_discovery::switch_hal::ToggleableOutputSwitch;


// this will be imported into the listener code for direct visibility rather than transmitting through a bus
static USER_BUTTON_PRESSED: AtomicBool = AtomicBool::new(false);

#[interrupt]
fn EXTI0() {
    //If we don't clear the interrupt to signal it's been serviced, it will continue to fire.
    button::interrupt::clear();
    // pa0 has a low pass filter on it, so no need to debounce in software
    USER_BUTTON_PRESSED.store(true, Ordering::SeqCst);
}

fn main() -&gt; ! {

    button::interrupt::enable(
        &amp;device_periphs.EXTI,
        &amp;device_periphs.SYSCFG,
        TriggerMode::Rising,
    );

    loop {
        wait_for_interrupt()
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="provide-an-api-for-controlling-the-lights"><a class="header" href="#provide-an-api-for-controlling-the-lights">Provide an API for controlling the lights</a></h3>
<p>We now have a handler that will tell us when the user has pressed the button, but we still need a way to turn on the lights.
Continuing the theme of ODP-style modularity, we will declare an API for light control here.</p>
<h6 id="ledapirs"><a class="header" href="#ledapirs">LedApi.rs</a></h6>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>let mut status_led;

fn lights_init() -&gt; ! {
    let device_periphs = pac::Peripherals::take().unwrap();
    let mut reset_and_clock_control = device_periphs.RCC.constrain();

    // initialize user leds
    let mut gpioe = device_periphs.GPIOE.split(&amp;mut reset_and_clock_control.ahb);
    let leds = Leds::new(
        gpioe.pe8,
        gpioe.pe9,
        gpioe.pe10,
        gpioe.pe11,
        gpioe.pe12,
        gpioe.pe13,
        gpioe.pe14,
        gpioe.pe15,
        &amp;mut gpioe.moder,
        &amp;mut gpioe.otyper,
    );

    status_led = leds.ld3;

}

fn lights_on() {
    status_led.on().ok();
}

fn lights_off() {
    status_led.off().ok()
}


<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="tying-it-together"><a class="header" href="#tying-it-together">Tying it together</a></h3>
<p>We now have integrated a handler that will signal us when the button is pressed, and an API for turning on/off the lights. Let's complete the obvious logic and turn on/off the lights in response to the button.</p>
<h6 id="buttontoledservicers"><a class="header" href="#buttontoledservicers">ButtonToLedService.rs</a></h6>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

extern crate panic_itm;

use cortex_m_rt::entry;

use stm32f3_discovery::stm32f3xx_hal::prelude::*;
use stm32f3_discovery::stm32f3xx_hal::pac;
use stm32f3_discovery::wait_for_interrupt;
use stm32f3_discovery::stm32f3xx_hal::delay::Delay;

mod ButtonHandler; 
mod LedApi;


fn read_user_button() -&gt; bool {
    USER_BUTTON_PRESSED.load(Ordering::SeqCst)
}

#[entry]
fn main() -&gt; ! {

    lights_init()

    let mut delay = Delay::new(core_periphs.SYST, clocks);
    
    loop {
        // give system some breathing room for the interrupt to occur
        delay.delay_ms(50u16);

        // synchronize the light to the button state
        if read_user_button() {
            lights_on()
        } else {
            lights_off()
        }

    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-tracks-of-odp"><a class="header" href="#the-tracks-of-odp">The tracks of ODP</a></h1>
<p>ODP is a comprehensive umbrella addressing a span of firmware concerns:</p>
<ul>
<li>Boot Firmware / UEFI  (Patina)</li>
<li>Embedded Controller components and services (EC)</li>
<li>Security firmware and architecture</li>
</ul>
<p>Development efforts for these domains are often not performed by the same teams, and these pieces are often built independently of each other and only brought together in the end.</p>
<p>ODP does not usurp this development paradigm but rather empowers it further through the commonality of the Rust language and tools, and through a shared philosophy of modularity and agility.</p>
<h2 id="how-to-continue-with-this-book"><a class="header" href="#how-to-continue-with-this-book">How to continue with this book</a></h2>
<p>This book is geared to a couple of different distinct audiences.  If you are concerned primarily with any one of the particular 'tracks' of ODP and are interested in a guide to which ODP repositories are relevant for that track, continue with <a href="./what/what.html">What is in ODP?</a></p>
<p>If you are interested in examples of <em>how</em> to develop along any of these tracks, follow the examples in <a href="./laptop/laptop.html">Building a Virtual Laptop</a>, either those relevant to the topic of your interest alone, or follow the entire exercise to build a complete virtual laptop comprised of each of these elements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-in-odp"><a class="header" href="#what-is-in-odp">What is in ODP?</a></h1>
<p>There are over 60 repositories that make up the whole of the ODP umbrella.  Many of these are simply HAL definitions for particular hardware, but others define the critical business logic and data traits that comprise the portable and modular framework ODP provides.  Many of the crates defined by these repositories may be interdependent.
Other repositories represented here define tools and tests that are useful in development.</p>
<div class="table-wrapper"><table><thead><tr><th>Repository</th><th>Description</th><th>Patina</th><th>EC</th><th>Security</th><th>Tooling</th><th>Other</th></tr></thead><tbody>
<tr><td><a href="https://sturdy-adventure-nv32gqw.pages.github.io/">Developing UEFI with Rust</a></td><td><em>(Document)</em> An overview of using ODP Patina and Rust, how to contribute to ODP, and how to setup and build DXE Core components.</td><td>‚úÖ</td><td></td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/patina?tab=readme-ov-file#patina">patina</a></td><td>This maintains a library of crates that implement UEFI-like code in Rust. This defines all of the reusable</td><td>‚úÖ</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-dxe-core-qemu?tab=readme-ov-file#qemu-dxe-core-binaries">patina-dxe-core-qemu</a></td><td>This repository holds the code responsible for pulling in reusable Rust DXE Core components from the Patina SDK, combining these with locally defined custom components, and building the resulting <code>.efi</code> image that may be loaded into the QEMU emulator.</td><td>‚úÖ</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-qemu?tab=readme-ov-file#patina-platform-repository">patina-qemu</a></td><td>This repository supplies a platform wrapper that loads the <code>.efi</code> firmware into QEMU using EDK build tools (<code>stuart_build</code>) from the <code>.efi</code> file indicated at build time.</td><td>‚úÖ</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-fw-patcher?tab=readme-ov-file#firmware-rust-patcher">patina-fw-patcher</a></td><td>This repository simplifies the iterative turnaround for incremental builds in a workflow, once one has been established, able to forego the full <code>stuart_build</code> process for each code update.</td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-mtrr?tab=readme-ov-file#introduction">patina-mtrr</a></td><td>This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</td><td>‚úÖ</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-paging?tab=readme-ov-file#cpu-paging-support">patina-paging</a></td><td>Common paging support for various architectures such as ARM64 and X64</td><td>‚úÖ</td><td></td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-services?tab=readme-ov-file#ec-services">embedded_services</a></td><td>Business logic service definitions and code for wrapping and controlling HAL-level component definitions into a service context.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/soc-embedded-controller">soc-embedded-controller</a></td><td>Demonstration of EC firmware built using ODP components</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-batteries?tab=readme-ov-file#embedded-batteries">embedded-batteries</a></td><td>SmartBattery Specification support defining traits for HAL abstraction.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-sensors?tab=readme-ov-file#embedded-sensors">embedded-sensors</a></td><td>Defines the embedded sensors interface for HAL abstraction. Designed for use with <code>embedded-services</code>.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-fans?tab=readme-ov-file#embedded-fans">embedded-fans</a></td><td>HAL definition for fan control. Designed for use with <code>embedded-services</code>.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-power-sequence?tab=readme-ov-file#embedded-power-sequence">embedded-power-sequence</a></td><td>Abstraction of SoC power on/off via firmware control.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-cfu?tab=readme-ov-file#embedded-cfu">embedded-cfu</a></td><td>Implements commands and responses as structs per the Windows CFU spec.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-usb-pd?tab=readme-ov-file#embedded-usb-pd">embedded-usb-pd</a></td><td>common types for usb pd.  May be necessary as a dependency for several <code>embedded-services</code> builds.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-mcu?tab=readme-ov-file#embedded-mcu">embedded-mcu</a></td><td>an agnostic set of MCU-related traits and libraries for manipulating hardware peripherals in a generic way.</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/hid-embedded-controller?tab=readme-ov-file#hid-embedded-controller">hid-embedded-controller</a></td><td>Embedded Controller HID library / HID over I2C demo</td><td></td><td>‚úÖ</td><td></td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ec-test-app?tab=readme-ov-file#ec-test-app">ec-test-app</a></td><td>Test application to exercise EC functionality through ACPI from the OS</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ffa?tab=readme-ov-file#ff-a-firmware-framework-for-armv8-a-profile">ffa</a></td><td>FFA for Rust services running under Hafnium through FF-A</td><td></td><td>‚úÖ</td><td>‚úÖ</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/haf-ec-service?tab=readme-ov-file#hafnium-ec-service-in-rust">haf-ec-service</a></td><td>Rust services for Hafnium supported EC architectures.</td><td></td><td>‚úÖ</td><td>‚úÖ</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-mtrr?tab=readme-ov-file#introduction">patina-mtrr</a></td><td>This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</td><td>‚úÖ</td><td></td><td>‚úÖ</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/openDevicePartnership/patina-paging?tab=readme-ov-file#cpu-paging-support">patina-paging</a></td><td>Common paging support for various architectures such as ARM64 and X64</td><td>‚úÖ</td><td></td><td>‚úÖ</td><td></td><td></td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/rust-crate-audits?tab=readme-ov-file#open-device-partnerships-rust-crate-audits">rust_crate_audits</a></td><td>Aggregated audits for Rust crates by the Open Device Partnership</td><td></td><td></td><td>‚úÖ</td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/uefi-bds">uefi-bds</a></td><td>UEFI Boot Device Selection DXE driver</td><td>‚úÖ</td><td></td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/uefi-corosensei">uefi-corosensei</a></td><td>UEFI fork of the corosensei crate</td><td>‚úÖ</td><td></td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/modern-payload">modern-payload</a></td><td>Slimmed down UEFI payload</td><td>‚úÖ</td><td></td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/slimloader">slimloader</a></td><td>First stage boot loader for AArch64</td><td>‚úÖ</td><td></td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/ec-slimloader">ec-slimloader</a></td><td>A light-weight stage-one bootloader for loading an app image as configured by ec-slimloader-descriptors</td><td>‚úÖ</td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/name">ec-slimloader-descriptors</a></td><td>Boot-time application image management descriptors for enabling multi-image firmware boot scenarios, such as those provided by CFU</td><td>‚úÖ</td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/odp-utilites">odp-utilites</a></td><td>A collection of Rust utilities focused on embedded systems development.</td><td></td><td></td><td></td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/systemview-tracing">systemview-tracing</a></td><td>Support for adding Segger SystemView tracing to ODP projects</td><td></td><td></td><td></td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/nxp-header">nxp-header</a></td><td>CLI utility to modify binary firmware image file to add NXP image header</td><td></td><td></td><td></td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq24773">bq24773</a></td><td>Driver for TI BQ24773 battery charge controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25713">bq25713</a></td><td>Driver for TI BQ25713 battery charge controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25730">bq25730</a></td><td>Driver for TI BQ25730 battery charge controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25770g">bq25770g</a></td><td>Driver for TI BQ2577G battery charge controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq25773">bq25773</a></td><td>Driver for TI BQ25773 battery charge controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/bq40z50">bq40z50</a></td><td>Driver for TI BQ40Z50 Li-ion battery pack manager</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tmp108">tmp108</a></td><td>Driver for TI TMP108 digital temperature sensor</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/cec17-data">cec17-data</a></td><td>Single meta-PAC supporting all variants within the MEC/CEC family of MCUs produced by Microchip</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mec17xx-pac">mec17xx-pac</a></td><td>Peripheral Access Crate (PAC) for the Microchip MEC17xx family of MCUs</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt633s-pac">mimxrt633s-pac</a></td><td>Embedded PAC for NXP RT633s MCU</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt685s-pac">mimxrt685s-pac</a></td><td>Rust PAC created with svd2rust for MIMXRT685s family of MCUs</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt685s-examples">mimxrt685s-examples</a></td><td>Collection of examples demonstrating the use of the mimxrt685s-pac crate</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/npcx490m-pac">npcx490m-pac</a></td><td>Embedded PAC for Nuvoton NPCX490M MCU</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/npcx490m-examples">npcx490m-examples</a></td><td>Examples for Nuvoton NPCX490M Embedded PAC</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-regulator">embedded-regulator</a></td><td>Embedded HAL for system voltage regulators</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embedded-keyboard-rs">embedded-keyboard-rs</a></td><td>Driver for embedded system matrix keyboards</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/rt4531">rt4531</a></td><td>Driver for Richtek RT4531 keyboard backlight controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tps65994ae">tps65994ae</a></td><td>Driver for TI TPS65994AE USB-C power delivery controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/tps6699x">tps6699x</a></td><td>Driver for TI TPS6699x USB-C power delivery controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/is31fl3743b">is31fl3743b</a></td><td>Driver for Lumissil IS31FL3743B LED matrix controller</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/pcal6416a">pcal6416a</a></td><td>Rust driver for IO Expander pcal6416a</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-imxrt">embassy-imxrt</a></td><td>Embassy HAL for NXP IMXRT MCU family</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-microchip">embassy-microchip</a></td><td>Embassy HAL for Microchip MEC17xx and MEC16xx series MCUs</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/embassy-npcx">embassy-npcx</a></td><td>Embassy HAL for Nuvoton NPCX MCU family</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/lis2dw12-i2c">lis2dw12-i2c</a></td><td>Rust driver for STMicroelectronics LIS2DW12 accelerometer</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/mimxrt600-fcb">mimxrt600-fcb</a></td><td>Flash Control Block for MIMXRT600 MCUs</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
<tr><td><a href="https://github.com/OpenDevicePartnership/MX25U1632FZUI02">MX25U1632FZUI02</a></td><td>Rust based driver for flash part MACRONIX/MX25U1632FZUI02</td><td></td><td>‚úÖ</td><td></td><td></td><td>‚úÖ</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-build-a-modern-laptop-using-odp"><a class="header" href="#how-to-build-a-modern-laptop-using-odp">How To Build A Modern Laptop using ODP</a></h1>
<p>This section will present a series of practical examples for creating ODP components for the embedded controller using a commodity-level development board to serve as an ersatz MCU SoC, and implementing a Patina DXE Core and bootloader to start up an operating system on a QEMU host that communicates with the EC. This is done through a series of practical exercises that stand alone as development examples, and come together in the end to create a credible, working integration.</p>
<p>These exercises will:</p>
<ul>
<li>build components for the embedded controller
<ul>
<li>battery, charger and power policy</li>
<li>thermal and sensors</li>
<li>connectivity</li>
<li>security architectures</li>
</ul>
</li>
<li>build components for the DXE Core
<ul>
<li>example component</li>
<li>firmware security</li>
<li>EC coordination</li>
</ul>
</li>
<li>integrate the components into a system
<ul>
<li>set up QEMU as a virtual host</li>
<li>use Patina firmware to boot this virtual host into Windows</li>
<li>coordinate between the boot firmware and the embedded controller</li>
<li>use runtime services to interact with EC services</li>
<li>implement and explore security firmware and architectures</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-development"><a class="header" href="#setting-up-development">Setting up Development</a></h1>
<p>If you are planning on going through these exercises to get a handle on developing components for Patina or the Embedded Controller, you will not need anything more than the Rust toolchain and development tools already described.  You can
build each of the exercises to construct a component in a non-embedded (std) environment and test on your local machine.</p>
<p>However, if you are planning on building for the virtual laptop project, you will need to set up QEMU as the host for the Patina boot firmware, and for EC Components, you will need a development board where you will target your embedded code to run on as a makeshift Embedded Controller.</p>
<p><a href="how/./qemu/qemu_setup_guide.html">QEMU Setup Guide</a></p>
<p><a href="how/...">Embedded Setup Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller-components"><a class="header" href="#embedded-controller-components">Embedded Controller Components</a></h1>
<p><em>TODO</em></p>
<p>The Embedded Controller topic comes first, because this is where most of the modern features live and when we get to Patina, it will need to wait for this to be ready and then also connect to it for certain runtime operations.</p>
<p>Basic idea is to reference the Battery effort currently in place, and the soon to follow Charger and Thermal examples.  This should provide a pretty good blueprint for building a mock or real EC for these components and inspire the pattern for things not covered by the examples.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-and-power-management"><a class="header" href="#battery-and-power-management">Battery and Power Management</a></h1>
<p>This example shows how to implement a mock battery service as part of the Embedded Controller (EC) power management system.</p>
<p>In this sample, we are going to implement a complete battery service subsystem.</p>
<h2 id="relevant-repositories"><a class="header" href="#relevant-repositories">Relevant Repositories</a></h2>
<p>We don't need to reinvent any wheels here. The ODP resources include ample template code and examples we can refer to for such a task. It is useful to identify which repositories contain these resources:</p>
<h3 id="embedded-services"><a class="header" href="#embedded-services">embedded-services</a></h3>
<p>We've touched on this before in <a href="how/ec/battery/../embedded_services/index.html">Embedded Services</a>, where we examined a Thermal subsystem implementation and explored variations between secure ARM-based and legacy x86_64-based systems.</p>
<p>We'll return to both of these concepts later. For now, we‚Äôll focus on implementing a Battery subsystem and related Power Policy services. After that, we‚Äôll fold in Thermal support and revisit the secure vs. non-secure implementations.</p>
<h3 id="embedded-batteries"><a class="header" href="#embedded-batteries">embedded-batteries</a></h3>
<p>This repository defines the Hardware Abstraction Layer (HAL) for a battery, tailored to the specific IC hardware being targeted. It builds a layered API chain upward, making most of the code portable and reusable across different integrations.</p>
<h3 id="embassy"><a class="header" href="#embassy">embassy</a></h3>
<p>Although our first exercises will be limited to simple desktop tests, we will then be building for an embedded context and that will require us to use features from <a href="https://embassy.dev/">Embassy</a> both directly and indirectly.</p>
<h3 id="soc-embedded-controller"><a class="header" href="#soc-embedded-controller">soc-embedded-controller</a></h3>
<p>This repository provides the core EC functionality, which in this case is centered around power policy and regulation.</p>
<p>We will refer to this later as we work on our own (virtual) battery service implementation.</p>
<p>We‚Äôll begin with the battery service ‚Äî one of the embedded services ‚Äî and later return here to integrate our battery into the broader scope of power management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goals-of-the-battery-component-example"><a class="header" href="#goals-of-the-battery-component-example">Goals of the Battery Component Example</a></h1>
<p>In this example we will be constructing a fucntioning battery component.</p>
<p>The battery itself will be a virtual battery - no hardware required - and the behavioral aspects of it will be simulated.
We will, however, discuss what one would do to implement actual battery hardware control in a HAL layer, which is the only
fundamental difference between the virtual and real-world manifestations of this component.</p>
<p>In this example, we will:</p>
<ul>
<li>Define the Traits of the battery component as defined by the industry standard Smart Battery Specification (SBS)</li>
<li>Identify the hardware actions that fulfill these traits</li>
<li>Define the HAL traits to match these hardware actions</li>
<li>Implement the HAL traits to hardware access (or define mocks for a virtual example)</li>
<li>Wrap this simple Traits implementation into a Device for service insertion</li>
<li>Provide the service layer and insert the device into it</li>
<li>Test the end result with unit tests and simple executions</li>
<li>Update the project for an embedded build and deploy onto hardware.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-we-will-build-the-battery-component"><a class="header" href="#how-we-will-build-the-battery-component">How we will build the Battery Component</a></h1>
<p>Like most components, the battery starts with a definition, or specification.  Most common components have industry-standard specifications associated with them.  For the battery, we have the Smart Battery Specification (SBS).</p>
<hr />
<h3 id="the-smart-battery"><a class="header" href="#the-smart-battery">The Smart Battery</a></h3>
<p>Batteries are ubiquitous in today‚Äôs portable devices. With many types of batteries serving various applications and provided by many vendors, the <a href="https://sbs-forum.org/specs/sbdat110.pdf">Smart Battery Data Specification</a> offers a standard to normalize this diversity.</p>
<p>Published by the Smart Battery System Implementers Forum (SBS-IF), this specification defines both electrical characteristics and ‚Äî more importantly for us ‚Äî the data and communication semantics of battery state.</p>
<p>Let's explore how this specification informs our implementation.</p>
<h4 id="battery-information"><a class="header" href="#battery-information">Battery Information</a></h4>
<p>A battery provides dynamic information (e.g., remaining charge), static metadata (e.g., make/model/serial/version), and operational parameters (e.g., recommended charge voltage/current).</p>
<p>As explored in <a href="how/ec/battery/...">...</a>, some of this information is exposed through direct hardware interfaces (e.g., GPIO or MMIO), while others originate from firmware logic or are derived dynamically.</p>
<p>Batteries typically report their state over a bus when queried and may also broadcast alarms when thresholds are breached.</p>
<p>The SBS specification outlines these functions that a smart battery should implement. These define a consistent set of data points and behaviors that other power management components can rely on:</p>
<ul>
<li><code>ManufacturerAccess</code> ‚Äì Optional, manufacturer-specific 16-bit value.</li>
<li><code>RemainingCapacityAlarm</code> ‚Äì Battery capacity threshold at which an alert should be raised.</li>
<li><code>RemainingTimeAlarm</code> ‚Äì Estimated time remaining before an alert should be raised.</li>
<li><code>BatteryMode</code> ‚Äì Flags indicating operational states or supported features.</li>
<li><code>AtRate</code> ‚Äì Charging/discharging rate used in subsequent time estimations.</li>
<li><code>AtRateTimeToFull</code> ‚Äì Time to full charge at the given rate.</li>
<li><code>AtRateTimeToEmpty</code> ‚Äì Time to depletion at the given rate.</li>
<li><code>AtRateTimeOK</code> ‚Äì Whether the battery can sustain the given rate for at least 10 seconds.</li>
<li><code>Temperature</code> ‚Äì Battery temperature.</li>
<li><code>Voltage</code> ‚Äì Battery voltage.</li>
<li><code>Current</code> ‚Äì Charge or discharge current.</li>
<li><code>AverageCurrent</code> ‚Äì One-minute rolling average of current.</li>
<li><code>MaxError</code> ‚Äì Expected error margin in charge calculations.</li>
<li><code>RelativeStateOfCharge</code> ‚Äì % of full charge capacity remaining.</li>
<li><code>AbsoluteStateOfCharge</code> ‚Äì % of design capacity remaining.</li>
<li><code>RemainingCapacity</code> ‚Äì In mAh or Wh, based on a capacity mode flag.</li>
<li><code>FullChargeCapacity</code> ‚Äì In mAh or Wh, based on capacity mode.</li>
<li><code>RunTimeToEmpty</code> ‚Äì Estimated minutes remaining.</li>
<li><code>AverageTimeToEmpty</code> ‚Äì One-minute average of minutes to empty.</li>
<li><code>AverageTimeToFull</code> ‚Äì One-minute average of minutes to full charge.</li>
<li><code>BatteryStatus</code> ‚Äì Flags indicating current state conditions.</li>
<li><code>CycleCount</code> - Number of cycles (a measure of wear). A cycle is the amount of discharge approximately equal to the value of the DesignCapacity.</li>
<li><code>DesignCapacity</code> - The theoretical capacity of a new battery pack.</li>
<li><code>DesignVoltage</code> - The theoritical voltage of a new battery pack.</li>
<li><code>SpecificationInfo</code> - Version and scaling specification info</li>
<li><code>ManufactureDate</code> - The data of manufacture as a bit-packed integer</li>
<li><code>SerialNumber</code> - the manufacturer assigned serial number of this battery pack.</li>
<li><code>ManufacturerName</code> - Name of the manufacturer</li>
<li><code>DeviceName</code> - Name of battery model.</li>
<li><code>DeviceChemistry</code> - String defining the battery chemical type</li>
<li><code>ManufacturerData</code> - (optional) proprietary manufacturer data.</li>
</ul>
<p>Please refer to the actual specification for details.  For example, functions referring to capacity may report in either current (mAh) or wattage (Wh) depending upon the current state of the CAPACITY_MODE flag (found in BatteryMode).</p>
<p>Some systems may support removable batteries, and such conditions must be accounted for in those designs.</p>
<hr />
<p>In the next steps, we will use the ODP published crates that expose this SBS defnition as a Trait and build our implementation on top of that starting point.</p>
<p>We will implement the mock values and behaviors of our simulated battery - instead of defining and building a HAL layer -
and then we will walk through the process of attaching this component definition to a Device wrapper and registering it
as a component with a Controller that can be manipulated by a service layer - in this case, the Power Policy Service.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-component-diagrams"><a class="header" href="#battery-component-diagrams">Battery component Diagrams</a></h1>
<p>The construction of a component such as our battery looks as follows.</p>
<pre class="mermaid">flowchart TD
    A[Power Policy Service&lt;br&gt;&lt;i&gt;Service initiates query&lt;/i&gt;]
    B[Battery Subsystem Controller&lt;br&gt;&lt;i&gt;Orchestrates component behavior&lt;/i&gt;]
    C[Battery Component Trait Interface&lt;br&gt;&lt;i&gt;Defines the functional contract&lt;/i&gt;]
    D[Battery HAL Implementation&lt;br&gt;&lt;i&gt;Implements trait using hardware-specific logic&lt;/i&gt;]
    E[EC / Hardware Access&lt;br&gt;&lt;i&gt;Performs actual I/O operations&lt;/i&gt;]

    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E

    subgraph Service Layer
        A
    end

    subgraph Subsystem Layer
        B
    end

    subgraph Component Layer
        C
        D
    end

    subgraph Hardware Layer
        E
    end
</pre>
<p>When in operation, it conducts its operations in response to message events</p>
<pre class="mermaid">sequenceDiagram
    participant Service as Power Policy Service
    participant Controller as Battery Subsystem Controller
    participant Component as Battery Component (Trait)
    participant HAL as Battery HAL (Hardware or Mock)

    Service-&gt;&gt;Controller: query_battery_state()
    Note right of Controller: Subsystem logic directs call via trait
    Controller-&gt;&gt;Component: get_battery_state()
    Note right of Component: Trait implementation calls into HAL
    Component-&gt;&gt;HAL: read_charge_level()
    HAL--&gt;&gt;Component: Ok(82%)
    Component--&gt;&gt;Controller: Ok(BatteryState { charge_pct: 82 })
    Controller--&gt;&gt;Service: Ok(BatteryState)

    alt HAL returns error
        HAL--&gt;&gt;Component: Err(ReadError)
        Component--&gt;&gt;Controller: Err(BatteryError)
        Controller--&gt;&gt;Service: Err(BatteryUnavailable)
    end

</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-component"><a class="header" href="#building-the-component">Building the component</a></h1>
<p>Let's get started on building our battery implementation</p>
<h2 id="a-mock-battery"><a class="header" href="#a-mock-battery">A Mock Battery</a></h2>
<p>In our example, we will build the full functionality of our component in a standard local-computer development environment.</p>
<p>This allows us to begin development without worrying about hardware complications while still implementing nearly all of the system‚Äôs behavior. In the end, we will have a fully functional‚Äîalbeit artificial‚Äîbattery subsystem.</p>
<p>Once complete, our battery implementation is ready to be flashed and tested on the target embedded hardware, where it should behave identically.</p>
<p>If in this step we had actual battery hardware to attach to, we would replace our mock implmentations at the HAL layer with actual hardware bindings.</p>
<p>In our example case, our battery will remain virtual, and can continue to serve its simulated purpose when integrated as part of the 'virtual laptop' project later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mock-battery-project"><a class="header" href="#a-mock-battery-project">A Mock Battery Project</a></h1>
<p>In the previous section, we saw how the <em>Smart Battery Specification (SBS)</em> defines a set of functions that a Smart Battery service should implement.</p>
<p>In this section, we are going to review how these traits are defined in Rust within the <a href="https://github.com/OpenDevicePartnership/embedded-services/">embedded-services repository</a>, and we are going to import these structures into our own workspace as we build our mock battery.
In subsequent sections we'll connect the battery into the supporting upstream EC service framwork.</p>
<h2 id="setting-up-for-development"><a class="header" href="#setting-up-for-development">Setting up for development</a></h2>
<p>We are going to create a project space that contains a folder for our battery code, and the dependent repository clones.</p>
<p>So, start by finding a suitable location on your local computer and create the workpace:</p>
<pre><code>mkdir battery_project
cd battery_project
git init
</code></pre>
<p>This will create a workspace root for us and establish it as a git repository (not attached).</p>
<p>Now, we are going to bring the embedded-batteries directory
into our workspace and build the crates it exports.</p>
<p><em>(from the <code>battery_project</code> directory):</em></p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-batteries
</code></pre>
<p>Now, we can create our project space and start our own work.  Within the battery_project directory, create a folder named mock_battery and give it this project structure:</p>
<pre><code>mock_battery/
  src/ 
   - lib.rs
   - mock_battery.rs
  Cargo.toml 
  
Cargo.toml  
</code></pre>
<p>note there are two <code>Cargo.toml</code> files here. One is within the <code>battery_project</code> root folder and the other is at the root of <code>mock_battery</code>.  The <code>mock_battery.rs</code> file resides within the <code>mock_battery/src</code> directory.</p>
<p>The contents of the <code>battery_project/Cargo.toml</code> file should contain:</p>
<pre><code>[workspace]
resolver = "2"
members = [
    "mock_battery"
]

</code></pre>
<p>and the contents of the <code>battery_project/mock_battery/Cargo.toml</code> file should be set to:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
</code></pre>
<p>This structure and the <code>Cargo.toml</code> definitions just define a minimal skeleton for the dependencies we will be adding to as we continue to build our mock battery implementation and work it into the larger ODP framework.</p>
<p>The <code>lib.rs</code> file is used to tell Rust which modules are part of the project. Set it's contents to:</p>
<pre><code>pub mod mock_battery;
</code></pre>
<p>the <code>mock_battery.rs</code> file can be empty for now.  We will define its contents in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-odp-repositories-for-defined-battery-traits"><a class="header" href="#using-the-odp-repositories-for-defined-battery-traits">Using the ODP repositories for defined Battery Traits</a></h1>
<p>In the previous step we set up our project workspace so that we can import from the ODP framework. In this step we will define the traits that our mock battery will expose.</p>
<h1 id="implementing-the-defined-traits"><a class="header" href="#implementing-the-defined-traits">Implementing the defined traits</a></h1>
<p>From the overview discussion you will recall that the SBS specification defines the Smart Battery with a series of functions that will return required data in expected ways.
Not surprisingly, then, we will find that the embedded-batteries crate we have imported defines these functions as traits to a SmartBattery trait.  If you are new to Rust, recall that if this were, say, C++ or Java, we would call this the SmartBattery <em>class</em>, or an <em>interface</em>.  These are <em>almost</em> interchangeable terms, but there are differences.  See <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">this definition</a> for more detail on that.</p>
<p>If we look through the <code>embedded-batteries</code> repository, we will see the SmartBattery trait defines the same functions we saw in the specification (except for the optional proprietary manufacturer facilitations).</p>
<p>So our job now is to implement these functions with data that comes from our battery - our Mock Battery.</p>
<p>We'll start off our <code>mock_battery.rs</code> file with this:</p>
<pre><code>use embedded_batteries::smart_battery::{
    SmartBattery, CapacityModeValue, CapacityModeSignedValue, BatteryModeFields,
    BatteryStatusFields, SpecificationInfoFields, ManufactureDate, ErrorType, 
    ErrorKind
};

#[derive(Debug)]
pub enum MockBatteryError {}

impl core::fmt::Display for MockBatteryError {
    fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
        write!(f, "MockBatteryError")
    }
}

use embedded_batteries::smart_battery::Error;

impl Error for MockBatteryError {
    fn kind(&amp;self) -&gt; ErrorKind {
        ErrorKind::Other
    }    
}

pub struct MockBattery;

impl ErrorType for MockBattery {
    type Error = MockBatteryError;
}

impl SmartBattery for MockBattery {
    fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    fn set_remaining_capacity_alarm(&amp;mut self, _val: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn set_remaining_time_alarm(&amp;mut self, _val: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::default())
    }

    fn set_battery_mode(&amp;mut self, _val: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    fn set_at_rate(&amp;mut self, _val: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    fn temperature(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2950) // 29.5¬∞C in deciKelvin
    }

    fn voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7500) // mV
    }

    fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1500)
    }

    fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1400)
    }

    fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(1)
    }

    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }

    fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(85)
    }

    fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4200))
    }

    fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4800))
    }

    fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(60)
    }

    fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(75)
    }

    fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(30)
    }

    fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2000)
    }

    fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(8400)
    }

    fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::default())
    }

    fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(100)
    }

    fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(5000))
    }

    fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7800)
    }

    fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::default())
    }

    fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(12345)
    }

    fn manufacturer_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MockBatteryCorp";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MB-4200";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_chemistry(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"Li-Ion";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }
}

</code></pre>
<p>Yes, that's a bit long, but it's not particularly complex.
We'll unpack what all this is in a moment.  For now, let's verify this Rust code is valid and that we've imported from the ODP repository properly.</p>
<p>Type</p>
<pre><code>cargo build
</code></pre>
<p>at the project root.
This should build without error.</p>
<h2 id="whats-in-there"><a class="header" href="#whats-in-there">What's in there</a></h2>
<p>The code in <code>mock_battery.rs</code> starts out with a <code>use</code> statement that imports what we will need from the <code>embedded-batteries::smart_battery</code> crate.</p>
<p>The next section defines a simple custom error type for use in our mock battery implementation. This MockBatteryError enum currently has no variants ‚Äî it serves as a placeholder that allows our code to conform to the expected error traits used by the broader embedded_batteries framework.</p>
<p>By implementing core::fmt::Display, we ensure that error messages can be printed in a readable form (here, just "MockBatteryError"). Then, by implementing the embedded_batteries::smart_battery::Error trait, we allow this error to be returned in contexts where the smart battery interface expects a well-formed error object. The .kind() method returns ErrorKind::Other to indicate a generic error category.</p>
<p>This scaffolding allows our mock implementation to slot into the service framework cleanly, even if the actual logic is still forthcoming.</p>
<p>Finally, we get to the SmartBattery implementation for our MockBattery.  As you might guess, this simply implements each of the functions of the trait as declared, by simply returning an arbitrary representative return value for each.  We'll make these values more meaningful later, but for now, it's pretty minimalist.</p>
<h2 id="now-to-expose-this-to-the-service"><a class="header" href="#now-to-expose-this-to-the-service">Now to expose this to the service</a></h2>
<p>We have defined the battery traits and given our simulated placeholder values for our mock battery here.
If we were implementing a real battery, the process would follow the same pattern except that instead of the literal values we've assigned, we would
call upon our Hardware Abstraction Layer (HAL) implementation modules to pull these values from the actual hardware circuitry, per manufacturer design (i.e. GPIO or MMIO).
But before any of this is useful, it needs to be exposed to the service layer.  In the next step, we'll do a simple test that shows we can expose these values, and then we'll implement the service layer that conveys these up the chain in response to service messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-values"><a class="header" href="#battery-values">Battery values</a></h1>
<p>In the previous step, we defined the traits of our mock battery.  In this step, we will begin to implement the service layer that defines the messaging between the battery and the controller controller service.</p>
<p>Before we implement the actual service, however, let's write a quick test/example to illustrate these values being extracted from our battery traits.</p>
<h2 id="create-mainrs-file-for-mock_battery"><a class="header" href="#create-mainrs-file-for-mock_battery">Create main.rs file for mock_battery</a></h2>
<p>In your mock_battery project create <code>src/main.rs</code> with this content:</p>
<pre><code>use mock_battery::mock_battery::MockBattery;
use embedded_batteries::smart_battery::SmartBattery;

fn main() {
    let mut battery = MockBattery;

    let voltage = battery.voltage().unwrap();
    let soc = battery.relative_state_of_charge().unwrap();
    let temp = battery.temperature().unwrap();

    println!("Voltage: {} mV", voltage);
    println!("State of Charge: {}%", soc);
    println!("Temperature: {} deci-K", temp);
}
</code></pre>
<p>and type <code>cargo run</code> to build and execute it.
After it builds and runs successfully, you should see output similar to this:</p>
<pre><code>Voltage: 7500 mV
State of Charge: 88%
Temperature: 2950 deci-K
</code></pre>
<p>Note that you can execute <code>Cargo run</code> in this case both from either the <code>battery_project/mock_battery</code> or <code>battery_project</code> directories.<br />
As we continue with the integration, we will only be able to build and execute from the <code>battery_project</code> root, so you may want to get used to running from there.</p>
<p>We're going to replace this main.rs very shortly in an upcoming step, and this print to console behavior will be removed.  But for now it's a good sanity check of what you have built so far.
Later, we'll turn checks like this into meaningful unit tests.</p>
<p>We'll move ahead with forwarding this information up to the battery service controller,
but for now, pat yourself on the back, pour yourself a cup of coffee, and take a moment to review the pattern you have walked through:</p>
<ul>
<li>Identified the traits needed for the battery per spec as reflected in the <code>SmartBattery</code> trait imported from the ODP embedded-batteries repository</li>
<li>Implemented a HAL layer to retrieve these values from the hardware (We conveniently skipped this part because this is a mock battery)</li>
<li>Implemented the traits to return these values per the <code>SmartBattery</code> trait</li>
<li>Created a simple sanity check to prove these values are available at runtime.</li>
</ul>
<p>Next, we'll look at the ODP embedded-services repository and the battery-service support we find there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-preparation"><a class="header" href="#battery-service-preparation">Battery Service Preparation</a></h1>
<hr />
<p><em>TODO:
This section needs to be revisited and rewritten to support a successful 'standard' build - earlier attempts at
including some of the dependencies in a std environment failed, and so this was written to build for the embedded target
at this premature phase.  We want to build the battery complete before switching to the embedded context though.</em></p>
<hr />
<p>We've successfully exposed and proven our implementation of battery traits and their values for our mock battery,
and built for an embedded target.
In this step, we'll continue our integration by connecting to a battery service, but that requires some setup to cover first.</p>
<h2 id="battery-service"><a class="header" href="#battery-service">Battery-service</a></h2>
<p>The ODP repository <code>embedded-services</code> has the <code>battery-service</code> we need for this, as well as the power-policy infracture support that uses it.</p>
<p>The ODP repository <code>embedded-cfu</code> is also needed here,
as is <code>embedded-usb-pd</code>.</p>
<p>We will bring these into our scope now.</p>
<p>In the <code>battery_project</code>, we'll bring these in with the commands:</p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-services

git submodule add git@github.com:OpenDevicePartnership/embedded-cfu

git submodule add git@github.com:OpenDevicePartnership/embedded-usb-pd

</code></pre>
<h3 id="a-mock-battery-device"><a class="header" href="#a-mock-battery-device">A Mock Battery Device</a></h3>
<p>To fit the design of the ODP battery service, we first need to create a wrapper that contains our MockBattery and a Device Trait.  We need to implement <code>DeviceContainer</code> for this wrapper and reference that <code>Device</code>.
Then we will register the wrapper with <code>register_device(...)</code> and we will have an async loop that awaits commands on the <code>Device</code>'s <code>channel</code>, executes them, and updates state.</p>
<h4 id="import-the-battery-service-from-the-odp-crate"><a class="header" href="#import-the-battery-service-from-the-odp-crate">Import the battery-service from the ODP crate</a></h4>
<p>One of the service definitions from the <code>embedded-services</code> repository we brought into scope is the <code>battery-service</code>.
We now need to update our Cargo.toml to know where to find it.
Open the <code>Cargo.toml</code> file of your mock-battery project and add the dependency to the battery-service path to our Cargo.toml.  We will also need a reference to <code>embedded-services</code> itself for various support needs.  Update your <code>mock_battery/Cargo.toml</code> so that your <code>[dependencies]</code> section now looks like this:</p>
<pre><code>[dependencies]
cortex-m-rt = "0.7.3"
static_cell = "2.0.0"
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embedded-batteries-async = { path = "../embedded-batteries/embedded-batteries-async" }
battery-service = { path = "../embedded-services/battery-service" }
embedded-services = { path = "../embedded-services/embedded-service" }
</code></pre>
<p>This will allow us to import what we need for the next steps.</p>
<h3 id="define-the-mockbatterydevice-wrapper"><a class="header" href="#define-the-mockbatterydevice-wrapper">Define the MockBatteryDevice wrapper</a></h3>
<p>In your mock_battery project <code>src</code> folder, create a new file named <code>mock_battery_device.rs</code> and give it this content:</p>
<pre><code>use crate::mock_battery::MockBattery;
use embedded_services::power::policy::DeviceId;
use embedded_services::power::policy::action::device::AnyState;
use embedded_services::power::policy::device::{
    Device, DeviceContainer, CommandData, ResponseData//, State
};
// use embedded_services::intrusive_list::Node;


pub struct MockBatteryDevice {
    #[allow(dead_code)] // Prevent unused warning for MockBattery -- not used yet   
    battery: MockBattery,
    device: Device,
}

impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }

    pub fn device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }

    pub async fn run(&amp;self) {
        loop {
            let cmd = self.device.receive().await;

            // Access command using the correct method
            let request = &amp;cmd.command; 

            match request {
                CommandData::ConnectConsumer(_cap) =&gt; {
                    // println!("Received ConnectConsumer for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    // Safe placeholder: detach any existing state
                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::ConnectProvider(_cap) =&gt; {
                    // println!("Received ConnectProvider for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::Disconnect =&gt; {
                    // println!("Received Disconnect");

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; {
                            // println!("Already disconnected or idle");
                        }
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }
            }
        }
    }
}

impl DeviceContainer for MockBatteryDevice {
    fn get_power_policy_device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }
}
</code></pre>
<p>What we've done here is:</p>
<ul>
<li>
<p>Imported what we need from the ODP repositories for both the SmartBattery definition from <code>embedded-batteries</code> and the battery service components from <code>embedded-services</code> crates as as our own local MockBattery definition.</p>
</li>
<li>
<p>Define and implement our MockBatteryDevice</p>
</li>
<li>
<p>implement a run loop for our MockBatteryDevice</p>
</li>
</ul>
<p>Note also there are some commented-out <code>println!</code> macros. We can't use <code>println!</code> in our embedded context, but we'll deal with that later. For now these comments serve as placeholders.</p>
<h4 id="including-mock_battery_device"><a class="header" href="#including-mock_battery_device">Including mock_battery_device</a></h4>
<p>Just like we had to inform the build of our mock_battery, we need to do likewise with mock_battery_device.  So edit <code>lib.rs</code> and to this:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
</code></pre>
<p><strong>Important</strong>: Note that we also added <code>#![no_std]</code> at the top of this <code>lib.rs</code> file.  This is necessary to insure that our build is not expecting the defaults from std to be available.</p>
<h4 id="updating-the-dependencies"><a class="header" href="#updating-the-dependencies">Updating the dependencies</a></h4>
<p>We now must make some edits to our top-level <code>battery_project/Cargo.toml</code> file to reflect the new dependencies.</p>
<p>Add the references to our embedded-services dependencies to <code>members</code> list of the <code>[workspace]</code> section so it now has all our new members:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embedded-batteries/embedded-batteries-async",
    "embedded-services/embedded-service",
    "embedded-services/battery-service",
    "embedded-cfu",
    "embedded-usb-pd",
    "embassy/embassy-executor",
    "embassy/embassy-futures",
    "embassy/embassy-sync",
    "embassy/embassy-time",
    "embassy/embassy-time-driver"
]
</code></pre>
<p>and create a new <code>[workspace.depedencies]</code> section in this file as well:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
</code></pre>
<p>This reconciles the name from 'embedded-service' to 'embedded-services'.</p>
<h2 id="-dependency-detour-manual-overrides-required--"><a class="header" href="#-dependency-detour-manual-overrides-required--">üõ†Ô∏èüß© Dependency Detour: Manual Overrides Required üß© üõ†Ô∏è</a></h2>
<p>At this point, you'll encounter a wall of configuration.
If you try to build here you will get an error about an failure to inherit a workspace dependency or else a dependency not found.  This is due to the need to match the configurations for the crates we are importing.  You can use tools like <code>cargo search</code> to show the current version of dependencies, for example, and tackle these one at a time, but in the interest of efficiency, just copy what is shown here, because there is a lot.</p>
<p>Unfortunately, the current structure of the service crates requires us to explicitly patch and align many transitive dependencies to avoid conflicts‚Äîespecially around async runtime and HAL crates.</p>
<p>This may feel excessive, but it‚Äôs a one-time setup step to align everything cleanly for builds targeting either desktop or embedded systems. Once it‚Äôs in place, the rest of the work proceeds smoothly.</p>
<p>Your top-level Cargo.toml at <code>battery_project/Cargo.toml</code> should have a full <code>[workspace.dependencies]</code> section that looks like this:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
defmt = "1.0"
embassy-executor = { path = "embassy/embassy-executor" }
embassy-futures = { path = "embassy/embassy-futures" }
embassy-sync = { path = "embassy/embassy-sync" }
embassy-time = { path = "embassy/embassy-time" }
embassy-time-driver = { path = "embassy/embassy-time-driver" }
embedded-batteries-async = { path = "embedded-batteries/embedded-batteries-async" }
embedded-cfu-protocol = { path = "embedded-cfu" }
embedded-usb-pd = { path = "embedded-usb-pd" }

embedded-hal = "1.0.0"
embedded-hal-async = "1.0.0"
log = "0.4"
bitfield = "0.17.0"
bitflags = "2.8.0"
bitvec = { version = "1.0.1", default-features = false }
cfg-if = "1.0.0"
chrono = { version = "0.4", default-features = false }
cortex-m = "0.7.6"
cortex-m-rt = "0.7.5"
critical-section = "1.1"
document-features = "0.2.7"                    
embedded-hal-nb = "1.0.0"
embedded-io = "0.6.1"
embedded-io-async = "0.6.1"
embedded-storage = "0.3.0"
embedded-storage-async = "0.3.0"
rand_core = "0.9.3"
heapless = { version = "0.7.16", default-features = false }
fixed = { version = "1.23.1", default-features = false }
postcard = { version = "1.1.1", default-features = false }
serde = { version = "1.0.219", default-features = false, features = ["derive"] }
</code></pre>
<p>After you've done all that,  you should be able to build with</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>and get a clean result</p>
<p>Next we will work to put this battery to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-registry"><a class="header" href="#battery-service-registry">Battery Service Registry</a></h1>
<hr />
<p><em>TODO: as noted, this content was written assuming an embedded (no-std) target, but we want to make sure we get through this while still able to build for std on the local machine.  Some details of this as written will likely need change.</em></p>
<hr />
<p>So far, we've defined our mock battery and wrapped it in Device wrapper so that it is ready to be included in a Service registry.</p>
<p>To do so meant committing to an embedded target build and a no-std environment compatible with the ODP crates and dependencies.</p>
<p>Now it is time to prepare the code we need to put this MockBatteryDevice to work.</p>
<h3 id="looking-at-the-examples"><a class="header" href="#looking-at-the-examples">Looking at the examples</a></h3>
<p>The <code>embedded-services</code> repository has some examples for us to consider already.  In the <code>embedded-services/examples/std</code> folder, particularly in <code>battery.rs</code> and <code>power_policy.rs</code> we can see how devices are created and then registered, and also how they are executed via per-device tasks.  The system is initialized and a runtime <code>Executor</code> is used to spawn the tasks.</p>
<h2 id="-wiring-up-the-battery-service"><a class="header" href="#-wiring-up-the-battery-service">üîå Wiring Up the Battery Service</a></h2>
<p>We need to create a device <code>Registry</code> as defined by <code>embedded-services</code> to wire our <code>MockBatteryDevice</code> into.</p>
<p>To do this, let's replace our current <code>mock_battery/main.rs</code> with this:</p>
<pre><code>#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embedded_services::init;
use embedded_services::power::policy::{register_device, DeviceId};
use static_cell::StaticCell;
use mock_battery::mock_battery_device::MockBatteryDevice;

use battery_service::{self, device::Device, wrapper::Wrapper};
use mock_battery::mock_battery_controller::MockBatteryController;

#[embassy_executor::main]
async fn async_main(spawner: Spawner) {
    // Required by embedded-services to initialize internals
    init().await;

    // Initialize and register our battery device
    static BATTERY: StaticCell&lt;MockBatteryDevice&gt; = StaticCell::new();
    let battery = BATTERY.init(MockBatteryDevice::new(DeviceId(0)));
    register_device(battery).await.unwrap();
    spawner.must_spawn(battery_run_task(battery));

    static WRAPPER: StaticCell&lt;Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;&gt; = StaticCell::new();


    // Initialize our fuel gauge controller
    static CONTROLLER: StaticCell&lt;MockBatteryController&gt; = StaticCell::new();
    let controller = CONTROLLER.init(MockBatteryController::new());
    
    // Initialize the device used by the battery service wrapper
    static DEVICE: StaticCell&lt;Device&gt; = StaticCell::new();
    let dev = DEVICE.init(Device::new(battery_service::device::DeviceId(1)));

    // Create a wrapper that can process battery service messages
    let wrapper = WRAPPER.init(Wrapper::new(dev, controller));
    // must_spawn will panic if the task fails to spawn, suitable for no_std
    spawner.must_spawn(wrapper_task(wrapper));

    
}

#[embassy_executor::task]
async fn battery_run_task(battery: &amp;'static MockBatteryDevice) {
    battery.run().await;
}


#[embassy_executor::task]
async fn wrapper_task(wrapper: &amp;'static Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;) {
    loop {
        wrapper.process().await;
    }
}

/// Required by embedded targets for panic handling
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>When you execute <code>cargo build --target thumbv7em-none-eabihf</code> you will receive errors, such as
"error: No architecture selected for embassy-executor. Make sure you've enabled one of the <code>arch-*</code> features in your Cargo.toml."</p>
<p>We still have some configuration to do.</p>
<p><code>embassy-executor</code> requires specific selection of the MCU architecture via features.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, remove the line
from the <code>[dependencies]</code> section</p>
<pre><code>embassy-executor = { path = "../embassy/embassy-executor", optional = true }
</code></pre>
<p>and add this section:</p>
<pre><code>[dependencies.embassy-executor]
path = "../embassy/embassy-executor"
features = ["arch-cortex-m", "executor-thread"]
optional = true
</code></pre>
<p>also, add these lines to the <code>[dependencies]</code> section (these references will come up soon):</p>
<pre><code>embassy-time = { path = "../embassy/embassy-time" }
embassy-sync = { path = "../embassy/embassy-sync" }
</code></pre>
<p>and then try again: <code>cargo build --target thumbv7em-none-eabihf</code></p>
<h2 id="the-battery-service"><a class="header" href="#the-battery-service">The Battery Service</a></h2>
<p>Now we have registered our battery device as a device for the embedded-services power policy,
but the <code>battery_service</code> knows how to use a battery specifically, so we need to register our battery as a 'fuel gauge' by that definition.</p>
<h3 id="the-battery-controller"><a class="header" href="#the-battery-controller">The Battery Controller</a></h3>
<p>The battery service <code>Controller</code> is the trait interface used to control a battery connected via the SmartBattery trait interface at a slightly higher level.</p>
<p>Create a new file in <code>mock_battery</code> named <code>mock_battery_controller.rs</code> and give it this content:</p>
<pre><code>use battery_service::controller::{Controller, ControllerEvent};
use battery_service::device::{DynamicBatteryMsgs, StaticBatteryMsgs};
use embassy_time::{Duration, Timer};
use embedded_batteries_async::smart_battery::{
    SmartBattery, ErrorType, 
    ManufactureDate, SpecificationInfoFields, CapacityModeValue, CapacityModeSignedValue,
    BatteryModeFields, BatteryStatusFields, 
    DeciKelvin, MilliVolts
};
use core::convert::Infallible;

pub struct MockBatteryController;

impl MockBatteryController {
    pub fn new() -&gt; Self {
        Self
    }
}

impl ErrorType for MockBatteryController {
    type Error = Infallible;
}

impl SmartBattery for &amp;mut MockBatteryController {
    async fn temperature(&amp;mut self) -&gt; Result&lt;DeciKelvin, Self::Error&gt; {
        Ok(2732) // Stubbed temperature in deci-Kelvin
    }
    // You can stub other SmartBattery methods as needed
    async fn voltage(&amp;mut self) -&gt; Result&lt;MilliVolts, Self::Error&gt; {
        Ok(11000)
    }


    // Stub all other required methods
    async fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn set_remaining_capacity_alarm(&amp;mut self, _: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn set_remaining_time_alarm(&amp;mut self, _: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::new())
    }

    async fn set_battery_mode(&amp;mut self, _: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    async fn set_at_rate(&amp;mut self, _: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    async fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::new())
    }

    async fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::new())
    }

    async fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    async fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn manufacturer_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_chemistry(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }    
}

impl Controller for &amp;mut MockBatteryController {
    type ControllerError = Infallible;

    async fn initialize(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    async fn get_static_data(&amp;mut self) -&gt; Result&lt;StaticBatteryMsgs, Self::ControllerError&gt; {
        Ok(StaticBatteryMsgs { ..Default::default() })
    }

    async fn get_dynamic_data(&amp;mut self) -&gt; Result&lt;DynamicBatteryMsgs, Self::ControllerError&gt; {
        Ok(DynamicBatteryMsgs { ..Default::default() })
    }

    async fn get_device_event(&amp;mut self) -&gt; ControllerEvent {
        loop {
            Timer::after(Duration::from_secs(60)).await;
        }
    }

    async fn ping(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    fn get_timeout(&amp;self) -&gt; Duration {
        Duration::from_secs(10)
    }

    fn set_timeout(&amp;mut self, _duration: Duration) {
        // Ignored for mock
    }
}
</code></pre>
<p>This just implements the SmartBattery traits with stubs for now.  We will connect it to our mock_battery shortly.  But for now, this gets us going past the next few steps.</p>
<h4 id="add-to-librs"><a class="header" href="#add-to-librs">add to <code>lib.rs</code></a></h4>
<p>Don't forget that we need to include this new file in our <code>lib.rs</code> declarations:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
</code></pre>
<p>Make sure you can build cleanly at this point, and then we will move ahead.</p>
<h3 id="the-fuel-gauge"><a class="header" href="#the-fuel-gauge">The fuel gauge</a></h3>
<p>The battery service has the concept of a 'fuel gauge' that calls into the SmartBattery traits to monitor charge / discharge.</p>
<p>We'll hook that up now.</p>
<p>Add this task to your <code>main.rs</code> file, nearby the other tasks found there:</p>
<pre><code>#[embassy_executor::task]
async fn battery_service_init_task(dev: &amp;'static Device) {
    let reg = battery_service::register_fuel_gauge(dev).await;
    if reg.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register fuel gauge device");
    }
}

</code></pre>
<p>and we'll call upon it just after registering the device, so at the end of your <code>async main</code> function, just after <code>spawner.must_spawn(wrapper_task(wrapper));</code>, add this:</p>
<pre><code> 
    // Register the fuel gauge device with the battery service
    spawner.must_spawn(battery_service_init_task(dev));
</code></pre>
<p>Verify you can still build cleanly</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<h3 id="implementing-comms"><a class="header" href="#implementing-comms">Implementing "comms"</a></h3>
<p>The battery service is one of several services that may reside within the Embedded Controller (EC) microcontroller. In a fully integrated system, messages between the EC and other components ‚Äî such as a host CPU or companion chips ‚Äî are typically carried over physical transports like SPI or I¬≤C.</p>
<p>However, within the EC firmware itself, services communicate through an internal message routing layer known as comms. This abstraction allows us to test and exercise service logic without needing external hardware.</p>
<p>At this point, we‚Äôll establish a simple comms setup that allows messages to reach our battery service from other parts of the EC ‚Äî particularly the power policy manager. The overall comms architecture can expand later to handle actual buses, security paging, or multi-core domains, but for now, a minimal local implementation will suffice.</p>
<h4 id="the-espi-comms"><a class="header" href="#the-espi-comms">The "espi" comms</a></h4>
<p>We'll follow a pattern exhibited by the ODP <code>embedded-services/examples/std/src/bin/battery.rs</code>, but trimmed for embedded/no-std use.</p>
<p>Create a file for a module named <code>espi_service.rs</code> inside your <code>mock_battery/src</code> folder and give it this content:</p>
<pre><code>use battery_service::context::{BatteryEvent, BatteryEventInner};
use battery_service::device::DeviceId;
use embassy_sync::blocking_mutex::raw::NoopRawMutex;
use embassy_sync::once_lock::OnceLock;
use embassy_sync::signal::Signal;
use embedded_services::comms::{self, EndpointID, External};
use embedded_services::ec_type::message::BatteryMessage;


pub struct EspiService {
    endpoint: comms::Endpoint,
    _signal: Signal&lt;NoopRawMutex, BatteryMessage&gt;,
}

impl EspiService {
    pub fn new() -&gt; Self {
        Self {
            endpoint: comms::Endpoint::uninit(EndpointID::External(External::Host)),
            _signal: Signal::new(),
        }
    }
}

impl comms::MailboxDelegate for EspiService {
    fn receive(&amp;self, message: &amp;comms::Message) -&gt; Result&lt;(), comms::MailboxDelegateError&gt; {
        let msg = message
            .data
            .get::&lt;BatteryMessage&gt;()
            .ok_or(comms::MailboxDelegateError::MessageNotFound)?;

        match msg {
            BatteryMessage::CycleCount(_count) =&gt; {
                // Do something if needed; placeholder
                Ok(())
            }
            _ =&gt; Err(comms::MailboxDelegateError::InvalidData),
        }
    }
}

static ESPI_SERVICE: OnceLock&lt;EspiService&gt; = OnceLock::new();

pub async fn init() {

    let svc = ESPI_SERVICE.get_or_init(EspiService::new);
    if comms::register_endpoint(svc, &amp;svc.endpoint).await.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register ESPI service endpoint");
    }

}

#[embassy_executor::task]
pub async fn task() {
    let svc = ESPI_SERVICE.get().await;

    let _ = svc.endpoint.send(
        EndpointID::Internal(comms::Internal::Battery),
        &amp;BatteryEvent {
            device_id: DeviceId(1),
            event: BatteryEventInner::DoInit,
        },
    ).await;

    let _ = battery_service::wait_for_battery_response().await;

    loop {
        let _ = svc.endpoint.send(
            EndpointID::Internal(comms::Internal::Battery),
            &amp;BatteryEvent {
                device_id: DeviceId(1),
                event: BatteryEventInner::PollDynamicData,
            },
        ).await;

        let _ = battery_service::wait_for_battery_response().await;

        embassy_time::Timer::after(embassy_time::Duration::from_secs(5)).await;
    }
}
</code></pre>
<p>Before the loop, the DoInit message is sent which will cause <code>Controller::initialize</code> to be invoked via service layer.  The loop runs at 5 second intervals and polls for updates in the dynamic data
(such as the current level of charge).</p>
<p>and, by now I'm sure you know the drill, remember to add this module to your <code>lib.rs</code> file:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
pub mod espi_service;
</code></pre>
<p>Now we will attach it in our <code>main.rs</code> file.</p>
<p>Add this <code>use</code> statement to import it:</p>
<pre><code>use mock_battery::espi_service;
</code></pre>
<p>and these lines at the end of your <code>async main</code> to initialize it and spin it up:</p>
<pre><code>    // Start up our comms
    espi_service::init().await;
    spawner.must_spawn(espi_service::task());
</code></pre>
<h3 id="adding-some-logging-support"><a class="header" href="#adding-some-logging-support">Adding some logging support</a></h3>
<p>We are now in a position to get data from our battery.  But how will we know? We need some logging in place first.  Let's hook that up now.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, add or update these values in their respective sections:</p>
<pre><code>[dependencies]
defmt = "1.0"
defmt-rtt = "0.4"
panic-probe = { version = "0.3", features = ["print-defmt"] }

# Add the log shim for libraries using `log` crate
log = { version = "0.4", features = ["release_max_level_debug"], optional = true }
defmt-log = { version = "0.3", optional = true }

[features]
default = ["embedded", "defmt-log", "log"]

[package.metadata.cargo-xbuild]
linker = "rust-lld"

</code></pre>
<p>We can now remove the <code>#![panic_handler] block in </code>main.rs` altogether and replace it with:</p>
<pre><code>/// Required by embedded targets for panic handling
use panic_probe as _; // This provides a defmt-compatible panic handler
</code></pre>
<p>The panic-probe crate, when built with the print-defmt feature, automatically installs the right panic handler for you ‚Äî no need to write one manually.</p>
<p>Using the logging is straightforward.  Examples of log statements would be like:</p>
<pre><code>info!("Starting wrapper task");
warn!("Something unusual");
error!("Something failed: {:?}", err);
</code></pre>
<!-- 
Note - this setup for logging is incomplete and turns out to be much more of a rabbit-hole than I could have imagined.
Additionally, major revisions to memory.x and
some of the cargo settings are needed, plus some
stubs for the cortex-m that need to be put into place that are not documented yet before anything
will build correctly to flash to the hardware. 
This is the current WIP and may require a separate section before continuing here.
-->
<h3 id="getting-the-dynamic-data"><a class="header" href="#getting-the-dynamic-data">Getting the dynamic data</a></h3>
<p>So now that we have logging in place,</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>In the previous exercises, we have built an implementation of a SmartBattery for our Mock Battery, and shown we can implement it into a service registry where it can be called upon by a service.</p>
<p>The next step is to test our implementation through a series of Unit Tests.
Unit Tests will insure the implementation produces the results we expect.  Early on, we had simply printed some values to the console to verify certain values.  This is not a good method of testing because the print action cannot be part of the final build.  Instead, we want to use a Unit Test harness that will allow us to inspect our otherwise silent build and report the values within it.</p>
<p>This will also allow us to continue to develop additional features of the battery as we simulate its behavior for charge over time.  This approach is commonly known as "Test Driven Development" (TDD) and is a strong pattern to adopt for any development scenario, perhaps even moreso for embedded device development.</p>
<h2 id="types-of-tests-and-where-to-put-them"><a class="header" href="#types-of-tests-and-where-to-put-them">Types of Tests and where to put them</a></h2>
<p>A <strong>Unit Test</strong> typically is scoped to test only the capabilities of a single component or "unit" of code.
An <strong>Integration Test</strong> is a test that either tests different implementations of a single unit structure, or else the integration of more than one component and the interactions between these components.</p>
<p>Code for Integration Tests are typically in a separate .rs file (often within a 'test' directory).  Unit Tests may also be separate, but it is also conventional for Unit Tests to be included in the same Rust code file as the component code itself.
In our Mock Battery case, we will put these first tests within our mock_battery.rs file.
This keeps our tests co-located with the implementation and avoids the need for additional test scaffolding.
Since we're implementing traits intended for broader reuse, but are only concerned with our one MockBattery implementation for now, embedding the tests here is both practical and instructive.</p>
<h3 id="our-first-tests"><a class="header" href="#our-first-tests">Our first tests</a></h3>
<p>So let's get started.  We're going to start with the mock battery itself. This keeps us focused on this basic level of functionality without adding additional complications of the abstraction layers introduced by wrapping it in a Device.  We'll return to this when we start writing directly for an embedded target and want to verify those levels.</p>
<p>At the bottom of <code>mock_battery.rs</code> add this code:</p>
<pre><code>#[cfg(test)]
mod tests {
    use super::*;
    use embedded_batteries::smart_battery::SmartBattery;

    #[test]
    fn test_voltage() {
        let mut battery = MockBattery;
        let voltage = battery.voltage().expect("Voltage should be readable");
        assert_eq!(voltage, 7500); // mV
    }

    #[test]
    fn test_state_of_charge() {
        let mut battery = MockBattery;
        let soc = battery.relative_state_of_charge().expect("SoC should be readable");
        assert_eq!(soc, 88); // percentage
    }

    #[test]
    fn test_temperature() {
        let mut battery = MockBattery;
        let temp = battery.temperature().expect("Temperature should be readable");
        assert_eq!(temp, 2950); // deci-Kelvin
    }

    #[test]
    fn test_manufacturer_name() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 32];
        battery.manufacturer_name(&amp;mut buf).expect("Should get manufacturer name");
        let name = core::str::from_utf8(&amp;buf[..15]).expect("Valid UTF-8");
        assert_eq!(name, "MockBatteryCorp");
    }

    #[test]
    fn test_device_name() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 32];
        battery.device_name(&amp;mut buf).expect("Should get device name");
        let name = core::str::from_utf8(&amp;buf[..8]).expect("Valid UTF-8");
        assert_eq!(name.trim_end_matches(char::from(0)), "MB-4200");
    }

    #[test]
    fn test_device_chemistry() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 16];
        battery.device_chemistry(&amp;mut buf).expect("Should get chemistry name");
        let name = core::str::from_utf8(&amp;buf[..6]).expect("Valid UTF-8");
        assert_eq!(name.trim_end_matches(char::from(0)), "Li-Ion");
    }
}

</code></pre>
<h3 id="running-the-test"><a class="header" href="#running-the-test">Running the test</a></h3>
<p>When you are ready, type <code>cargo test</code> at the <code>battery_project</code> root.</p>
<p>You will see a lot of output because <code>cargo test</code> is going to test all the components of the workspace, including the ODP repository directories we've included.
There may be warning errors in some of these dependencies. But you will also see that all the tests pass, and looking more closely at the output you will see that there are indeed 6 tests reported for mock_battery that all pass.</p>
<blockquote>
<p>üìå <strong>Note about embedded dependencies and unit testing</strong></p>
<p>While <code>cargo test -p mock_battery</code> would normally isolate this crate for testing,
the embedded dependencies it brings in assume certain runtime features (like <code>critical-section</code> and <code>embassy_time</code>) that aren't defined in desktop builds.</p>
<p>These assumptions cause linker errors unless we provide full backend implementations ‚Äî something we‚Äôll do later, when we shift to testing in a proper embedded target.</p>
<p>For now, we can safely run our unit tests by invoking <code>cargo test</code> from the workspace root, and simply ignore unrelated test warnings from other crates.</p>
</blockquote>
<h4 id="fixing-some-of-the-warnings-from-the-dependencies"><a class="header" href="#fixing-some-of-the-warnings-from-the-dependencies">Fixing some of the warnings from the dependencies</a></h4>
<p>It is not uncommon to encounter warnings in tests that are introduced from dependencies.  As one might appreciate, writing tests for a shared package that may be used in multiple different contexts can be challenging, and the focus on testing tends to center on the worthiness of the code in the package more than the viability of those tests being inherited by consuming packages.</p>
<p>You may be seeing warnings in the full test run we have done that originate from one or more of the dependent projects.</p>
<p>This is a common and recognizable problem and the Rust toolchain is aware of it and smart enough to assist.</p>
<p>If there are warnings such as 'unused import', 'unused variable', incorrect field names (with suggestions), or notes about outdated or deprecated syntax, <code>cargo</code> can repair these for you.</p>
<p>So, for example, if you have a 'unused import' warning originating from the <code>embedded-services</code> repository in this workspace, you can try <code>cargo fix --lib -p embedded-services --tests --allow-no-vcs</code>
This will patch any offending test code that may have caused the previous warnings.  If you subsequently run <code>cargo test</code> the warnings should have disappeared.</p>
<h3 id="continuing-with-tdd"><a class="header" href="#continuing-with-tdd">Continuing with TDD</a></h3>
<p>Having gotten that cleared up, we are ready to continue to build out our tests and the corresponding behaviors for our mock battery to behave like a real battery might.</p>
<h4 id="defining-the-time-trait-now"><a class="header" href="#defining-the-time-trait-now">Defining the Time Trait <code>now</code></a></h4>
<p>To simulate charge or discharge over time in our mock battery, we need a way to track elapsed time. We'll use one actual time source here and another later when we are in-system on a target build.</p>
<p>To support this cleanly, we will define a TimeSource trait,
and its implementation for our current test context.</p>
<pre><code>pub trait TimeSource {
    fn now(&amp;self) -&gt; u64; // time in milliseconds
}

#[derive(Default)]
pub struct MockTime {
    time_ms: core::cell::Cell&lt;u64&gt;,
}

impl MockTime {
    pub fn new() -&gt; Self {
        Self { time_ms: core::cell::Cell::new(0) }
    }

    pub fn advance(&amp;self, delta_ms: u64) {
        let now = self.time_ms.get();
        self.time_ms.set(now + delta_ms);
    }
}

impl TimeSource for MockTime {
    fn now(&amp;self) -&gt; u64 {
        self.time_ms.get()
    }
}
</code></pre>
<p>This just defines a time that starts with an initial real time value, and advances the time by a given amount when we call <code>advance</code>. It could just as well start at 0 and be manually advanced for testing, but we'll go ahead and attach a real clock.</p>
<h4 id="adding-a-clock-to-the-mockbattery"><a class="header" href="#adding-a-clock-to-the-mockbattery">Adding a clock to the MockBattery</a></h4>
<p>Let's give our MockBattery a TimeSource trait and a couple of reference values we will use later.  We'll use <code>std:rc::Rc</code> as a real-time clock reference for our testing for now.</p>
<p>üìå <strong>Use of dynamic dispatch</strong></p>
<blockquote>
<p>Note: We're using dynamic dispatch here (<code>dyn TimeSource</code>)
for flexibility in swapping out implementations. In
performance-sensitive code, a generic parameter might be
preferable, but this approach keeps things simple and
testable.</p>
</blockquote>
<pre><code>use std::rc::Rc;

pub struct MockBattery {
    clock: Rc&lt;dyn TimeSource&gt;,
    #[allow(dead_code)]
    start_time: u64,
    #[allow(dead_code)]
    start_soc: u8,
}

impl MockBattery {
    // to create a battery with a self-contained internal clock
    pub fn new() -&gt; Self {
        let clock = Rc::new(MockTime::new());
        let now = clock.now();
        Self {
            clock,
            start_time: now,
            start_soc: 100,
        }
    }
}
impl MockBattery {
    // to create a battery in which time time source is external
    pub fn with_clock(clock: Rc&lt;dyn TimeSource&gt;) -&gt; Self {
        let now = clock.now();
        Self {
            clock,
            start_time: now,
            start_soc: 100,
        }
    }

    pub fn clock(&amp;self) -&gt; &amp;Rc&lt;dyn TimeSource&gt; {
        &amp;self.clock
    }
}

</code></pre>
<h4 id="update-the-battery-instantiation"><a class="header" href="#update-the-battery-instantiation">Update the battery instantiation</a></h4>
<p>We now need to update every place in our first test code where we reference what was originally a static battery structure with a new instantiation.
Find all the lines like this:</p>
<pre><code>let mut battery = MockBattery;
</code></pre>
<p>and replace with:</p>
<pre><code>let mut battery = MockBattery::new();
</code></pre>
<p>And since we've changed MockBattery in this way we also need to fix the reference to it in <code>mock_battery_device.rs</code> or it won't compile.</p>
<p>In <code>mock_battery_device.rs</code> change</p>
<pre><code>impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }
</code></pre>
<p>to</p>
<pre><code>impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery:  MockBattery::new(),
            device: Device::new(id)
        }
    }
</code></pre>
<h3 id="implementing-dynamic-battery-behavior"><a class="header" href="#implementing-dynamic-battery-behavior">Implementing dynamic battery behavior</a></h3>
<p>Now that we have a time reference, we can support concepts like charge/discharge over time for our simulated battery.</p>
<h4 id="relative-state-of-charge"><a class="header" href="#relative-state-of-charge">Relative state of charge</a></h4>
<p>The SmartBattery Specification, which we've implemented statically by providing values for the traits of our MockBattery implementation, defines a function <code>RelativeStateOfCharge</code> that we can use to determine the current battery capacity over time as it is discharged.</p>
<p>We have implemented this in our MockBattery currently, here:</p>
<pre><code>    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }
</code></pre>
<p>which will forever report our remaining capacity at 88%.</p>
<p>To make this dynamic and respect the other attributes implemented via our SmartBattery implmentation, we can change this function to the following:</p>
<pre><code>fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
    let cap = match self.full_charge_capacity()? {
        CapacityModeValue::MilliAmpUnsigned(c) =&gt; c as u32,
        _ =&gt; return Ok(100),
    };

    let curr = self.average_current()? as i32;
    let discharge_ma = if curr &lt;= 0 { 1 } else { curr };

    let elapsed_ms = self.clock.now().saturating_sub(self.start_time);
    let elapsed_mah = (elapsed_ms as i64 * discharge_ma as i64) / 3600_000;

    let remaining_mah = cap.saturating_sub(elapsed_mah.max(0) as u32);

    let percent = ((remaining_mah as f64 / cap as f64) * 100.0).round() as u8;
    Ok(percent.min(100))
}
</code></pre>
<p>This will give us a simulated discharge using a simple linear model.  A more sophisticated battery simulation may use a non-linear derivation or consider other factors (e.g. thermal effects) that we don't have available at the current time, but
our real goal is not to make the world's best battery simulation, but rather to learn how to connect <em>real</em> batteries - no simulation needed - in the same way.  So this is fine.</p>
<h4 id="fixing-the-initial-charge-value"><a class="header" href="#fixing-the-initial-charge-value">Fixing the initial charge value</a></h4>
<p>If we ran that test  now, it would fail because our first tests are still checking the original values we used when we constructed our SmartBattery implmentation.  So we need to change the test for this to expect 100 instead of 88, like it has been because we now are expecting a full charge at startup, per our dynamic function above.</p>
<p>So change <code>test_state_of_charge</code> to look like:</p>
<pre><code>    #[test]
    fn test_state_of_charge() {
        let mut battery = MockBattery::new();
        let soc = battery.relative_state_of_charge().expect("SoC should be readable");
        assert_eq!(soc, 100); // fresh battery just instantiated
    }
</code></pre>
<h4 id="testing-decrease-over-time"><a class="header" href="#testing-decrease-over-time">Testing decrease over time</a></h4>
<p>Now let's actually test for a decrease in charge over time with a new test function.</p>
<p>Add this test at teh bottom of the <code>#[cfg(test)]</code> block:</p>
<pre><code>#[test]
fn test_dynamic_soc_decreases_over_time() {
    let clock = std::rc::Rc::new(MockTime::new());
    let mut battery = MockBattery::with_clock(clock.clone());

    // At time 0, should be near 100%
    let soc_initial = battery.relative_state_of_charge().unwrap();
    assert!(soc_initial &gt;= 99, "Initial SoC should be close to 100, got {}", soc_initial);

    // Advance 1 hour (3600_000 ms)
    clock.advance(3600_000);

    // Now SoC should have decreased
    let soc_after_1h = battery.relative_state_of_charge().unwrap();
    assert!(soc_after_1h &lt; soc_initial, "SoC should decrease after 1h");
    assert!(soc_after_1h &lt;= 100, "SoC should be at most 100%");
}

</code></pre>
<p>As you can see, this test gets the initial value of our charge, which should be 100%, then uses our TimeSource to advance time one hour after  the initial charge of 100%, then tests
As you can see, this test gets the initial value of our charge, which should be 100%, then uses our TimeSource to advance time one hour after and verifies that the charge is &lt; 100%</p>
<p>For the next section, we need to stop working on our desktop build and move forward with an embedded target.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-for-the-embedded-target"><a class="header" href="#building-for-the-embedded-target">Building for the Embedded Target</a></h1>
<p>We've validated our simplistic mock battery has implemented basic traits, and we've been able to do that with a generic build on the desktop.
To go much further, we need to start building for the embedded controller context that this component is designed to run as - targeted for a microcontroller, without standard library dependencies.</p>
<p>Which development board we use at this point isn‚Äôt critical. Our mock battery and simulated components will remain software-only for now, so we don‚Äôt need physical hardware peripherals or a fully implemented HAL. Later, when we explore advanced features like ARM TrustZone or Hafnium hypervisor integration, we may need a specific Cortex-M board ‚Äî but those can be hard to source. So rather than lock ourselves in too early, we‚Äôll keep this next section general and adaptable to what you may already have.</p>
<p>In particular, if you've followed the excellent  <a href="https://docs.rust-embedded.org/book/">Rust Embedded Book</a>, there's a good chance you already have an STM32 Discovery board on hand. These boards are inexpensive, well-supported, and ideal for this stage of development.</p>
<p>The examples here will use the STM32F3 Discovery board. If you're using a different board, you may need to adjust your configuration accordingly. That said, our code will aim to be as portable and HAL-independent as possible.</p>
<h2 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h2>
<p>To build for an embedded target, we need to prepare our development environment with a few important tools and configuration files.</p>
<p>While there are many variations depending on target board and host OS, we will aim to keep this setup as broadly compatible and standard as possible.</p>
<h3 id="installing-the-embedded-rust-toolchain"><a class="header" href="#installing-the-embedded-rust-toolchain">Installing the Embedded Rust Toolchain</a></h3>
<p>The standard Rust toolchain needs a few additions to suppor cross-compiling for emedded targets.</p>
<p>Staying within your current <code>battery_project</code> workspace,
run</p>
<pre><code>rustup target add thumbv7em-none-eabihf
</code></pre>
<h3 id="including-embassy"><a class="header" href="#including-embassy">Including Embassy</a></h3>
<p>Many of the embedded features supported by ODP rely on dependencies of Embassy, and we will also want to use many of Embassy's framework support to simplify our construction.
To keep things as consistent as possible, we will be bringing in the Embassy repository as another submodule, similar to what we did with <code>embedded-batteries</code></p>
<p>At the <code>battery_project</code> root:</p>
<pre><code>git submodule add https://github.com/embassy-rs/embassy.git
</code></pre>
<h3 id="updating-the-configuration-files"><a class="header" href="#updating-the-configuration-files">Updating the configuration files</a></h3>
<p>In <code>mock_battery/Cargo.toml</code>, update the contents to look like this:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embassy-executor = { path = "../embassy/embassy-executor", optional = true }

[features]
default = ["embedded"]
embedded = ["embassy-executor"]
</code></pre>
<p>At the top-level Cargo.toml (<code>battery_project/Cargo.toml</code>), update the workspace members to include the new local crates:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embassy/embassy-executor"
]
</code></pre>
<p>Now you should be able to build with</p>
<pre><code>cargo build
</code></pre>
<p>That should build properly.
Now let's see if we can target our embedded toolchain.
enter</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>This will produce a number of errors because we still have the old <code>println!</code> statements in there from the previous example.
We also need to better prepare the code for a "no-std" environment.</p>
<p>Replace the current <code>main.rs</code> content with this new version:</p>
<pre><code>#![no_std]
#![no_main]

use embedded_batteries::smart_battery::SmartBattery;
use mock_battery::mock_battery::MockBattery;
use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let mut battery = MockBattery;

    let _ = battery.voltage();
    let _ = battery.relative_state_of_charge();
    let _ = battery.temperature();

    loop {}
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>You can see we're not only not printing anything to the output here, we have specifically declared <code>#![no_std]</code> and provided a <code>#[panic_handler]</code> that normally would be supplied by std.</p>
<p>One more thing to do.  In <code>lib.rs</code>, add <code>#![no_std]</code> at the top of that file as well.</p>
<pre><code>#![no_std]
pub mod mock_battery;
</code></pre>
<p>Now</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>should build without issue.</p>
<p>In the next section, we will look at writing Unit Tests to prove out the behaviors of our mock battery and provide some simulation of charge behaviors.</p>
<div style="break-before: page; page-break-before: always;"></div><h4 id="unavoidable-detail-ahead-dependency-overrides"><a class="header" href="#unavoidable-detail-ahead-dependency-overrides">Unavoidable Detail Ahead: Dependency Overrides</a></h4>
<p>At this point, you'll encounter a wall of configuration. Unfortunately, the current structure of the service crates requires us to explicitly patch and align many transitive dependencies to avoid conflicts‚Äîespecially around async runtime and HAL crates.</p>
<p>This may feel excessive, but it‚Äôs a one-time setup step to align everything cleanly for builds targeting either desktop or embedded systems. Once it‚Äôs in place, the rest of the work proceeds smoothly.</p>
<p>Add the following lines to the <code>[workspace.dependencies]</code> section:</p>
<pre><code># These align versions of crates used across embedded-services, battery-service,
# and embassy dependencies to avoid mismatched or duplicated transitive dependencies.
bitfield = "0.17.0"
bitflags = "2.8.0"
bitvec = { version = "1.0.1", default-features = false }
cfg-if = "1.0.0"
chrono = { version = "0.4", default-features = false }
cortex-m = "0.7.6"
cortex-m-rt = "0.7.5"
critical-section = "1.1"
defmt = "0.3"
document-features = "0.2.7"

embassy-executor     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-executor" }
embassy-futures      = { git = "https://github.com/embassy-rs/embassy", package = "embassy-futures" }
embassy-sync         = { git = "https://github.com/embassy-rs/embassy", package = "embassy-sync" }
embassy-time         = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time" }
embassy-time-driver  = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time-driver" }

embedded-batteries-async = { path = "embedded-batteries/embedded-batteries-async" }
embedded-cfu-protocol    = { git = "https://github.com/OpenDevicePartnership/embedded-cfu" }
embedded-hal             = "1.0"
embedded-hal-async       = "1.0"
embedded-hal-nb          = "1.0"
embedded-io              = "0.6.1"
embedded-io-async        = "0.6.1"
embedded-storage         = "0.3"
embedded-storage-async   = "0.4.1"
embedded-usb-pd          = { git = "https://github.com/OpenDevicePartnership/embedded-usb-pd", default-features = false }

fixed     = "1.23.1"
heapless  = "0.8.*"
log       = "0.4"
postcard  = "1.*"
rand_core = "0.6.4"
serde     = { version = "1.0.*", default-features = false }
tps6699x  = { git = "https://github.com/OpenDevicePartnership/tps6699x" }
</code></pre>
<p>And, finally, add this patch section so that Cargo does not try to load embassy from <code>crates.io</code> despite other declarations:</p>
<pre><code>[patch.crates-io]
embassy-executor = { git = "https://github.com/embassy-rs/embassy", package = "embassy-executor" }
embassy-time     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time" }
embassy-sync     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-sync" }
embassy-futures  = { git = "https://github.com/embassy-rs/embassy", package = "embassy-futures" }
</code></pre>
<p>You should now be able to run <code>cargo build</code> from the <code>battery_project</code> directory without errors.</p>
<h4 id="two-versions-of-main"><a class="header" href="#two-versions-of-main">Two versions of main</a></h4>
<p>Our register-and-run main function will have two versions. One for desktop (the default, and the one we just built in the previous step), and one for embedded.</p>
<p>In the <code>mock_battery</code> directory, create the file <code>embedded_main.rs</code> that we will use for our embedded target.  Give it this content:</p>
<pre><code>use embassy_executor::Spawner;
use embedded_services::power::policy::register_device;
use embedded_services::power::policy::DeviceId;
use mock_battery::mock_battery_device::MockBatteryDevice;

#[embassy_executor::main]
async fn main(_spawner: Spawner) {

    let dev = Box::leak(Box::new(MockBatteryDevice::new(DeviceId(0))));
    
    register_device(dev).await.unwrap();
    dev.run().await;
}

pub fn run() {
    // Stub for build compatibility when running on non-embedded platform
    panic!("This binary must be built for an embedded target");
}

</code></pre>
<p>and create a file named <code>desktop_main.rs</code> with this content:</p>
<pre><code>use embedded_services::power::policy::register_device;
use embedded_services::power::policy::DeviceId;
use mock_battery::mock_battery_device::MockBatteryDevice;


pub async fn run() {

    let dev = Box::leak(Box::new(MockBatteryDevice::new(DeviceId(0))));
    
    register_device(dev).await.unwrap();
    dev.run().await;
}

// Stub for build compatibility when running on non-embedded platform
#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _critical_section_1_0_acquire() {}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _critical_section_1_0_release() {}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _embassy_time_now() -&gt; u64 {
    0
}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _embassy_time_schedule_wake(_timestamp: u64) {}
</code></pre>
<p>Replace the current contents of <code>main.rs</code> with this code, which will choose between the two:</p>
<pre><code>#![cfg_attr(feature = "embedded", no_std)]

#[cfg(all(feature = "desktop", not(feature = "embedded")))]
mod desktop_main;

#[cfg(all(feature = "embedded", not(feature = "desktop")))]
mod embedded_main;

#[cfg(all(feature = "desktop", not(feature = "embedded")))]
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(desktop_main::run());
}

#[cfg(all(feature = "embedded", not(feature = "desktop")))]
fn main() {
    embedded_main::run();
}
</code></pre>
<p>And then, finally, from the <code>battery_project</code> root,
build the desktop version with</p>
<pre><code>cargo build --features desktop
</code></pre>
<p>and build the embedded version with</p>
<pre><code>cargo build --features embedded --no-default-features
</code></pre>
<p>Both should build without errors.</p>
<p>Note that <code>cargo build</code> by itself defaults to the desktop option.</p>
<p>The <code>--no-default-features</code> flag is required for the embedded option because of the exclusivity of the feature options.</p>
<p>Also note that you might optionally add <code> -p mock_battery</code> to this command to definitively say which workspace project to build, but this will be the default anyway since it is the only one that takes these features.</p>
<h4 id="no-output"><a class="header" href="#no-output">No output</a></h4>
<p>If you try to do a <code>cargo run</code> for the embedded build you will see an error that it can't do that without an embedded target -- which we will get to in good time.</p>
<p>If you do a <code>cargo run</code> for the desktop build you will not see any output, and will have to use <code>ctrl-c</code> to break and exit the program.</p>
<p>This is because we changed our main function (for both feature targets) to register and wait for commands from the service, and we haven't done that yet.  So nothing is going to appear until we do.</p>
<p>We shouldn't be emitting console messages here anyway.
The proper way to check the features of something like our SmartBattery Device implementation for MockBatteryDevice
is through well-defined Unit Tests.</p>
<p>We'll be doing that in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="code-changes-required-to-continue-with-embedding"><a class="header" href="#code-changes-required-to-continue-with-embedding">Code changes required to continue with embedding</a></h2>
<p>Simply updating the dependencies probably isn't enough to get a clean embedded build yet.  There will need to be some code changes as well.  These are covered in this section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-logging-support"><a class="header" href="#embedded-logging-support">Embedded logging support</a></h1>
<p>We will need to verify our embedded build runs, and to do that we need to insure we have logging properly implemented.
This covers that effort (if not already in place from the previous steps), and the usages of logging in the embedded context.
Also covers panic handling, as a reminder and in keeping with how failures are reported in logging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-flashing"><a class="header" href="#embedded-flashing">Embedded Flashing</a></h1>
<p>This will be the end of the component series.  This covers actually running the component on the target hardware and summarizes what has been done from the beginning of the series to achieve this.</p>
<p>A note that the ultimate embedded integration involving multiple components is still a task for the future before our mock embedded controller goal will be reached.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="charger"><a class="header" href="#charger">Charger</a></h1>
<p><em>TODO</em></p>
<p>This will be an adjunct to the current Battery example, completing the relationship for power management.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-management"><a class="header" href="#thermal-management">Thermal management</a></h1>
<p>This example shows how to implement a thermal component subsystem</p>
<p><em>TODO: This will follow similar pattern found for Battery</em></p>
<h2 id="relevant-repositories-1"><a class="header" href="#relevant-repositories-1">Relevant Repositories</a></h2>
<p><em>TODO: Like battery, this will point out the ODP resources we will use in the upcoming example</em></p>
<hr />
<h2 id="a-side-tour"><a class="header" href="#a-side-tour">A Side Tour:</a></h2>
<h3 id="exploring-the-microsoft-power-thermal-framework-specification"><a class="header" href="#exploring-the-microsoft-power-thermal-framework-specification">Exploring the Microsoft Power Thermal Framework specification</a></h3>
<p>Before we begin our example exercise, let's take a look at another example and demo that focuses on the specific characteristics of the Microsoft Power Thermal Framework specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microsoft-power-thermal-framework-getting-started"><a class="header" href="#microsoft-power-thermal-framework-getting-started">Microsoft Power Thermal Framework Getting Started</a></h1>
<p>This section covers details from integration with the OS through EC services down to the MCU code that controls system thermals.</p>
<p>The Microsoft Power Thermal Framework (MPTF) specification is not defined here. A good understanding of what MPTF is and how the OS interacts with it should be considered first to properly understand this getting started guide.</p>
<p>By the end of this guide you should be able to take your hardware platform running windows and use it to control fan and thermal attributes from your embedded controller.</p>
<h2 id="a-discussion-before-we-begin"><a class="header" href="#a-discussion-before-we-begin">A discussion before we begin</a></h2>
<p>This section is <em>not</em> the Thermal Component Example.  That discussion will follow.  This section is meant to provide real-world context for a specific implementation of the thermal component subsystem as it relates to the MPTF specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>This guide will walk you through configuration of four primary components</p>
<ol>
<li>MPTF Drivers and config Blob</li>
<li>ACPI input and output</li>
<li>Hafnium EC service</li>
<li>MCU EC Interface</li>
</ol>
<p>The OS Power Manager (OSPM) communicates with input and output devices defined by MPTF to read skin temperatures and control fan and thermal levels.</p>
<p><img src="how/ec/thermal/mptf/media/embedded_controller.jpeg" alt="Embedded Controller" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mptf-drivers"><a class="header" href="#mptf-drivers">MPTF Drivers</a></h1>
<p>There is 3 primary drivers involved in MPTF</p>
<ul>
<li>MPTF Core Driver</li>
<li>Microsoft Customized IO Driver</li>
<li>MPTF Customize IO Signal Client</li>
</ul>
<p>All these drivers are included in OS drops after 26394 as part of the default OS build.</p>
<h2 id="mptf-core-driver"><a class="header" href="#mptf-core-driver">MPTF Core Driver</a></h2>
<p>The Core Driver provides the core logic for MPTF, reads the configuration blob and operates on input and output devices. This driver will not be loaded unless you add the following ACPI entry to load the driver automatically at boot time.</p>
<pre><code>// MPTFCore Driver
Device(MPC0) {
 Name(_HID, "MSFT000D")
 Name (_UID, 1)

}
</code></pre>
<p>You can find this driver under windows driverstore folder</p>
<p><code>C:\Windows\System32\DriverStore\FileRepository\mptfcore.inf_*</code></p>
<p>If it is enumerated properly you will see it show up as MPTF Core Driver in device manager.</p>
<p><img src="how/ec/thermal/mptf/media/device_manager.png" alt="MPTF Driver" /></p>
<p>MPTF Core Driver logging can be enable in windbg with the following commands.</p>
<pre><code>!wmitrace.start MptfCore -kd
!wmitrace.enable MptfCore {9BBAB94F-A0B0-4F96-8966-A04F9BA72CA0} -level 0x7 -flag 0xFFFF
</code></pre>
<h2 id="microsoft-customized-io-driver"><a class="header" href="#microsoft-customized-io-driver">Microsoft Customized IO Driver</a></h2>
<p>The Microsoft Customized IO Driver provides a standard interface to the embedded controller to provide input and output values to control fan and thermal properties on the embedded controller.</p>
<p>The ACPI entry for loading the Microsoft Customized IO Driver is as follows</p>
<pre><code>Device(CIO1) {
  Name(_HID, "MSFT000B")
  Name (_UID, 1)
  ...
}
</code></pre>
<p>For further details on ACPI definitions and customizations for defining IO inputs and outputs see the section on ACPI.</p>
<p>You can find this driver under windows driverstore folder</p>
<p><code>C:\Windows\System32\DriverStore\FileRepository\mscustomizedio.inf_*</code></p>
<p>You will find the driver under device manager in Thermal devices as Microsoft Customized IO Driver</p>
<p><img src="how/ec/thermal/mptf/media/device_manager.png" alt="MPTF Driver" /></p>
<p>Microsoft Customized IO Driver logging can be enabled in windbg with the following commands.</p>
<pre><code>!wmitrace.start MptfIo -kd
!wmitrace.enable MptfIo {D0ABE2A4-A604-4BEE-8987-55C529C06185} -level 0x7 -flag 0xFFFF
</code></pre>
<h2 id="mptf-custom-io-signal-client-driver"><a class="header" href="#mptf-custom-io-signal-client-driver">MPTF Custom IO Signal Client Driver</a></h2>
<p>The Custom IO Signal Cient Driver provides ability for OEM's to provide their own custom input and output signals into MPTF. Examples of custom drivers along with input and output definitions can be found in the MPTF specification and are not covered here.</p>
<p>The following ACPI entry will cause the Custom IO Signal Driver to be loaded at boot time.</p>
<pre><code>// MPTF Signal IO Client driver
Device(MPSI) {
  Name(_HID, "MSFT0011")
  Name (_UID, 1)
}
</code></pre>
<p>You can find this driver under windows driverstore folder</p>
<p><code>C:\Windows\System32\DriverStore\FileRepository\mptfcustomizeiosignalclient.inf_*</code></p>
<p>If it loads with no errors you will see it loaded as MPTF Custom IO Signal Client Driver in device manager.</p>
<p><img src="how/ec/thermal/mptf/media/device_manager.png" alt="MPTF Driver" /></p>
<h2 id="microsoft-temperature-sensor-driver"><a class="header" href="#microsoft-temperature-sensor-driver">Microsoft Temperature Sensor Driver</a></h2>
<p>The Temperature Sensor Driver is an input to MPTF that allows MPTF to take actions based on skin temperature or other sensors external to the CPU. Details of the MPTF temperature sensor can be found in the MTPF specification.</p>
<p>The following ACPI entry is necessary to load the Temperature Sensor Driver</p>
<pre><code>// Skin temperature sensor
Device(TMP1) {
  Name(_HID, "MSFT000A")
  Name (_UID, 1)
  ...
</code></pre>
<p>The driver is in windows driverstore folder</p>
<p><code>C:\Windows\System32\DriverStore\FileRepository\mstemperaturesensor.inf_* </code></p>
<p>If it loads with no failures you should see it listed in device manager</p>
<p><img src="how/ec/thermal/mptf/media/temp_sensor.png" alt="Temp Sensor" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="acpi-entries-for-mptf"><a class="header" href="#acpi-entries-for-mptf">ACPI Entries for MPTF</a></h1>
<p>Windows will boot and run without the MPTF driver loading, however it will not provide any inbox default handling of thermal control.</p>
<p>For any MPTF functionality the Core Driver must be loaded with the following ACPI entry</p>
<pre><code>// MPTFCore Driver
Device(MPC0) {
  Name(_HID, "MSFT000D")
  Name (_UID, 1)
}
</code></pre>
<p>There is no requirement to define further resources through the core driver those are all controlled by the IO driver entries.</p>
<h2 id="microsoft-temperature-sensor-driver-1"><a class="header" href="#microsoft-temperature-sensor-driver-1">Microsoft Temperature Sensor Driver</a></h2>
<p>This driver is loaded uner MSFT000A entry, it must always define a _TMP method and _DSM with support for function 0 and function1. If just these two functions are supported function 0 will return 0x3</p>
<pre><code>  Method (_TMP) {
    // Check to make sure FFA is available and not unloaded
    If(LEqual(\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
      CreateByteField(BUFF,19, TMP1) // In ‚Äì Thermal Zone Identifier
      CreateField(BUFF,144,32,TMPD) // Out ‚Äì temperature for TZ

      Store(20, LENG)
      Store(0x1, CMDD) // EC_THM_GET_TMP
      Store(1,TMP1)
      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (TMPD)
      }
    }
    Return(Zero)
  }

  // Update Thresholds
  Method(STMP, 0x2, Serialized) {
    // Check to make sure FFA is available and not unloaded
    If(LEqual(\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
      CreateByteField(BUFF,19, TID1) // In ‚Äì Thermal Zone Identifier
      CreateDwordField(BUFF,20,THS1) // In ‚Äì Timeout in ms
      CreateDwordField(BUFF,24,THS2) // In ‚Äì Low threshold tenth Kelvin
      CreateDwordField(BUFF,28,THS3) // In ‚Äì High threshold tenth Kelvin
      CreateField(BUFF,144,32,THSD) // Out ‚Äì Status from EC

      Store(0x30, LENG)
      Store(0x2, CMDD) // EC_THM_SET_THRS
      Store(1,TID1)
      Store(0,THS1) // Timout in ms 0 ignore
      Store(Arg0,THS2) // Low Threshold
      Store(Arg1,THS3) // High Threshold
      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (THSD)
      }
    }
    Return(Zero)
  }


  // Arg0 GUID
  //      1f0849fc-a845-4fcf-865c-4101bf8e8d79 - Temperature GUID
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    // Input Variable
    If(LEqual(ToUuid("1f0849fc-a845-4fcf-865c-4101bf8e8d79"),Arg0)) {
        Switch(Arg2) {
          Case(0) {
            // We support function 0,1
            Return (Buffer() {0x03, 0x00, 0x00, 0x00})
          }
          // Update Thresholds
          // Arg3 = Package () { LowTemp, HighTemp }
          Case(1) {
            Return(STMP(DeRefOf(Index(Arg3,0)),DeRefOf(Index(Arg3,1)))) // Set Temp low and high threshold
          }
        }
    }

    Return (Ones)
  }
</code></pre>
<h2 id="microsoft-customized-io-signal-driver"><a class="header" href="#microsoft-customized-io-signal-driver">Microsoft Customized IO Signal Driver</a></h2>
<p>This driver is loaded under MSFT0011 entry, and must always define Function 0 for both input and output devices. Function 0 is a bitmask of all the other variables that are supported on this platform. If you support functions 1,2,3 you would return 0b1111 (0xf) to indicate support for function 0-3.</p>
<pre><code>  // Arg0 GUID
  //      07ff6382-e29a-47c9-ac87-e79dad71dd82 - Input
  //      d9b9b7f3-2a3e-4064-8841-cb13d317669e - Output
  // Arg1 Revision
  // Arg2 Function Index
  // Arg3 Function dependent
  Method(_DSM, 0x4, Serialized) {
    // Input Variable
    If(LEqual(ToUuid("07ff6382-e29a-47c9-ac87-e79dad71dd82"),Arg0)) {
        Switch(Arg2) {
          Case(0) {
            // We support function 0-3
            Return (Buffer() {0x0f, 0x00, 0x00, 0x00})
          }
          Case(1) {
            Return(GVAR(1,ToUuid("db261c77-934b-45e2-9742-256c62badb7a"))) // MinRPM
          }
          Case(2) {
            Return(GVAR(1,ToUuid("5cf839df-8be7-42b9-9ac5-3403ca2c8a6a"))) // MaxRPM
          }
          Case(3) {
            Return(GVAR(1,ToUuid("adf95492-0776-4ffc-84f3-b6c8b5269683"))) // CurrentRPM
          }
        }
        Return(Ones)
    }
    // Output Variable
    If(LEqual(ToUuid("d9b9b7f3-2a3e-4064-8841-cb13d317669e"),Arg0)) {
        Switch(Arg2) {
          Case(0) {
            // We support function 0-3
            Return (Buffer() {0x0f, 0x00, 0x00, 0x00})
          }
          Case(1) {
            Return(SVAR(1,ToUuid("db261c77-934b-45e2-9742-256c62badb7a"),Arg3)) // MinRPM
          }
          Case(2) {
            Return(SVAR(1,ToUuid("5cf839df-8be7-42b9-9ac5-3403ca2c8a6a"),Arg3)) // MaxRPM
          }
          Case(3) {
            Return(SVAR(1,ToUuid("adf95492-0776-4ffc-84f3-b6c8b5269683"),Arg3)) // CurrentRPM
          }
        }
        Return(Ones)
    }

    Return (Ones)
  }
</code></pre>
<p>In this case we've assigned the following meanings to supported functions</p>
<pre><code>Function 1 --&gt; MinRPM
Function 2 --&gt; MaxRPM
Function 3 --&gt; CurrentRPM
</code></pre>
<p>The meaning of what Function 1 does is mapped by the configuration Blob for your device, so Function 1 need not always be MinRPM. For communication with the EC we've assigned UUID's to each variable we support on the EC. This allows us to keep the same UUID for MinRPM on all platform implementations even though it may be a different function.</p>
<p>The following is the list of UUID's and variables we have defined for our reference implementation, but further mappings can be added by OEM's as well.</p>
<table>
<thead>
<tr class="header">
<th><strong>Variable</strong></th>
<th><strong>GUID</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<td>OnTemp</td>
<td>ba17b567-c368-48d5-bc6f-a312a41583c1</td>
<td>Lowest temperature at which the fan is turned on.</td>
</tr>
<td>RampTemp</td>
<td>3a62688c-d95b-4d2d-bacc-90d7a5816bcd</td>
<td>Temperature at which the fan starts ramping from min speed.</td>
</tr>
<td>MaxTemp</td>
<td>dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76</td>
<td>Temperature at top of fan ramp where fan is at maximum speed.</td>
</tr>
<td>CrtTemp</td>
<td>218246e7-baf6-45f1-aa13-07e4845256b8</td>
<td>Critical temperature at which we need to shut down the system.</td>
</tr>
<td>ProcHotTemp</td>
<td>22dc52d2-fd0b-47ab-95b8-26552f9831a5</td>
<td>Temperature at which the EC will assert the PROCHOT notification.</td>
</tr>
<td>MinRpm</td>
<td>db261c77-934b-45e2-9742-256c62badb7a</td>
<td>Minimum RPM FAN speed</td>
</tr>
<td>MinDba (Optional)</td>
<td>0457a722-58f4-41ca-b053-c7088fcfb89d</td>
<td>Minimum Dba from FAN</td>
</tr>
<td><p>MinSones (Optional)</td>
<td>311668e2-09aa-416e-a7ce-7b978e7f88be</td>
<td>Minimum Sones from FAN</td>
</tr>
<td>MaxRpm</td>
<td>5cf839df-8be7-42b9-9ac5-3403ca2c8a6a</td>
<td>Maximum RPM for FAN</td>
</tr>
<td>MaxDba (Optional)</td>
<td>372ae76b-eb64-466d-ae6b-1228397cf374</td>
<td>Maximum DBA for FAN</td>
</tr>
<td>MaxSones (Optional)</td>
<td>6deb7eb1-839a-4482-8757-502ac31b20b7</td>
<td>Maximum Sones for FAN</td>
</tr>
<td>ProfileType</td>
<td>23b4a025-cdfd-4af9-a411-37a24c574615</td>
<td>Set profile for EC, gaming, quiet, lap, etc</td>
</tr>
<td>CurrentRpm</td>
<td>adf95492-0776-4ffc-84f3-b6c8b5269683</td>
<td>The current RPM of FAN</td>
</tr>
<td>CurrentDba (Optional)</td>
<td>4bb2ccd9-c7d7-4629-9fd6-1bc46300ee77</td>
<td>The current Dba from FAN</td>
</tr>
<td>CurrentSones (Optional)</td>
<td>7719d686-02af-48a5-8283-20ba6ca2e940</td>
<td>The current Sones from FAN</td>
</tr>
</tbody>
</table>
<h2 id="acpi-communication-to-ec"><a class="header" href="#acpi-communication-to-ec">ACPI communication to EC</a></h2>
<p>MPTF refers to input and output channel values, however these need to be communicated to the EC. Above code refers to GVAR and SVAR to get a variable or set a variable. The following ACPI shows example of how to conver this to an FFA command which is sent to the secure EC service and then communicated to the EC. Further details of how this data is sent to the EC is covered in the EC Service section.</p>
<pre><code>  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(GVAR,2,Serialized) {
    If(LEqual(\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(52){})
        CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
        CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
        CreateField(BUFF, 128, 128, UUID) // UUID of service
        CreateField(BUFF, 256, 8, CMDD) // Command register
        CreateField(BUFF, 264, 8, INST) // In ‚Äì Instance ID
        CreateField(BUFF, 272, 16, VLEN) // In ‚Äì Variable Length in bytes
        CreateField(BUFF, 288, 128, VUID) // In ‚Äì Variable UUID
        CreateField(BUFF, 264, 64, RVAL) // Out ‚Äì Variable value

        Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
        Store(0x5, CMDD) // EC_THM_GET_VAR
        Store(Arg0,INST) // Save instance ID
        Store(4,VLEN) // Variable is always DWORD here
        Store(Arg1, VUID)
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
    
        If(LEqual(STAT,0x0) ) // Check FF-A successful?
        {
        Return (RVAL)
        }
      }
      Return (Ones)
    }

  // Arg0 Instance ID
  // Arg1 UUID of variable
  // Return (Status,Value)
  Method(SVAR,3,Serialized) {
    If(LEqual(\_SB_.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(56){})
    
      CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
      CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
      CreateField(BUFF, 128, 128, UUID) // UUID of service
      CreateField(BUFF, 256, 8, CMDD) // Command register
      CreateField(BUFF, 264, 8, INST) // In ‚Äì Instance ID
      CreateField(BUFF, 272, 16, VLEN) // In ‚Äì Variable Length in bytes
      CreateField(BUFF, 288, 128, VUID) // In ‚Äì Variable UUID
      CreateField(BUFF, 416, 32, DVAL) // In ‚Äì Variable Data
      CreateField(BUFF, 264, 64, RVAL) // Out ‚Äì Variable value

      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
      Store(0x6, CMDD) // EC_THM_SET_VAR
      Store(Arg0,INST) // Save instance ID
      Store(4,VLEN) // Variable is always DWORD here
      Store(Arg1, VUID)
      Store(Arg2,DVAL)
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (RVAL)
      }
    }
    Return (Ones)
  }

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-blob"><a class="header" href="#configuration-blob">Configuration Blob</a></h1>
<p>The configuration blob data is owned by the OEM and allows custom actions to be taken on output paramters based on input channels and settings.</p>
<p>There are two files used to define configuration of the blob:</p>
<ul>
<li>PocSpec.txt -  Defines Input and Output GUID's and actions to map input to outputs</li>
<li>PocIF.txt - For a given GUID maps valid ranges and mapping to ACPI output functions</li>
</ul>
<p>Both these files live directly under the root folder, but will likely move in the future.
<br><b>Note: </b> If these files are not present or found the MPTF Core driver will yellow bang.</p>
<h2 id="pocspectxt"><a class="header" href="#pocspectxt">PocSpec.txt</a></h2>
<p>This file defines UUID's for input and output devices. If using an input or output from the OS you must use the existing UUID definitions found in the MPTF documentation.</p>
<p>In this case the output device is defined in the PocIF.txt but must be unique UUID if you are creating your own output channels.</p>
<pre><code>//
// INPUT
   #macro I_OS_PWR_MODE_MPTF         {8945AB0A-35DD-4BEE-82A5-8138892C280D}_1
//
// OUTPUT
   #macro O_FAN1_ACTIVE_RPM           	{91F589E0-45F0-4C6E-A17D-24FD8E8CBDCE}_730

//
// DEMO-B - OS Power Mode Driven Fan RPM
//		Will monitor the OS PWR MODE and then in a lookup TABLE output a target RPM stored in O_FAN1_ACTIVE_RPM
1,0,0,%A_TABLE%,1,1,1,%I_OS_PWR_MODE_MPTF%,%O_FAN1_ACTIVE_RPM%,4,0,0,1,3,5,7,2,4,6,7,15,25,35,45
</code></pre>
<p>The last line monitors the input values selected in the OS from the power mode and maps this to output values for O_FAN1_ACTIVE_RPM. The last 4 values are the output values in this case in percentage for the fan speed 15,25,35,45.</p>
<p>@Douglas to fill in further details on the meaning of these other mapping bits</p>
<h2 id="pociftxt"><a class="header" href="#pociftxt">PocIF.txt</a></h2>
<p>This file maps an output channel to an ACPI function along with default, min and max values</p>
<pre><code>// O_FAN1_ACTIVE_RPM  
{91F589E0-45F0-4C6E-A17D-24FD8E8CBDCE}_730,1,60,10,20,2,"\_SB.CIO1"
</code></pre>
<p>Here the last two parameters maps this output to function 2 in the _DSM function of _SB.CIO1 device in ACPI.</p>
<p>The value before (20) is the default value set if no value is set by the OS.</p>
<p>Previous two values 60,10 are the maximum and minimum valid values.</p>
<p>@Douglas to provide further details on the spec</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>This section describes the order you should follow when validating the MPTF and log files to capture.</p>
<h2 id="loading-drivers"><a class="header" href="#loading-drivers">Loading Drivers</a></h2>
<p>The first step is to make sure the MPTF drivers are loaded successfully in device manager.</p>
<p>In device manager expand the Thermal devices tab to make sure see the following three devices listed without any yellow bang.</p>
<p><img src="how/ec/thermal/mptf/media/device_manager.png" alt="MPTF Driver" /></p>
<p>If you don't see the "Thermal devices" in device manager, you are either missing the ACPI entries or the files are not present in your windows folder. Review the sections on ACPI and the MPTF drivers to make sure all the files are present.</p>
<p>If MPTF Core Driver is present but yellow banged, this is normally because of a failure in parsing the PocIF.txt and PocSpec.txt files in the root folder. Make sure these are present and look valid or try a simpler file. If they are valid collect logs that are listed in the Logging section below and review/share.</p>
<p>If Microsoft Customized IO Driver is present but yellow banged, this is normally an issue with your configuration files and ACPI _DSM definitions for input and output devices. Review your ACPI entries for MSFT0011 and make sure all functions referenced in the PocIF.txt are present and valid in your ACPI tables. For further debug collect logs and see section on ACPI debugging to debug ACPI</p>
<p>If MPTF Custom IO Signal Client River is present but yellow banged, this indicates there is normally a problem in your custom input/output driver component. Enable logging in your driver and make sure it is loaded successfully and no failures. Enable all other logs under logging and review content.</p>
<p>Sometimes drivers will not load correctly if the MPTF service is not running so be sure to make sure in your service manager that MPTF service is running and set to automatically start.</p>
<p><img src="how/ec/thermal/mptf/media/mptf_service.png" alt="MPTF service" /></p>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Logging has moved to EventViewer traces. To view the MPTF events open Event Viewer (eventvwr.msc) and browse to Applications and Services -&gt; Microsoft -&gt; Windows -&gt; MPTF</p>
<p>You will see the MPTF events here for debugging and tracing behaviors.</p>
<p><img src="how/ec/thermal/mptf/media/mptf_log.png" alt="MPTF debugging" /></p>
<p>If using secure EC services and sending commands via FFA these logs are captured to the serial port, in this case you should see the output channel value being written to the variable on the serial port logs</p>
<pre><code>15:29:00.621 : SP 8003: DEBUG - set_variable instance id: 0x1
15:29:00.622 : SP 8003:                 length: 0x4
15:29:00.623 : SP 8003:                 uuid: 5cf839df-8be7-42b9-9ac5-3403ca2c8a6a
15:29:00.623 : SP 8003:                 data: 0x19
</code></pre>
<h2 id="acpi-debugging"><a class="header" href="#acpi-debugging">ACPI Debugging</a></h2>
<p>Since input and output devices go through ACPI calls you may find yourself needing to debug content in ACPI.</p>
<pre><code>!amli set spewon verboseon traceon dbgbrkon
!amli bp \_SB.CIO1._DSM
!amli bl
!amli dns /s \_SB.CIO1
</code></pre>
<p>For further details on ACPI debugging see <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/introduction-to-the-amli-debugger">AMLI Debugging</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-service"><a class="header" href="#ec-service">EC Service</a></h1>
<p>On ARM platforms where the interface to the EC is in the secure world, we have a service that runs in the secure world that translates requests from the OS to commands sent to the EC. In the case of MPTF there is a Thermal Service that runs within the EC service to handle requests for custom IO.</p>
<p><img src="how/ec/thermal/mptf/media/odp_arch.png" alt="EC Service" /></p>
<h2 id="acpi-to-ec-service-communication"><a class="header" href="#acpi-to-ec-service-communication">ACPI to EC Service Communication</a></h2>
<p>The EC Specification defines commands for get variable and set variable.</p>
<pre><code>EC_THM_GET_VAR = 0x5
EC_THN_SET_VAR = 0x6
</code></pre>
<p>Get variable passes in the following structure.</p>
<pre><code>struct GetVar {
    inst: u8,  // Instance of thermal device, there may be multiple fans
    len: u16,  // Length of the variable in this case always 4 bytes
    uuid: uuid, // UUID of the variable see spec
}
</code></pre>
<p>This will return status and data</p>
<p>Set variable passes in the following structure</p>
<pre><code>struct SetVar {
    inst: u8,  // Instance of thermal device, there may be multiple fans
    len: u16,  // Length of the variable in this case always 4 bytes
    uuid: uuid, // UUID of the variable see spec
    data: u32, // 32-bit data to write to variable
}
</code></pre>
<p>Returns status.</p>
<p>See ACPI section for further details of FFA definition and sending commands. The instance is normally hard coded in ACPI based off the instance definition of ACPI.</p>
<h2 id="ec-service-to-ec-communication"><a class="header" href="#ec-service-to-ec-communication">EC Service to EC Communication</a></h2>
<p>The communication between the EC service in the secure world and over to the EC MCU itself can vary from platform to platform.</p>
<p>In the example given here the EC is connected via eSPI and we map a chunk of memory in the peripheral channel directly to various variables. The variable maps to an offset in the peripheral channel where the read and write is done for the corresponding entry.</p>
<p>The EC Firmware is notified when a region of memory is updated and will adjust fan and hardware logic based on these new values.</p>
<p><img src="how/ec/thermal/mptf/media/acpi_haf_ec.png" alt="EC Comm" /></p>
<p>The EC service receives the get/set variable requests in the thermal service</p>
<p><code>haf-ec-service/ec-service-lib/src/services/thermal/mod.rs</code></p>
<pre><code>            EC_THM_GET_VAR =&gt; {
                rsp.struct_to_args64(&amp;self.get_variable(msg));
                Ok(rsp)
            }
            EC_THM_SET_VAR =&gt; {
                rsp.struct_to_args64(&amp;self.set_variable(msg));
                Ok(rsp)
            }
</code></pre>
<p>From here it converts it to eSPI peripheral reads and writes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-service-acpi"><a class="header" href="#ec-service-acpi">EC Service ACPI</a></h1>
<p>Sometimes the GVAR and SVAR from CIO may directly map to memory mapped OpRegion in an EC controller such as on Intel platforms. In the case where EC service is present in the secure world on ARM platforms we need to setup a bit more content.</p>
<p>All the communication between non-secure side (NTOS) and secure side (EC Secure Partition) is done through a standard called FF-A.</p>
<p><a href="https://developer.arm.com/Architectures/Firmware%20Framework%20for%20A-Profile">FF-A Specification</a></p>
<h2 id="ffa-acpi-defintion"><a class="header" href="#ffa-acpi-defintion">FFA ACPI Defintion</a></h2>
<p>Make sure in your system in ACPI you have FFA device defined and corresponding _DSD and _DSM methods according to FFA documentation.</p>
<pre><code>Device(\_SB_.FFA0) {
  Name(_HID, "MSFT000C")

  OperationRegion(AFFH, FFixedHw, 2, 144) 
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }     
  ...
  Method(AVAL,0x0, Serialized)
  {
    Return(One)
  }
</code></pre>
<p>This should also implment the AVAL function to determine that FFA is loaded and can be used by other ACPI references. If you directly reference FFA0 without checking this if the FFA driver is not loaded can lead to deadlock and other OS issues.</p>
<h2 id="making-ffa-calls"><a class="header" href="#making-ffa-calls">Making FFA Calls</a></h2>
<p>As previously documented in the MPTF section, in the SVAR and GVAR we make calls into FFA. This section documents those parameters in more detail.</p>
<pre><code>    If(LEqual(\_SB.FFA0.AVAL,One)) {        // First check to make sure FFA0 device is available
        Name(BUFF, Buffer(52){})            // Allocate a buffer large enough for all input and output data
        CreateField(BUFF, 0, 64, STAT)      // All FFA commands must have 64-bits status returned
        CreateField(BUFF, 64, 64, RCVD)     // ReceiverId left as zero is populated by the framework
        CreateField(BUFF, 128, 128, UUID)   // UUID of service we want to talk to in this case Thermal Service
        CreateField(BUFF, 256, 8, CMDD)     // Command to send to this service
        CreateField(BUFF, 264, 8, INST)     // Remaining entries are command specific input and output structure definition
        CreateField(BUFF, 272, 16, VLEN) 
        CreateField(BUFF, 288, 128, VUID) 
        CreateField(BUFF, 264, 64, RVAL)    // Output structure will overlap with input data

        Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Populate the Thermal Service UUID
        Store(0x5, CMDD)                    // Write command EC_THM_GET_VAR into buffer
        Store(Arg0,INST)                    // Save instance ID into buffer
        Store(4,VLEN)                       // Variable is always DWORD here
        Store(Arg1, VUID)                   // Variable UUID 
        
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF) // Writes BUFF to FFA operation region this actually sends FFA request and gets response
    
        If(LEqual(STAT,0x0) )               // Check FF-A successful?
        {
            Return (RVAL)                   // Return data in the out buffer
        }
      }
      // Otherwise return an error
</code></pre>
<p>For MPTF we mostly just need Get/Set varaible commands and notifications.</p>
<h2 id="ec-notifications"><a class="header" href="#ec-notifications">EC Notifications</a></h2>
<p>The EC can also send notifications back to the OS if certain events occur. All the notifications come initially through the FFA0 device. When device is defined in ACPI you must list all the logical notification events you expect and the handler for notifications.</p>
<pre><code>Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              1, // Count of following packages
              Package () {
                     ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), // UUID for thermal
                     Package () {
                          0x01,     // EC_THM_HOT
                          0x02,     // EC_THM_LOW crossed low threshold
                          0x03,     // EC_THM_HIGH crossed high threshold
                      }
              }
         }
      }
    }
  }) // _DSD()

  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Local0 = DeRefOf(Index(Arg3,1))
        Store(Local0,\_SB.ECT0.NEVT )

        Switch(Local0) {
          Case(1) {
            // Handle HOT notification
          }
          Case(2) {
            // Handle Low temp notification
          }
          Case(3) {
            // Handle High temp notification
          }
        }
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-service-debugging"><a class="header" href="#ec-service-debugging">EC Service Debugging</a></h1>
<p>Since the EC service runs in the secure world you cannot debug it through windbg. Most debugging is done through serial log messages or JTAG with SWD.</p>
<p>For SWD debugging see references to Hafnium and JTAG debugging.</p>
<h1 id="serial-debug"><a class="header" href="#serial-debug">Serial Debug</a></h1>
<p>In the code you can simply use println or logging interface and these messages will be routed to serial port by default.</p>
<p>Eg.</p>
<pre><code>        println!(
            "set_variable instance id: 0x{:x}
                length: 0x{:x}
                uuid: {}
                data: 0x{:x}",
            req.id, req.len, req.var_uuid, req.data
        );
</code></pre>
<p>You will see these messages printed out on the serial terminal</p>
<pre><code>15:29:00.621 : SP 8003: DEBUG - set_variable instance id: 0x1
15:29:00.622 : SP 8003:                 length: 0x4
15:29:00.623 : SP 8003:                 uuid: 5cf839df-8be7-42b9-9ac5-3403ca2c8a6a
15:29:00.623 : SP 8003:                 data: 0x19
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcu-firmware"><a class="header" href="#mcu-firmware">MCU Firmware</a></h1>
<p>The MCU Firmware has a region of 256 bytes that is mapped as the peripheral channel on eSPI. This is used to read and write 32-bit values to and from the EC. Based on the parameters that we read and write the MCU firmware will adjust fan speeds and other parameters within the EC that adjust thermal.</p>
<p><img src="how/ec/thermal/mptf/media/fan.png" alt="MCU Variables" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apps-to-mcu-interface"><a class="header" href="#apps-to-mcu-interface">Apps to MCU Interface</a></h1>
<p>When using eSPI transport we define a mapped memory region in the peripheral bus, that must be agreed on between apps side and MCU side.</p>
<p><a href="https://www.intel.com/content/www/us/en/content-details/841685/enhanced-serial-peripheral-interface-espi-interface-base-specification-for-client-and-server-platforms.html">eSPI Specification</a></p>
<h2 id="memory-layout-definition"><a class="header" href="#memory-layout-definition">Memory Layout Definition</a></h2>
<p>Both apps side and MCU side are using RUST, we define the memory layout in YAML format and currently have a python script that converts this to a RUST format.</p>
<p><code>embedded-services/embedded-service/src/ec_type/generator/ec_memory.yaml</code></p>
<pre><code># EC Memory layout definition

Version:
  major:
    type: u8
  minor:
    type: u8
  spin:
    type: u8
  res0:
    type: u8
...
# Size 0x38
Thermal:
  events:
    type: u32
  cool_mode:
    type: u32
  dba_limit:
    type: u32
  sonne_limit:
    type: u32
  ma_limit:
    type: u32
  fan1_on_temp:
    type: u32
  fan1_ramp_temp:
    type: u32
  fan1_max_temp:
    type: u32
  fan1_crt_temp:
    type: u32
  fan1_hot_temp:
    type: u32
  fan1_max_rpm:
    type: u32
  fan1_cur_rpm:
    type: u32
  tmp1_val:
    type: u32
  tmp1_timeout:
    type: u32
  tmp1_low:
    type: u32
  tmp1_high:
    type: u32

</code></pre>
<h2 id="converting-yaml-to-rust"><a class="header" href="#converting-yaml-to-rust">Converting YAML to RUST</a></h2>
<p>To convert YAML to RUST simply run the ec-memory-generator.py using the following command</p>
<p><code>python ec-memory-generator.py ec_memory.yaml</code></p>
<p>This will outut the following two files for C based structure definition and RUST based</p>
<pre><code>structure.rs
ecmemory.h
</code></pre>
<p>When compiling embedded-services the structure.rs must be copied under</p>
<p><code>embedded-services/embedded-service/src/ec_type</code></p>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>Any time a breaking change is made the major version must be updated and if EC and apps don't agree on a major version the fields cannot be interpreted. Whenever possible we only want to add fields which means we can keep the structure backwards compatible and just the minor version can be updated.</p>
<h2 id="mcu-espi-service"><a class="header" href="#mcu-espi-service">MCU eSPI Service</a></h2>
<p>When the apps modifies or writes some value into the peripheral channel on the MCU side a service can register for notifications to specific regions of the memory map. The handling of all eSPI events can be found in</p>
<p><code>embedded-services/espi-service/src/espi_service.rs</code></p>
<p>This contains the entry point and main message handling loop.</p>
<pre><code>#[embassy_executor::task]
pub async fn espi_service(mut espi: espi::Espi&lt;'static&gt;, memory_map_buffer: &amp;'static mut [u8]) {
    info!("Reserved eSPI memory map buffer size: {}", memory_map_buffer.len());
    info!("eSPI MemoryMap size: {}", size_of::&lt;ec_type::structure::ECMemory&gt;());
    ...
    loop {
        ...
    }
</code></pre>
<p>VWire events and Peripheral channel events come in on Port 0, while OOB messages come in on Port 1. For details about the eSPI protocol see the eSPI secification</p>
<p>Based on the offset of the access in the peripheral channel the data is routed to the correct service</p>
<pre><code>    if offset &gt;= offset_of!(ec_type::structure::ECMemory, therm)
                &amp;&amp; offset &lt; offset_of!(ec_type::structure::ECMemory, therm) + size_of::&lt;ec_type::structure::Thermal&gt;()
    {
        self.route_to_thermal_service(&amp;mut offset, &amp;mut length).await?;
    }
</code></pre>
<p>This gets converted to a transport independent message and routed to the thermal endpoint that can register and listen for these messages</p>
<pre><code>    async fn route_to_thermal_service(&amp;self, offset: &amp;mut usize, length: &amp;mut usize) -&gt; Result&lt;(), ec_type::Error&gt; {
        let msg = {
            let memory_map = self.ec_memory.borrow();
            ec_type::mem_map_to_thermal_msg(&amp;memory_map, offset, length)?
        };

        comms::send(
            EndpointID::External(External::Host),
            EndpointID::Internal(Internal::Thermal),
            &amp;msg,
        )
        .await
        .unwrap();

        Ok(())
    }
    ```
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mcu-debugging"><a class="header" href="#mcu-debugging">MCU Debugging</a></h1>
<p>Debugging on the MCU side is done primarily with J-Link SWD connection. Some platforms will provide a dedicated serial port to the MCU that allows debug print messages.</p>
<h2 id="j-link-debugging"><a class="header" href="#j-link-debugging">J-Link Debugging</a></h2>
<p>With JTAG debugger you can set breakpoints and step through MCU side code as well as print messages out through the JTAG port using probe-rs.</p>
<pre><code>    info!("Reserved eSPI memory map buffer size: {}", memory_map_buffer.len());
    info!("eSPI MemoryMap size: {}", size_of::&lt;ec_type::structure::ECMemory&gt;());
</code></pre>
<p>@Jerry and Felipe to provide further details or link to MCU debugging document</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mptf-demo"><a class="header" href="#mptf-demo">MPTF Demo</a></h1>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You will need a hardware platform that has the following:</p>
<ul>
<li>Boots OS 26400 or later with MPTF support</li>
<li>ACPI changes for Custom IO and MPTF driver loading</li>
<li>haf-ec-service with eSPI or other transport from ODP</li>
<li>MCU firmware code that runs on your MCU from ODP</li>
</ul>
<h2 id="mptf-and-customized-io"><a class="header" href="#mptf-and-customized-io">MPTF and Customized IO</a></h2>
<p>After booting the device copy both the following PocIF.txt and PocSpec.txt to root folder on the device</p>
<ul>
<li><a href="how/ec/thermal/mptf/media/PocIF.txt">PocIF.txt</a></li>
<li><a href="how/ec/thermal/mptf/media/PocSpec.txt">PocSpec.txt</a></li>
</ul>
<p><img src="how/ec/thermal/mptf/media/files.png" alt="Copy Files" /></p>
<p>After copying these files we reboot the computer and check in device manager to make sure MPTF devices are all running with no failures.</p>
<p><img src="how/ec/thermal/mptf/media/device_man_full.png" alt="Device manager" /></p>
<p>Open System Settings and select Power</p>
<p><img src="how/ec/thermal/mptf/media/power_mode.png" alt="Power mode" /></p>
<p>With windbg connecteded and logging enabled for Microsoft Custom IO driver when we change the power mode we will see values being selected.</p>
<pre><code>!wmitrace.stop MptfIo -kd
!wmitrace.start MptfIo -kd
!wmitrace.enable MptfIo {D0ABE2A4-A604-4BEE-8987-55C529C06185} -level 0x7 -flag 0xFFFF
!wmitrace.dynamicprint 1
.reload /f
</code></pre>
<p>As you select the different values for Balanced, Best Performance etc you will see it executing the Customized IO functions with the corresponding values defined form the PocSpec.</p>
<pre><code>[1]0004.03A4::04/28/2025-10:58:28.051 [kernel] [SmfInterface_RequestCompletionHandling]Deferred execution: Data write activated
[1]0004.03A4::04/28/2025-10:58:28.067 [mptfcustomizeiosignalclient] [MptfInterfaceDataSet]MptfInterfaceDataSet Received data on channel:0 with value:35 FunctionId 2.
[3]0004.03A4::04/28/2025-10:58:30.211 [kernel] [SmfInterface_RequestCompletionHandling]Deferred execution: Data write activated
[3]0004.03A4::04/28/2025-10:58:30.243 [mptfcustomizeiosignalclient] [MptfInterfaceDataSet]MptfInterfaceDataSet Received data on channel:0 with value:25 FunctionId 2.
[1]0004.03A4::04/28/2025-10:58:32.387 [kernel] [SmfInterface_RequestCompletionHandling]Deferred execution: Data write activated
[1]0004.03A4::04/28/2025-10:58:32.403 [mptfcustomizeiosignalclient] [MptfInterfaceDataSet]MptfInterfaceDataSet Received data on channel:0 with value:15 FunctionId 2.
</code></pre>
<h2 id="hafnium-ec-service"><a class="header" href="#hafnium-ec-service">Hafnium EC Service</a></h2>
<p>Now we demonstrate that the data is received and requests are processed in secure world side. Connecting terminal to our debug serial port we can get the Hanfnium debug messages for each of these power modes we select.</p>
<p>We see that it calls set_variable for instance id: 0x1 with the variable UUID we specify in our ACPI the the value select from the UI</p>
<pre><code>11:02:10.823 : SP 8003: DEBUG - Successfully received ffa msg:
11:02:10.824 : SP 8003:             function_id = c400008d
11:02:10.824 : SP 8003:                    uuid = 31f56da7-593c-4d72-a4b3-8fc7171ac073
11:02:10.824 : SP 8003: DEBUG - Received ThmMgmt command 0x6
11:02:10.824 : SP 8003: DEBUG - set_variable instance id: 0x1
11:02:10.824 : SP 8003:                 length: 0x4
11:02:10.824 : SP 8003:                 uuid: 5cf839df-8be7-42b9-9ac5-3403ca2c8a6a
11:02:10.824 : SP 8003:                 data: 0x23
11:02:12.647 : SP 8003: DEBUG - Successfully received ffa msg:
11:02:12.647 : SP 8003:             function_id = c400008d
11:02:12.648 : SP 8003:                    uuid = 31f56da7-593c-4d72-a4b3-8fc7171ac073
11:02:12.648 : SP 8003: DEBUG - Received ThmMgmt command 0x6
11:02:12.648 : SP 8003: DEBUG - set_variable instance id: 0x1
11:02:12.648 : SP 8003:                 length: 0x4
11:02:12.648 : SP 8003:                 uuid: 5cf839df-8be7-42b9-9ac5-3403ca2c8a6a
11:02:12.648 : SP 8003:                 data: 0x19
11:02:14.199 : SP 8003: DEBUG - Successfully received ffa msg:
11:02:14.199 : SP 8003:             function_id = c400008d
11:02:14.200 : SP 8003:                    uuid = 31f56da7-593c-4d72-a4b3-8fc7171ac073
11:02:14.200 : SP 8003: DEBUG - Received ThmMgmt command 0x6
11:02:14.200 : SP 8003: DEBUG - set_variable instance id: 0x1
11:02:14.200 : SP 8003:                 length: 0x4
11:02:14.200 : SP 8003:                 uuid: 5cf839df-8be7-42b9-9ac5-3403ca2c8a6a
11:02:14.200 : SP 8003:                 data: 0xf
</code></pre>
<h2 id="ec-mcu-functionality"><a class="header" href="#ec-mcu-functionality">EC MCU Functionality</a></h2>
<p>Finally we validate that the uCode running on the MCU actually receives this data and takes the correct corresponding action. In this example we directly map this variable to the fan RPM as a percentage. As you change the setting in the UI and see the commands in Hafnium EC Service changing values in peripheral channel on the MCU side we receive those notfications and set the fan speed accordingly</p>
<p>Add debug output from MCU here as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-thermal-component-example"><a class="header" href="#the-thermal-component-example">The Thermal Component Example</a></h1>
<p>In this example we will be constructing a functioning mock thermal component subsystem.</p>
<p><em>TODO -- this will closely follow the pattern of the Battery example</em></p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The thermal itself will be virtual - no hardware required - and the behavioral aspects of it will be simulated.
We will, however, discuss what one would do to implement actual thermal hardware control in a HAL layer.</p>
<p>In this example, we will:</p>
<ul>
<li>Define the Traits of the thermal component</li>
<li>Identify the hardware actions that fulfill these traits</li>
<li>Define the HAL traits to match these hardware actions</li>
<li>Implement the HAL traits to hardware access (or define mocks for a virtual example)</li>
<li>Wrap this simple Traits implementation into a Device for service insertion</li>
<li>Provide the service layer and insert the device into it</li>
<li>Test the end result with unit tests and simple executions</li>
<li>Update the project for an embedded build and deploy onto hardware.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-we-will-build-the-thermal-component"><a class="header" href="#how-we-will-build-the-thermal-component">How we will build the Thermal Component</a></h1>
<p><em>TODO: This will mirror the similar steps for Battery</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-component-diagrams"><a class="header" href="#thermal-component-diagrams">Thermal component Diagrams</a></h1>
<p><em>TODO: This will mirror similar content for Battery</em></p>
<p>The construction of a component such as our thermal subsystem looks as follows.</p>
<pre class="mermaid">flowchart TD
    A[Service&lt;br&gt;&lt;i&gt;Service initiates query&lt;/i&gt;]
    B[Thermal Subsystem Controller&lt;br&gt;&lt;i&gt;Orchestrates component behavior&lt;/i&gt;]
    C[Thermal Component Trait Interface&lt;br&gt;&lt;i&gt;Defines the functional contract&lt;/i&gt;]
    D[Thermal HAL Implementation&lt;br&gt;&lt;i&gt;Implements trait using hardware-specific logic&lt;/i&gt;]
    E[EC / Hardware Access&lt;br&gt;&lt;i&gt;Performs actual I/O operations&lt;/i&gt;]

    A --&gt; B
    B --&gt; C
    C --&gt; D
    D --&gt; E

    subgraph Service Layer
        A
    end

    subgraph Subsystem Layer
        B
    end

    subgraph Component Layer
        C
        D
    end

    subgraph Hardware Layer
        E
    end
</pre>
<p>When in operation, it conducts its operations in response to message events</p>
<p><em>TODO: Will be similar to battery example diagram</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-component-1"><a class="header" href="#building-the-component-1">Building the component</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mock-thermal-subsystem-project"><a class="header" href="#a-mock-thermal-subsystem-project">A Mock Thermal Subsystem Project</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-odp-repositories-for-defined-thermal-traits"><a class="header" href="#using-the-odp-repositories-for-defined-thermal-traits">Using the ODP repositories for defined Thermal traits</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-values"><a class="header" href="#thermal-values">Thermal values</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-service-preparation"><a class="header" href="#thermal-service-preparation">Thermal Service Preparation</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-service-registry"><a class="header" href="#thermal-service-registry">Thermal Service Registry</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-for-the-embedded-target-1"><a class="header" href="#building-for-the-embedded-target-1">Building for the Embedded Target</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-dependencies"><a class="header" href="#embedded-dependencies">Embedded Dependencies</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="code-changes-required-to-continue-with-embedding-1"><a class="header" href="#code-changes-required-to-continue-with-embedding-1">Code changes required to continue with embedding</a></h2>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-logging-support-1"><a class="header" href="#embedded-logging-support-1">Embedded logging support</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-flashing-1"><a class="header" href="#embedded-flashing-1">Embedded Flashing</a></h1>
<p><em>TODO: Will be similar to Battery content for this section</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connectivity"><a class="header" href="#connectivity">Connectivity</a></h1>
<p><em>TODO</em></p>
<p>possibly include a USB example
may also include mentions (probably not examples) of WiFi and Bluetooth integration</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usb"><a class="header" href="#usb">USB</a></h1>
<p>May or may not produce a sample showing implementation of USB. If there is not an example, there will at least be a discussion.</p>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wifi"><a class="header" href="#wifi">WiFi</a></h1>
<p>May or may not produce and example of implementing WiFi...
If no example, there will at least be a discussion.<br />
This <em>might</em> move to Patina, although I think it may need to be on the EC for certain options to be practical. <em>TBD</em></p>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bluetooth"><a class="header" href="#bluetooth">Bluetooth</a></h1>
<p><em>TODO</em></p>
<p>May or may not produce and example of implementing Bluetooth...
If no example, there will at least be a discussion.<br />
This <em>might</em> move to Patina, although I think it may need to be on the EC for certain options to be practical. <em>TBD</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina-components"><a class="header" href="#patina-components">Patina Components</a></h1>
<p>Creating a component for Patina follows the same principles of development we've seen in building components for the Embedded Controller in that the ODP foundations for a solid, heirarchical design of interlocking layers of functionality are combined to create a modular and trusted component with high flexibility and agility for reuse and portability.</p>
<p>There are some differences in how one sets up for development for Patina, so let's look at that first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-for-patina"><a class="header" href="#setting-up-for-patina">Setting up for Patina</a></h1>
<p>Patina is based upon the foundations of UEFI, and as such, much of the tooling used to build boot firmware
continues to leverage the existing proven tools from Tianocore, such as the <code>stuart_build</code> set of commands, and many other parts familiar within the EDK II framework.</p>
<p>The steps to setting up the tooling can be found documented in the Readme of the <a href="https://github.com/OpenDevicePartnership/patina-qemu">patina-qemu</a> repository, but what is not immediately clear from that discussion is the role that different repositories play.  This is a bit of a marathon, so we'll walk through it here.</p>
<h3 id="the-repositories-involved"><a class="header" href="#the-repositories-involved">The repositories involved</a></h3>
<p>The full umbrella of ODP material encompassses multiple repositories, because ODP covers several diverse aspects of firmware development that speak to different audiences.  Simililarly, the Patina subsection of ODP itself is maintained in multiple repositories, which ones are utilized by a developer will depend upon the goals and scope of a particular project.</p>
<p>The most common Patina-related repositories are as follows</p>
<ul>
<li>
<p><strong>patina</strong> - This maintains a library of crates that implement UEFI-like code in Rust. This defines all of the reusable
'Patina SDK' components that may be pulled into other workflows (such as <em>patina-dxe-core-qemu</em>) to create customized <code>.efi</code> images.</p>
</li>
<li>
<p><strong>patina-dxe-core-qemu</strong> - This repository holds the code responsible for pulling in reusable Rust DXE Core components from the Patina SDK, combining these with locally defined custom components, and building the resulting <code>.efi</code> image that may be loaded into the QEMU emulator.</p>
</li>
<li>
<p><strong>patina-qemu</strong> - This repository supplies a platform wrapper that loads the <code>.efi</code> firmware into QEMU using EDK build tools (<code>stuart_build</code>) from the <code>.efi</code> file indicated at build time.</p>
</li>
<li>
<p><strong>patina-fw-patcher</strong> - This repository simplifies the iterative turnaround for incremental builds in a workflow, once one has been established, able to forego the full <code>stuart_build</code> process for each code update.</p>
</li>
<li>
<p><strong>patina-mtrr</strong> - This repository supports a MTRR(Memory Type Range Registers) API that helps program MTRRs on x86_64 architecture.</p>
</li>
<li>
<p><strong>patina-paging</strong> - Common paging support for various architectures such as ARM64 and X64</p>
</li>
</ul>
<p>In this discussion we will be focused on the steps required to build Patina into a QEMU emulator.  We will be primarily concerned
with the <strong>patina-dxe-core-qemu</strong> and <strong>patina-quemu</strong> repositories for this.</p>
<h2 id="preparing-the-workspace-environment"><a class="header" href="#preparing-the-workspace-environment">Preparing the workspace environment</a></h2>
<p>To explore how to create a component for Patina, we will build and test a simple "hello, world" type test component.
In this example, we will not be building for a host target board, but will be targeting the QEMU emulator instead.</p>
<p>Create a project space for your test component, and in this space, clone the necessary ODP repositories:</p>
<pre><code>git clone https://github.com/OpenDevicePartnership/patina-qemu
git clone https://github.com/OpenDevicePartnership/patina-dxe-core-qemu
</code></pre>
<p>You will be working with these repositories and their examples as you create your own component.</p>
<h2 id="qemu-q35-package"><a class="header" href="#qemu-q35-package">Qemu Q35 package</a></h2>
<p>In these steps, we will be building an emulated platform based on the Intel Q35 chipset. This will demonstrate the Patina UEFI firmware development for x86_64.  The patina-qemu repository also has support for an ARM architecture. Refer there for more information on that approach.  We will focus for now on the x86_64 option.</p>
<h3 id="-follow-the-instructions"><a class="header" href="#-follow-the-instructions">üëâ Follow the instructionsüëà</a></h3>
<p>Your next step is to look at the <code>README</code> of <code>patina-qemu</code>. <em><strong>It contains detailed information on how to properly set up a workspace for the QemuQ35Pkg project</strong></em> we will be working with.</p>
<p>Follow the prompts in the <code>workspace_setup.py</code> script wizard, and accept the recommended options which will result in establishing a python virtual environment and then prompting you to run the script again to build an image for QEMU.</p>
<p>Once you have followed these setup instructions and all has gone well, carefully follow all the steps in the <code>Build and Run</code> section for the <strong>X64 Target</strong>.</p>
<blockquote>
<p>Acquaint yourself with these steps. Note that as we work through our example component project, the normal
development routine will be to switch to the patina-qemu directory, then execute <code>q35env\Scripts\activate.bat</code> to put us  into our Python Virtual Environment (if we aren't already in one).  Then, we will be regularly executing the <code>stuart_build</code>  command as shown in the "Stuart Build and Launch UEfi Shell" section as we move through the example steps.</p>
</blockquote>
<h4 id="pointing-to-the-qemu-dxe-core"><a class="header" href="#pointing-to-the-qemu-dxe-core">Pointing to the qemu-dxe-core</a></h4>
<p>Note that the path passed for <code>BLD_*_DXE_CORE_BINARY_PATH</code> is shown in that example as something like:  "C:\r\patina-dxe-core-qemu\target\x86_64-unknown-uefi".<br />
Unless you happened to create your patina test component project root folder at <code>C:\r</code> (or wish to move it there) this path will have to be changed.
Change the "C:\r" portion of that example path to be the
absolute path to your workspace directory (where you have cloned the repositories).</p>
<h5 id="oops----too-long-a-path"><a class="header" href="#oops----too-long-a-path">Oops -- too long a path</a></h5>
<p>When you build, if you subsequently get an error from NMAKE that the path is too long, you can:</p>
<h5 id="use-the-windows-group-policy-editor-to-enable-long-path-support"><a class="header" href="#use-the-windows-group-policy-editor-to-enable-long-path-support">Use the Windows Group Policy Editor to enable long path support.</a></h5>
<p>Find and run the Group Policy Editor application (<code>gpedit.exe</code>) from the Windows Command Prompt.
Navigate to <code>Computer Configuration</code> -&gt; <code>Administrative Templates</code> -&gt; <code>System</code> -&gt; <code>Filesystem</code> -&gt; <code>Enable Win32 long paths</code>.  Open this policy setting and select <code>enable</code>.</p>
<h5 id="other-solutions-to-the-long-path-problem-include"><a class="header" href="#other-solutions-to-the-long-path-problem-include">Other solutions to the long path problem include:</a></h5>
<ul>
<li>relocating your project directory to a shorter path (e.g. <code>C:\r</code>)</li>
<li>using <code>subst</code> to map this directory to a drive letter (e.g. <code>Z:\</code>)</li>
</ul>
<h5 id="using-subst-for-our-example"><a class="header" href="#using-subst-for-our-example">Using <code>subst</code> for our example</a></h5>
<p>For these examples, we will adopt the last option and use <code>subst</code> to remain consistent with the instructions to follow.</p>
<pre><code>subst Z: &lt;your absolute path to your patina project directory&gt;
</code></pre>
<p>So that Z:\ is now your pantina component project root that contains the two cloned repositories:</p>
<pre><code>Z:\&gt;dir
 Volume in drive Z is Local Disk
 Volume Serial Number is 0A87-D98F

 Directory of Z:\

06/16/2025  09:59 AM    &lt;DIR&gt;          .
06/16/2025  09:58 AM    &lt;DIR&gt;          ..
06/16/2025  10:37 AM    &lt;DIR&gt;          patina-dxe-core-qemu
06/16/2025  11:04 AM    &lt;DIR&gt;          patina-qemu
               0 File(s)              0 bytes
  
</code></pre>
<p>Now, you should be able to follow the steps from "Build and Run", and it should look something like this:</p>
<pre><code>Z:\&gt;cd patina-qemu

Z:\patina-qemu&gt;q35env\Scripts\activate.bat

(q35env) Z:\patina-qemu&gt;stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --flashrom BLD_*_DXE_CORE_BINARY_PATH="Z:\patina-dxe-core-qemu\target\x86_64-unknown-uefi"
</code></pre>
<p>Building will take several minutes.  At the end of this you should see a QEMU window that shows a brief splash graphic and then a shell prompt and output showing success.</p>
<p>You will also see a long train of runtime debug output to the console window.  This will exceed the scroll-back buffer of the window so you won't be able to see the first portion of it.  The tail end of this runtime log will likely contain a number of TRACE level warnings at this stage.  We can ignore this output at this time.</p>
<p>To build without running on QEMU, leave off the <code>--flashrom</code> flag and the path assignment.</p>
<h3 id="what-did-we-just-build"><a class="header" href="#what-did-we-just-build">What did we just build?</a></h3>
<p>The Patina DXE Core was successfully installed into your QEMU emulator!  But the actual Rust code for that is contained within a prebuilt .efi binary.  Next we will look at the steps you will need to take to update that .efi binary so that <em>your</em> firmware development can be set into place.</p>
<p>Now that the QEMU tooling is ready, let's look at getting a customized Patina core with your own component code onto it with the next steps.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patina-dxe-core-qemu-code"><a class="header" href="#patina-dxe-core-qemu-code">Patina-dxe-core-qemu Code</a></h1>
<p>The <a href="https://github.com/OpenDevicePartnership/patina-dxe-core-qemu">"patina-dxe-core-qemu" repository</a> contains the tooling and build steps needed to combine elements of the patina SDK (maintained in the 'patina' repository) with locally provided component code.</p>
<p>Let's review the component parts of UEFI again at this point:</p>
<p><img src="how/patina/tree/./media/PI_Boot_Phases.jpg" alt="UEFI Diagram" /></p>
<p>All of these sections can be found covered in the Patina implementation.
The DXE Core (colloquially pronounced "Dixie") is the Driver Execution Environment and where most of the key development for components is centered.<br />
There is also of course the Runtime Services (RT) that continue beyond boot of the OS.
And there are all the parts in between, including security management, transient system load (TSL) handling, logging, boot device selection, and so forth.
There are some key differences between a conventional UEFI implmentation and Patina.
One such difference is there is no traditional EFI Dispatcher.  Instead, the DXE Core is built monolithically using dependency injection for the drivers that are bound to a prescribed function.</p>
<p>Read more about the monolithic construction model of Patina and other differences from UEFI in the <a href="https://sturdy-adventure-nv32gqw.pages.github.io/component/interface.html">Patina Documentation</a></p>
<h2 id="how-does-this-come-together"><a class="header" href="#how-does-this-come-together">How does this come together?</a></h2>
<p>Within the patina-dxe-core-qemu repository there is a primary file at <code>bin\q35_dxe_core.rs</code> that controls the monolithic construction of the core and its various components.</p>
<p>Inpecting this file, we see a key function, <code>Core::default()</code> that is the launching point for a number of <code>.with_component()</code> and <code>.with_config()</code> calls chained together to construct the complement of our firmware image.</p>
<p>Patina uses a Dependency-Injection scheme to map components and their configurations into the dispatch mechanism, and this is where the registration comes together.</p>
<h2 id="reviewing-and-finalizing-the-setup"><a class="header" href="#reviewing-and-finalizing-the-setup">Reviewing and finalizing the setup</a></h2>
<p>Before we start constructing our own component, let's take a moment to be sure we are set up properly and understand the steps of the process:</p>
<ol>
<li>We will be creating our component within its own project inside our workspace.</li>
<li>We will pass the path of this local component project to the <code>make q35</code> command of <code>patina-dxe-core-qemu</code> and it will combine this with the default stubs from its own sources to create our custom build with our component in it.</li>
<li>When the code is ready, we will switch to our Z:\patina-qemu location  and build and run the stuart_build process that will construct our emulator image and execute it in QEMU.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-component"><a class="header" href="#creating-a-component">Creating a component</a></h1>
<p>By this point, we have set up our development workspace between the patina-dxe-core-qemu and the patina-qemu repositories and have them wired together so that the image loaded and run in the QEMU emulator is that which was built from the patina-dxe-core-qemu sources.</p>
<h2 id="starting-our-test-component-project"><a class="header" href="#starting-our-test-component-project">Starting our test component project</a></h2>
<p>In our test component project root, create a new folder for our project space. Call it <code>test_component</code>.</p>
<p>In this project, we will be mimicking the parts of the code layout that is used in <code>patina-dxe-core-qemu</code>, and adding our own files or replacing those that are represented there with updated versions.</p>
<p>In your test_component project, create this file structure.  No need for content in any of the files just yet:</p>
<pre><code>-\
  - bin\
    - q35_dxe_core.rs
  - src\
    - component\
        - test_component.rs
  - q35.rs  
</code></pre>
<p>in <code>src/q35.rs</code>, set the content to simply</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod test_component
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>üëÄ</p>
<p>Note that We will not be using the service-related files from the patina-dxe-core-qemu repository in this example. These components implement platform services related to hardware configuration‚Äîsuch as ACPI port address emulation and HOB (Hand-Off Block) population‚Äîthat are important for more advanced firmware scenarios.</p>
<p>For our purposes, which focus on demonstrating a basic custom component using Patina‚Äôs DXE Core, these services are unnecessary. This allows us to simplify the component setup and focus on the essentials of the registration and dispatch model.</p>
<p>These service components are useful when simulating realistic platform behavior‚Äîlike memory-mapped I/O, reset control, or dynamic configuration discovery‚Äîand would be valuable when bringing up firmware against specific hardware targets. They can be reintroduced later if needed.</p>
</blockquote>
<h3 id="defining-the-component-code"><a class="header" href="#defining-the-component-code">Defining the component code</a></h3>
<p>for the <code>src/component/test_component.rs</code> file, add this content to define our new test component</p>
<pre><code>use log::info;
use patina_sdk::{component::params::Config, error::Result};

#[derive(Default, Clone, Copy)]
pub struct Name(pub &amp;'static str);

pub fn run_test_component(name: Config&lt;Name&gt;) -&gt; Result&lt;()&gt; {
    info!("============= Test Component ===============");
    info!("Hello, {}!", name.0);
    info!("=========================================");
    Ok(())
}
</code></pre>
<p>As you can see, this presents a classic 'hello world' style example, which is all we will need to get started.</p>
<p>It starts by importing (the <code>use</code> statements at the top) the logging support we will use for our message, the Config construct from the patina_sdk that we will use for our parameter, and the classic Rust <code>Result</code> construct.</p>
<p>The function signature for this implementation forms the basis for the dependency injection we will register in the next step.</p>
<h3 id="registering-the-component"><a class="header" href="#registering-the-component">Registering the component</a></h3>
<p>The file <code>bin/q35_dxe_core.rs</code> is the main binding and execution point for the manifest of components that will make up the image.</p>
<p>Find this file in the <code>patina-dxe-core-qemu</code> repository directory and copy it to your project space at <code>bin/q35_dxe_core.rs</code> so we start from the full contents.</p>
<p>If we look at the patina-dxe-core-qemu version of this file we will see a <code>Core:default()</code> function is called with a number of <code>with_config()</code> and <code>with_component()</code> calls, along with a few others, chained together. This sets up the components that will be included.</p>
<p>The chain concludes with <code>.start().unwrap()</code>.</p>
<p>Remove these lines from your copy and between</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>with_section_extractor(patina_section_extractor::CompositeSectionExtractor::default())
        .init_memory(physical_hob_list) // We can make allocations now!
<span class="boring">}</span></code></pre></pre>
<p>and</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        .start()
<span class="boring">}</span></code></pre></pre>
<p>We will want logging, so replace the line</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        .with_component(adv_logger_component)
<span class="boring">}</span></code></pre></pre>
<p>We can add our component just prior after this, by inserting the lines</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_component(test_component::run_test_component)
.with_config(test_component::Name("World"))
<span class="boring">}</span></code></pre></pre>
<p>just before the <code>.start()</code> call.</p>
<p>It should end up looking similar to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    Core::default()
        .with_section_extractor(patina_section_extractor::CompositeSectionExtractor::default())
        .init_memory(physical_hob_list) // We can make allocations now!
        .with_component(adv_logger_component)
        .with_component(test_component::run_test_component)
        .with_config(test_component::Name("World"))
        .start()
        .unwrap();

    log::info!("Dead Loop Time");
    loop {}

<span class="boring">}</span></code></pre></pre>
<p>also, toward the top of that file, remove the line that looks like this, since we are not using the services in this component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qemu_resources::q35::component::service as q35_services;
<span class="boring">}</span></code></pre></pre>
<h3 id="importing-the-component"><a class="header" href="#importing-the-component">importing the component</a></h3>
<p>Of course, before this code can register our component, it must know about it.</p>
<p>We've already named it in <code>q35.rs</code> with <code>pub mod test_component</code>;</p>
<p>We can then add our import to the list of <code>use</code> statements near the top of the <code>bin/q35_dxe_core.rs</code> file with the line</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qemu_resources::q35::component::test_component;
<span class="boring">}</span></code></pre></pre>
<p>You should see a similar line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use qemu_resources::q35::component::service as q35_services;
<span class="boring">}</span></code></pre></pre>
<p>add our test_component import near here.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>We can now build with the command</p>
<pre><code class="language-cmd">Z:
cd patina-dxe-core-qemu
cargo make q35 Z:\\test_component
</code></pre>
<p>and once that's done, we can build it into QEMU and run it with</p>
<pre><code class="language-cmd">Z:
cd patina-qemu
q35env\Scripts\activate.bat
stuart_build -c Platforms\QemuQ35Pkg\PlatformBuild.py --flashrom BLD_*_DXE_CORE_BINARY_PATH="Z:\patina-dxe-core-qemu\target\x86_64-unknown-uefi"
</code></pre>
<p>Like before, this will take several minutes to build before it starts QEMU and begins logging the output of the execution.</p>
<p>A large amount of log output is generated by subsystems that trigger before and after our component is run, so it will be tricky to find the output in the scroll-back window of your terminal.</p>
<p>You should be able to locate your "Hello, World!" output within a section that starts with "Dispatching Local Drivers".  But be aware that the default patina-qemu image has similar "Hello, World" type examples within it, so be sure to look for mention of <code>test_component</code> in the log as well to verify it is running your code.  You can also modify the text of your test message to verify this.  If you only see the "other" samples, then something has gone wrong.  Verify that the <code>BLD_*_DXE_CORE_BINARY_PATH</code> environment variable correctly points to the <code>.efi</code> file built by your test component project. If needed, rebuild your component and re-run the <code>stuart_build</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-patina-fw-patcher"><a class="header" href="#using-the-patina-fw-patcher">Using the Patina FW Patcher</a></h1>
<p>There is no need to rebuild everything with the Stuart build process each time you make a change in Rust.</p>
<p>The Patina-FW-Patcher is maintained in a repository of the same name: <a href="https://github.com/OpenDevicePartnership/patina-fw-patcher">patina-fw-patcher</a>.  The README there has instructions for use.</p>
<p>There are a couple of ways to efficiently update the firmware build, depending upon the circumstances.</p>
<p><em>(TODO practical examples)</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-1"><a class="header" href="#security-1">Security</a></h1>
<p><em>TODO</em></p>
<p>With overview and links to prior articles.
3rd party support content reposition to here.
Solicit input for this one.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<p><em>TODO</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="booting-into-windows"><a class="header" href="#booting-into-windows">Booting into Windows</a></h1>
<p><em>TODO</em> -- find existing doc on this and reference</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-the-virtual-laptop"><a class="header" href="#integrating-the-virtual-laptop">Integrating the Virtual Laptop</a></h1>
<p><em>TODO</em>
This section will take the components created in the previous exercises and apply them in an integration that
covers</p>
<ul>
<li>
<p>setting up QEMU as a host</p>
</li>
<li>
<p>apply the Patina Firmware we built in exercises and a bootloader</p>
</li>
<li>
<p>communicate with the EC we have constructed in exercises</p>
</li>
<li>
<p>run some tests</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-and-takeaways"><a class="header" href="#summary-and-takeaways">Summary and Takeaways</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="odp-specification-documents"><a class="header" href="#odp-specification-documents">ODP Specification documents</a></h1>
<p>Adherence to the specifications defined by the ODP allow for component portability and auditing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="embedded-controller-interface-specification"><a class="header" href="#embedded-controller-interface-specification">Embedded Controller Interface Specification</a></h1>
<p>Embedded Controller(EC) Interface Specification describes base set of requirements to interface to core windows features.
It covers the following areas:</p>
<ul>
<li>Firmware Management</li>
<li>Battery</li>
<li>Time and Alarm</li>
<li>UCSI</li>
<li>Thermal and Power</li>
<li>Input Devices</li>
<li>Customization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-soc-interface"><a class="header" href="#ec-soc-interface">EC SOC Interface</a></h1>
<h2 id="ec-physical-interface"><a class="header" href="#ec-physical-interface">EC Physical Interface</a></h2>
<p>The interface by which the EC is physically wired to the SOC may vary
depending on what interfaces are supported by the Silicon Vendor, EC
manufacturer and OEM. It is recommended that a simple and low latency
protocol is chosen such as eSPI, I3C, UART, memory.</p>
<h2 id="ec-software-interface"><a class="header" href="#ec-software-interface">EC Software Interface</a></h2>
<p>There are several existing OS interfaces that exist today via ACPI and
HID to manage thermal, battery, keyboard, touch etc. These existing
structures need to keep working and any new interface must be created in
such a way that it does not break existing interfaces. This document
covers details on how to implement EC services in secure world and keep
compatibility with non-secure EC OperationRegions. It is important to
work towards a more robust solution that will handle routing, larger
packets and security in a common way across OS‚Äôs and across SV
architectures.</p>
<p><img src="specs/ec_interface/media/odp_arch.png" alt="EC connections to apps" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legacy-ec-interface-1"><a class="header" href="#legacy-ec-interface-1">Legacy EC Interface</a></h1>
<p>ACPI specification has a definition for an embedded controller, however
this implementation is tied very closely to the eSPI bus and x86
architecture.</p>
<p>The following is an example of legacy EC interface definition from ACPI</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/11_Thermal_Management/thermal-zone-examples.html">11.7. Thermal Zone Examples ‚Äî ACPI Specification 6.4
documentation</a></p>
<pre><code>Scope(\\_SB.PCI0.ISA0) {
  Device(EC0) {
    Name(_HID, EISAID("PNP0C09")) // ID for this EC

    // current resource description for this EC
    Name(_CRS, ResourceTemplate() {
      IO(Decode16,0x62,0x62,0,1)
      IO(Decode16,0x66,0x66,0,1)
    })

    Name(_GPE, 0) // GPE index for this EC
    
    // create EC's region and field for thermal support
    OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
    Field(EC0, ByteAcc, Lock, Preserve) {
      MODE, 1, // thermal policy (quiet/perform)
      FAN, 1, // fan power (on/off)
      , 6, // reserved
      TMP, 16, // current temp
      AC0, 16, // active cooling temp (fan high)
      , 16, // reserved
      PSV, 16, // passive cooling temp
      HOT 16, // critical S4 temp
      CRT, 16 // critical temp
    }

    // following is a method that OSPM will schedule after
    // it receives an SCI and queries the EC to receive value 7
    Method(_Q07) {
      Notify (\\_SB.PCI0.ISA0.EC0.TZ0, 0x80)
    } // end of Notify method

    // fan cooling on/off - engaged at AC0 temp
    PowerResource(PFAN, 0, 0) {
      Method(_STA) { Return (\\_SB.PCI0.ISA0.EC0.FAN) } // check power state
      Method(_ON) { Store (One, \\\\_SB.PCI0.ISA0.EC0.FAN) } // turn on fan
      Method(_OFF) { Store ( Zero, \\\\_SB.PCI0.ISA0.EC0.FAN) }// turn off
fan
    }

    // Create FAN device object
    Device (FAN) {
    // Device ID for the FAN
    Name(_HID, EISAID("PNP0C0B"))
    // list power resource for the fan
    Name(_PR0, Package(){PFAN})
    }

    // create a thermal zone
    ThermalZone (TZ0) {
      Method(_TMP) { Return (\\_SB.PCI0.ISA0.EC0.TMP )} // get current temp
      Method(_AC0) { Return (\\_SB.PCI0.ISA0.EC0.AC0) } // fan high temp
      Name(_AL0, Package(){\\_SB.PCI0.ISA0.EC0.FAN}) // fan is act cool dev
      Method(_PSV) { Return (\\_SB.PCI0.ISA0.EC0.PSV) } // passive cooling
temp
      Name(_PSL, Package (){\\_SB.CPU0}) // passive cooling devices
      Method(_HOT) { Return (\\_SB.PCI0.ISA0.EC0.HOT) } // get critical S4
temp
      Method(_CRT) { Return (\\_SB.PCI0.ISA0.EC0.CRT) } // get critical temp
      Method(_SCP, 1) { Store (Arg1, \\\\_SB.PCI0.ISA0.EC0.MODE) } // set
cooling mode

      Name(_TSP, 150) // passive sampling = 15 sec
      Name(_TZP, 0) // polling not required
      Name (_STR, Unicode ("System thermal zone"))
    } // end of TZ0
  } // end of ECO
} // end of \\\\_SB.PCI0.ISA0 scope-
</code></pre>
<p>On platforms that do not support IO port access there is an option to
define MMIO regions to simulate the IO port transactions.</p>
<p>In the above example you can see that the operation region directly maps
to features on the EC and you can change the EC behavior by writing to a
byte in the region or reading the latest data from the EC.</p>
<p>For a system with the EC connected via eSPI and that needs a simple
non-secure interface to the EC the above mapping works very well and
keeps the code simple. The eSPI protocol itself has details on port
accesses and uses the peripheral channel to easily read/write memory
mapped regions.</p>
<p>As the EC features evolve there are several requirements that do no work
well with this interface:</p>
<ul>
<li>
<p>Different buses such as I3C, SPI, UART target a packet
request/response rather than a memory mapped interface</p>
</li>
<li>
<p>Protected or restricted access and validation of request/response</p>
</li>
<li>
<p>Firmware update, large data driven requests that require larger data
response the 256-byte region is limited</p>
</li>
<li>
<p>Discoverability of features available and OEM customizations</p>
</li>
<li>
<p>Out of order completion of requests, concurrency, routing and
priority handling</p>
</li>
</ul>
<p>As we try to address these limitations and move to a more packet based
protocol described in this document. The following section covers
details on how to adopt existing operation region to new ACPI
functionality.</p>
<h2 id="adopting-ec-operation-region-1"><a class="header" href="#adopting-ec-operation-region-1">Adopting EC Operation Region</a></h2>
<p>The new OS frameworks such as MPTF still use ACPI methods as primary
interface. Instead of defining devices such as FAN or ThermalZone in the
EC region you can simply define the EC region itself and then map all
the other ACPI functions to operate on this region. This will allow you
to maintain backwards compatibility with existing EC definitions.</p>
<pre><code>Device(EC0) {
  Name(_HID, EISAID("PNP0C09")) // ID for this EC
  // current resource description for this EC
  Name(_CRS, ResourceTemplate() {
    IO(Decode16,0x62,0x62,0,1)
    IO(Decode16,0x66,0x66,0,1)
  })

  // create EC's region and field for thermal support
  OperationRegion(EC0, EmbeddedControl, 0, 0xFF)
  Field(EC0, ByteAcc, Lock, Preserve) {
    MODE, 1, // thermal policy (quiet/perform)
    FAN, 1, // fan power (on/off)
    , 6, // reserved
    TMP, 16, // current temp
    AC0, 16, // active cooling temp (fan high)
    , 16, // reserved
    PSV, 16, // passive cooling temp
    HOT 16, // critical S4 temp
    CRT, 16 // critical temp
  }
}

Device(SKIN) {
¬† Name(_HID, "MSFT000A") // New MPTF HID Temperature Device
¬† Method(_TMP, 0x0, Serialized) {
‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇ‚ÄÇReturn( \\_SB.PCI0.ISA0.EC0.TMP)
¬† }
}
</code></pre>
<p>For more complicated functions that take a package some of the data may
be constructed within ACPI and some of the data pulled from the
OperationRegion. For example BIX for battery information may have a
combination of static and dynamic data like this:</p>
<pre><code>Method (_BIX) {
  Name (BAT0, Package (0x12)
  {
    0x01, // Revision
    0x02, // Power Unit
    0x03, // Design Capacity
    \\_SB.PCI0.ISA0.EC0.BFCC, // Last Full Charge Capacity
    0x05, // Battery Technology
    0x06, // Design Voltage
    0x07, // Design capacity of Warning
    0x08, // Design Capacity of Low
    \\_SB.PCI0.ISA0.EC0.BCYL, // Cycle Count
    0x0A, // Measurement Accuracy
    0x0B, // Max Sampling Time
    0x0C, // Min Sampling Time
    0x0D, // Max Averaging Interval
    0x0E, // Min Averaging Interval
    0x0F, // Battery Capacity Granularity 1
    0x10, // Battery Capacity Granularity 2
    "Model123", // Model Number
    "Serial456", // Serial Number
    "Li-Ion", // Battery Type
    "OEMName" // OEM Information
  })
  Return(BAT0)
}
</code></pre>
<h2 id="limitations-for-using-legacy-ec-1"><a class="header" href="#limitations-for-using-legacy-ec-1">Limitations for using Legacy EC</a></h2>
<p>Before using the Legacy EC definition OEM‚Äôs should be aware of several
use cases that may limit you ability to use it.</p>
<h3 id="acpi-support-for-espi-master-1"><a class="header" href="#acpi-support-for-espi-master-1">ACPI support for eSPI master</a></h3>
<p>In the case of Legacy EC the communication to the EC is accomplished
directly by the ACPI driver using PORT IO and eSPI Peripheral Bus
commands. On ARM platforms there is no PORT IO and these must be
substituted with MMIO regions. The ACPI driver needs changes to support
MMIO which is being evaluated and support is not yet available. Some
Silicon Vendors also do not implement the full eSPI specification and as
such the ACPI driver cannot handle all the communication needs. On these
platforms using Legacy EC interface is not an option.</p>
<h3 id="security-of-espi-bus-1"><a class="header" href="#security-of-espi-bus-1">Security of eSPI bus</a></h3>
<p>When non-secure world is given access to the eSPI bus it can send
commands to device on that bus. Some HW designs have the TPM or SPINOR
on the same physical bus as the EC. On these designs allowing non-secure
world to directly sends commands to EC can break the security
requirements of other devices on the bus. In these cases the eSPI
communication must be done in the secure world over FF-A as covered in
this document and not use the Legacy EC channel. Since non-secure world
has complete access to the EC operation region there is no chance for
encryption of data. All data in the operation region is considered
non-secure.</p>
<h3 id="functional-limitations-of-legacy-ec-1"><a class="header" href="#functional-limitations-of-legacy-ec-1">Functional limitations of Legacy EC</a></h3>
<p>The peripheral region that is mapped in the Legacy EC in ACPI is limited
to 256 bytes and notification events to the ones that are defined and
handled in ACPI driver. To create custom solutions, send large packets
or support encryption of data the Legacy EC interface has limitations in
this area.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-ec-services-overview-1"><a class="header" href="#secure-ec-services-overview-1">Secure EC Services Overview</a></h1>
<p>In this section we review a system design where the EC communication is
in the secure world running in a dedicated SP. In a system without
secure world or where communication to EC is not desired to be secure
all the ACPI functions can be mapped directly to data from the EC
operation region.</p>
<p>The following github projects provide sample implementations of this interface:</p>
<p><a href="https://github.com/opendevicepartnership/ec-test-app">ACPI EC samples, Kernel mode test driver, User mode test driver</a><br>
<a href="https://github.com/opendevicepartnership/haf-ec-service">Sample Secure Partition Service for EC services in RUST</a><br>
<a href="https://github.com/opendevicepartnership/ffa">RUST crate for FFA implementation in secure partition</a><br></p>
<p>The following GUID‚Äôs have been designed to represent each service
operating in the secure partition for EC.</p>
<table>
<thead>
<tr class="header">
<th>EC Service Name</th>
<th>Service GUID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<td>EC_SVC_MANAGEMENT</td>
<td>330c1273-fde5-4757-9819-5b6539037502</td>
<td>Used to query EC functionality, Board info, version, security state, FW update</td>
</tr>
<td>EC_SVC_POWER</td>
<td>7157addf-2fbe-4c63-ae95-efac16e3b01c</td>
<td>Handles general power related requests and OS Sx state transition state notification</td>
</tr>
<td>EC_SVC_BATTERY</td>
<td>25cb5207-ac36-427d-aaef-3aa78877d27e</td>
<td>Handles battery info, status, charging</td>
</tr>
<td>EC_SVC_THERMAL</td>
<td>31f56da7-593c-4d72-a4b3-8fc7171ac073</td>
<td>Handles thermal requests for skin and other thermal events</td>
</tr>
<td>EC_SVC_UCSI</td>
<td>65467f50-827f-4e4f-8770-dbf4c3f77f45</td>
<td>Handles PD notifications and calls to UCSI interface</td>
</tr>
<td>EC_SVC_INPUT</td>
<td>e3168a99-4a57-4a2b-8c5e-11bcfec73406</td>
<td>Handles wake events, power key, lid, input devices (HID separate instance)</td>
</tr>
<td>EC_SVC_TIME_ALARM</td>
<td>23ea63ed-b593-46ea-b027-8924df88e92f</td>
<td>Handles RTC and wake timers.</td>
</tr>
<td>EC_SVC_DEBUG</td>
<td>0bd66c7c-a288-48a6-afc8-e2200c03eb62</td>
<td>Used for telemetry, debug control, recovery modes, logs, etc</td>
</tr>
<td>EC_SVC_TEST</td>
<td>6c44c879-d0bc-41d3-bef6-60432182dfe6</td>
<td>Used to send commands for manufacturing/factory test</td>
</tr>
<td>EC_SVC_OEM1</td>
<td>9a8a1e88-a880-447c-830d-6d764e9172bb</td>
<td>Sample OEM custom service and example piping of events</td>
</tr>
</tbody>
</table>
<h2 id="ffa-overview-1"><a class="header" href="#ffa-overview-1">FFA Overview</a></h2>
<p>This section covers the components involved in sending a command to EC
through the FFA flow in windows. This path is specific to ARM devices
and a common solution with x64 is still being worked out. Those will
continue through the non-secure OperationRegion in the near term.</p>
<p><img src="specs/ec_interface/media/image1.png" alt="A diagram of a computer security system Description automatically generated" /></p>
<p>ARM has a standard for calling into the secure world through SMC‚Äôs and
targeting a particular service running in secure world via a UUID. The
full specification and details can be found here: <a href="https://developer.arm.com/Architectures/Firmware%20Framework%20for%20A-Profile">Firmware Framework
for A-Profile</a></p>
<p>The windows kernel provides native ability for ACPI to directly send and
receive FFA commands. It also provides a driver ffadrv.sys to expose a
DDI that allows other drivers to directly send/receive FFA commands
without needing to go through ACPI.</p>
<p>Hyper-V forwards the SMC‚Äôs through to EL3 to Hafnium which then uses the
UUID to route the request to the correct SP and service. From the
corresponding EC service it then calls into the eSPI or underlying
transport layer to send and receive the request to the physical EC.</p>
<h3 id="ffa-device-definition-2"><a class="header" href="#ffa-device-definition-2">FFA Device Definition</a></h3>
<p>The FFA device is loaded from ACPI during boot and as such requires a
Device entry in ACPI</p>
<pre><code>  Name(_HID, "MSFT000C")

  OperationRegion(AFFH, FFixedHw, 4, 144) 
  Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1), FFAC, 1152 }     
    

  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              2, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
              Package () {
                     ToUUID("b510b3a3-59f6-4054-ba7a-ff2eb1eac765"), // Service2 UUID
                     Package () {
                          0x01,     //Cookie1
                          0x03,     //Cookie2
                      }
             }
         }
      }
    }
  }) // _DSD()

  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(DeRefOf(Index(Arg3,1)), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }

  Method(AVAL,0x0, Serialized)
  {
    Return(One)
  }
}
</code></pre>
<h4 id="hid-definition-1"><a class="header" href="#hid-definition-1">HID definition</a></h4>
<p>The _HID ‚ÄúMSFT000C‚Äù is reserved for FFA devices. Defining this HID for
your device will cause the FFA interface for the OS to be loaded on this
device.</p>
<h4 id="operation-region-definition-1"><a class="header" href="#operation-region-definition-1">Operation Region Definition</a></h4>
<p>The operation region is marked as FFixedHw type 4 which lets the ACPI
interpreter know that any read/write to this region requires special
handling. The length is 144 bytes because this region operates on
registers X0-X17 each of which are 8 bytes 18*8 = 144 bytes. This is
mapped to FFAC is 1152 bits (144*8) and this field is where we act
upon.</p>
<pre><code>OperationRegion(AFFH, FFixedHw, 4, 144)
Field(AFFH, BufferAcc, NoLock, Preserve) { AccessAs(BufferAcc, 0x1),FFAC, 1152 }
</code></pre>
<p>When reading and writing from this operation region the FFA driver does
some underlying mapping for X0-X3</p>
<pre><code>X0 = 0xc400008d // FFA_DIRECT_REQ2
X1 = (Receiver Endpoint ID) | (Sender Endpoint ID \&lt;\&lt; 16)
X2/X3 = UUID
</code></pre>
<p>The following is the format of the request and response packets that are
sent via ACPI</p>
<pre><code>FFA_REQ_PACKET
{
  uint8 status; // Not used just populated so commands are symmetric
  uint8 length; // Number of bytes in rawdata
  uint128 UUID;
  uint8 reqdata[];
}

FFA_RSP_PACKET
{
  uint8 status; // Status from ACPI if FFA command was sent successfully
  uint8 length;
  uint128 UUID;
  uint64 ffa_status; // Status returned from the service of the FFA command
  uint8 rspdata[];
}

CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // In/Out - UUID of service
CreateDwordField(BUFF,18,FFST)// Out - FFA command status
</code></pre>
<h4 id="register-notification-1"><a class="header" href="#register-notification-1">Register Notification</a></h4>
<p>During FFA driver initialization it calls into secure world to get a
list of all available services for each secure partition. After this we
send a NOTIFICATION_REGISTRATION request to each SP that has a service
which registers for notification events</p>
<pre><code>  Name(_DSD, Package() {
      ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), //Device Prop UUID
      Package() {
        Package(2) {
          "arm-arml0002-ffa-ntf-bind",
          Package() {
              1, // Revision
              1, // Count of following packages
              Package () {
                     ToUUID("330c1273-fde5-4757-9819-5b6539037502"), // Service1 UUID
                     Package () {
                          0x01,     //Cookie1 (UINT32)
                          0x07,     //Cookie2
                      }
              },
         }
      }
    }
  }) // _DSD()
</code></pre>
<p><img src="specs/ec_interface/media/image2.png" alt="A diagram of a application Description automatically generated" /></p>
<p>In the above example we indicate that the OS will handle 2 different
notification events for UUID 330c1273-fde5-4757-9819-5b6539037502 which
is our EC management UUID. FFA knows which secure partition this maps to
based on the list of services for each SP it has retrieved. Rather than
having to keep track of all the physical bits in the bitmask that are
used the FFA driver keeps track of this and allows each service to
create a list of virtual ID‚Äôs they need to handle. The FFA driver then
maps this to one of the available bits in the hardware bitmask and
passes this mapping down to the notification service running in a given
SP.</p>
<h3 id="input-1"><a class="header" href="#input-1">Input</a></h3>
<table>
<thead>
<tr class="header">
<th><strong>Parameter¬†</strong></th>
<th><strong>Register¬†</strong></th>
<th><strong>Value¬†</strong></th>
</tr>
</thead>
<tbody>
<td>Function<strong>¬†</strong></td>
<td>X4¬†</td>
<td>0x1¬†</td>
</tr>
<td>UUID Lo<strong>¬†</strong></td>
<td>X5¬†</td>
<td>Bytes [0..7] for the service UUID.¬†</td>
</tr>
<td>UUID Hi<strong>¬†</strong></td>
<td>X6¬†</td>
<td>Bytes [8..16] for the service UUID.¬†</td>
</tr>
<td>Mappings Count<strong>¬†</strong></td>
<td>X7¬†</td>
<td>The number of notification mappings¬†</td>
</tr>
<td>Notification Mapping1<strong>¬†</strong></td>
<td>X8¬†</td>
<td><p>Bits [0..16] ‚Äì Notification ID. --&gt; 0,1,2,3,...¬†</p>
<p>¬†</p>
<p>Bits [16..32] ‚Äì Notification Bitmap bit number (0-383).¬†¬†</p></td>
</tr>
<td>Notification Mapping2<strong>¬†</strong></td>
<td>X9¬†</td>
<td><p>Bits [0..16] ‚Äì Notification ID. --&gt; 0,1,2,3,...¬†</p>
<p>¬†</p>
<p>Bits [16..32] ‚Äì Notification Bitmap bit number (0-383).¬†</p>
<p>¬†</p></td>
</tr>
<td>...<strong>¬†</strong></td>
<td>...¬†</td>
<td>...¬†</td>
</tr>
</tbody>
</table>
<p>¬†</p>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Parameter¬†</th><th>Register¬†</th><th>Value¬†</th></tr></thead><tbody>
<tr><td>Result</td><td>X4</td><td>0 on success. Otherwise, Failure</td></tr>
</tbody></table>
</div>
<p>¬†</p>
<p>Note this NOTIFICATION_REGISTER request is sent to the
Notification Service UUID in the SP. The UUID of the service that the
notifications are for are stored in X5/X6 registers shown above.</p>
<p>The UUID for notification service is
{B510B3A3-59F6-4054-BA7A-FF2EB1EAC765} which is stored in X2/X3.</p>
<h4 id="notification-events-1"><a class="header" href="#notification-events-1">Notification Events</a></h4>
<p>All notification events sent from all secure partitions are passed back
through the FFA driver. The notification calls the _DSM method. Function 0
is always a bitmap of all the other functions supported. We must support at
least a minium of the Query and Notify.
The UUID is stored in Arg0 and the notification cookie is stored in Arg3 when Arg2 is 11.</p>
<pre><code>  Method(_DSM, 0x4, NotSerialized)
  {
    // Arg0 - UUID
    // Arg1 - Revision
    // Arg2: Function Index
    //         0 - Query
    //         1 - Notify
    //         2 - binding failure
    //         3 - infra failure    
    // Arg3 - Data
  
    //
    // Device specific method used to query
    // configuration data. See ACPI 5.0 specification
    // for further details.
    //
    If(LEqual(Arg0, Buffer(0x10) {
        //
        // UUID: {7681541E-8827-4239-8D9D-36BE7FE12542}
        //
        0x1e, 0x54, 0x81, 0x76, 0x27, 0x88, 0x39, 0x42, 0x8d, 0x9d, 0x36, 0xbe, 0x7f, 0xe1, 0x25, 0x42
      }))
    {
      // Query Function
      If(LEqual(Arg2, Zero)) 
      {
        Return(Buffer(One) { 0x03 }) // Bitmask Query + Notify
      }
      
      // Notify Function
      If(LEqual(Arg2, One))
      {
        // Arg3 - Package {UUID, Cookie}
        Store(DeRefOf(Index(Arg3,1)), \_SB.ECT0.NEVT )
        Return(Zero) 
      }
    } Else {
      Return(Buffer(One) { 0x00 })
    }
  }
</code></pre>
<p>The following is the call flow showing a secure interrupt arriving to
the EC service which results in a notification back to ACPI. The
notification payload can optionally be written to a shared buffer or
ACPI can make another call back into EC service to retrieve the
notification details.</p>
<p>The _NFY only contains the ID of the notification and no other payload,
so both ACPI and the EC service must be designed either with shared
memory buffer or a further notify data packet.</p>
<p><img src="specs/ec_interface/media/image3.png" alt="A diagram of a service Description automatically generated" /></p>
<h2 id="runtime-requests-1"><a class="header" href="#runtime-requests-1">Runtime Requests</a></h2>
<p>During runtime the non-secure side uses FFA_MSG_SEND_DIRECT_REQ2
requests to send requests to a given service within an SP. Any request
that is expected to take longer than 500 uSec should yield control back
to the OS by calling FFA_YIELD within the service. When FFA_YIELD is
called it will return control back to the OS to continue executing but
the corresponding ACPI thread will be blocked until the original FFA
request completes with DIRECT_RSP2. Note this creates a polling type
interface where the OS will resume the SP thread after the timeout
specified. The following is sample call sequence.</p>
<p><img src="specs/ec_interface/media/image4.png" alt="A diagram of a company&#39;s process Description automatically generated" /></p>
<h3 id="ffa-example-data-flow-1"><a class="header" href="#ffa-example-data-flow-1">FFA Example Data Flow</a></h3>
<p>For an example let‚Äôs take the battery status request _BST and follow
data through.</p>
<p><img src="specs/ec_interface/media/image5.png" alt="A screenshot of a computer Description automatically generated" /></p>
<pre><code>FFA_REQ_PACKET req = {
  0x0, // Initialize to no error
  0x1, // Only 1 byte of data is sent after the header
  {0x25,0xcb,0x52,0x07,0xac,0x36,0x42,0x7d,0xaa,0xef,0x3a,0xa7,0x88,0x77,0xd2,0x7e},
  0x2 // EC_BAT_GET_BST
}
</code></pre>
<p>The equivalent to write this data into a BUFF in ACPI is as follows</p>
<pre><code>Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
CreateField(BUFF,16,128,UUID) // UUID of service
CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
CreateField(BUFF,144,128,BSTD) // Out ‚Äì Raw data response 4 DWords
Store(20,LENG)
Store(0x2, CMDD)
Store(ToUUID ("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID)
Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)
</code></pre>
<p>The ACPI interpreter when walking through this code creates a buffer and
populates the data into buffer. The last line indicates to send this
buffer over FFA interface.</p>
<p>ACPI calls into the FFA interface to send the data over to the secure
world EC Service</p>
<pre><code>typedef struct _FFA_INTERFACE {
¬† ¬† ULONG Version;
¬† ¬† PFFA_MSG_SEND_DIRECT_REQ2 SendDirectReq2;
} FFA_INTERFACE, \*PFFA_INTERFACE;
</code></pre>
<h3 id="ffa-parsing-1"><a class="header" href="#ffa-parsing-1">FFA Parsing</a></h3>
<p>FFA is in charge of sending the SMC over to the secure world and routing
to the correct service based on UUID.</p>
<p><img src="specs/ec_interface/media/image6.png" alt="A diagram of a computer Description automatically generated" /></p>
<pre><code>X0 = SEND_DIRECT_REQ2 SMC command ID
X1 = Source ID and Destination ID
X2 = UUID Low
X3 = UUID High
X4-X17 = rawdata
</code></pre>
<p><strong>Note:</strong> The status and length are not passed through to the secure
world they are consumed only be ACPI.</p>
<p>HyperV and Monitor have a chance to filter or deny the request, but in
general just pass the SMC request through to Hafnium</p>
<p>Hafnium extracts the data from the registers into an sp_msg structure
which is directly mapping contents from x0-x17 into these fields.</p>
<pre><code>pub struct FfaParams {
¬† ¬† pub x0: u64,
¬† ¬† pub x1: u64,
¬† ¬† pub x2: u64,
¬† ¬† pub x3: u64,
¬† ¬† pub x4: u64,
¬† ¬† pub x5: u64,
¬† ¬† pub x6: u64,
¬† ¬† pub x7: u64,
¬† ¬† pub x8: u64,
¬† ¬† pub x9: u64,
¬† ¬† pub x10: u64,
¬† ¬† pub x11: u64,
¬† ¬† pub x12: u64,
¬† ¬† pub x13: u64,
¬† ¬† pub x14: u64,
¬† ¬† pub x15: u64,
¬† ¬† pub x16: u64,
¬† ¬† pub x17: u64,
}
</code></pre>
<p>In our SP we receive the raw FfaParams structure and we convert this to
an FfaMsg using our translator. This pulls out the function_id,
source_id, destination_id and uuid.</p>
<pre><code>fn from(params: FfaParams) -&gt; FfaMsg {
  FfaMsg {
¬†   function_id: params.x0, ¬† ¬† ¬† ¬† ¬† ¬† ¬†// Function id is in lower 32 bits of x0
¬† ¬† source_id: (params.x1 &gt;&gt; 16) as u16, // Source in upper 16 bits
¬† ¬† destination_id: params.x1 as u16, ¬† ¬†// Destination in lower 16 bits
¬† ¬† uuid: u64_to_uuid(params.x2, params.x3),
¬† ¬† args64: [
¬† ¬†   params.x4, params.x5, params.x6, params.x7, params.x8, params.x9, params.x10,
¬† ¬† ¬† params.x11, params.x12, params.x13, params.x14, params.x15, params.x16, params.x17,
¬† ¬† ¬† ¬† ¬† ¬† ],
  }
}
</code></pre>
<p>The destination_id is used to route the message to the correct SP, this
is based on the ID field in the DTS description file. Eg: id =
&lt;0x8001&gt;;</p>
<h3 id="ec-service-parsing-1"><a class="header" href="#ec-service-parsing-1">EC Service Parsing</a></h3>
<p>Within the EC partition there are several services that run, the routing
of the FF-A request to the correct services is done by the main message
handling loop for the secure partition. After receiving a message we
call into ffa_msg_handler and based on the UUID send it to the
corresponding service to handle the message.</p>
<pre><code>let mut next_msg = ffa.msg_wait();
loop {
  match next_msg {
 ¬†  Ok(ffamsg) =&gt; match ffa_msg_handler(&amp;ffamsg) {
¬† ¬†   Ok(msg) =&gt; next_msg = ffa.msg_resp(\&amp;msg),
¬† ¬†   Err(_e) =&gt; panic!("Failed to handle FFA msg"),
¬†   },
¬†   Err(_e) =&gt; {
  ¬†   panic!("Error executing msg_wait");
¬†   }
   }
}
</code></pre>
<p>The main message loop gets the response back from ffa_msg_handler and
returns to non-secure world so the next incoming message after the
response is a new message to handle.</p>
<pre><code>fn ffa_msg_handler(msg: &amp;FfaMsg) -&gt; Result&lt;FfaMsg&gt; {
¬† ¬† println!(
¬† ¬† ¬† ¬† "Successfully received ffa msg:
¬† ¬† ¬† ¬† function_id = {:08x}
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†uuid = {}",
¬† ¬† ¬† ¬† msg.function_id, msg.uuid
¬† ¬† );

¬† ¬† match msg.uuid {
¬† ¬† ¬† ¬† UUID_EC_SVC_MANAGEMENT =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let fwmgmt = fw_mgmt::FwMgmt::new();
¬† ¬† ¬† ¬† ¬† ¬† fwmgmt.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_NOTIFY =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let ntfy = notify::Notify::new();
¬† ¬† ¬† ¬† ¬† ¬† ntfy.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_POWER =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let pwr = power::Power::new();
¬† ¬† ¬† ¬† ¬† ¬† pwr.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_BATTERY =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let batt = battery::Battery::new();
¬† ¬† ¬† ¬† ¬† ¬† batt.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_THERMAL =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let thm = thermal::ThmMgmt::new();
¬† ¬† ¬† ¬† ¬† ¬† thm.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_UCSI =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let ucsi = ucsi::UCSI::new();
¬† ¬† ¬† ¬† ¬† ¬† ucsi.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_TIME_ALARM =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let alrm = alarm::Alarm::new();
¬† ¬† ¬† ¬† ¬† ¬† alrm.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_DEBUG =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let dbg = debug::Debug::new();
¬† ¬† ¬† ¬† ¬† ¬† dbg.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† UUID_EC_SVC_OEM =&gt; {
¬† ¬† ¬† ¬† ¬† ¬† let oem = oem::OEM::new();
¬† ¬† ¬† ¬† ¬† ¬† oem.exec(msg)
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† _ =&gt; panic!("Unknown UUID"),
¬† ¬† }
}
</code></pre>
<h3 id="large-data-transfers-1"><a class="header" href="#large-data-transfers-1">Large Data Transfers</a></h3>
<p>When making an FFA_MSG_SEND_DIRECT_REQ2 call the data is stored in
registers X0-X17. X0-X3 are reserved to store the Function Id, Source
Id, Destination Id and UUID. This leaves X4-X17 or 112 bytes. For larger
messages they either need to be broken into multiple pieces or make use
of a shared buffer between the OS and Secure Partition.</p>
<h4 id="shared-buffer-definitions-1"><a class="header" href="#shared-buffer-definitions-1">Shared Buffer Definitions</a></h4>
<p>To create a shared buffer you need to modify the dts file for the secure
partition to include mapping to your buffer.</p>
<pre><code>ns_comm_buffer {
  description = "ns-comm";
  base-address = &lt;0x00000100 0x60000000&gt;;
  pages-count = &lt;0x8&gt;;
  attributes = &lt;NON_SECURE_RW&gt;;
};
</code></pre>
<p>During UEFI Platform initialization you will need to do the following
steps, see the FFA specification for more details on these commands</p>
<ul>
<li>FFA_MAP_RXTX_BUFFER</li>
<li>FFA_MEM_SHARE</li>
<li>FFA_MSG_SEND_DIRECT_REQ2 (EC_CAP_MEM_SHARE)</li>
<li>FFA_UNMAP_RXTX_BUFFER</li>
</ul>
<p>The RXTX buffer is used during larger packet transfers but can be
overridden and updated by the framework. The MEM_SHARE command uses the
RXTX buffer so we first map that buffer then populate our memory
descriptor requests to the TX_BUFFER and send to Hafnium. After sending
the MEM_SHARE request we need to instruct our SP to retrieve this
memory mapping request. This is done through our customer
EC_CAP_MEM_SHARE request where we describe the shared memory region
that UEFI has donated. From there we call FFA_MEM_RETRIEVE_REQ to map
the shared memory that was described to Hafnium. After we are done with
the RXTX buffers we must unmap them as the OS will re-map new RXTX
buffers. From this point on both Non-secure and Secure side will have
access to this shared memory buffer that was allocated.</p>
<h3 id="async-transfers-1"><a class="header" href="#async-transfers-1">Async Transfers</a></h3>
<p>All services are single threaded by default. Even when doing FFA_YIELD
it does not allow any new content to be executed within the service. If
you need your service to be truly asynchronous you must have commands
with delayed responses.</p>
<p>There is no packet identifier by default and tracking of requests and
completion by FFA, so the sample solution given here is based on shared
buffers defined in previous section and existing ACPI and FFA
functionality.</p>
<p><img src="specs/ec_interface/media/image7.png" alt="A diagram of a service Description automatically generated" /></p>
<p>Inside of our FFA functions rather than copying our data payload into
the direct registers we define a queue in shared memory and populate the
actual data into this queue entry. In the FFA_MSG_SEND_DIRECT_REQ2
we populate an ASYNC command ID (0x0) along with the seq #. The seq #
is then used by the service to locate the request in the TX queue. We
define a separate queue for RX and TX so we don‚Äôt need to synchronize
between OS and secure partition.</p>
<p><img src="specs/ec_interface/media/image8.png" alt="" /></p>
<h3 id="acpi-structures-and-methods-for-asynchronous-1"><a class="header" href="#acpi-structures-and-methods-for-asynchronous-1">ACPI Structures and Methods for Asynchronous</a></h3>
<p>The SMTX is shared memory TX region definition</p>
<pre><code>// Shared memory regions and ASYNC implementation
OperationRegion (SMTX, SystemMemory, 0x10060000000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMTX, AnyAcc, NoLock, Preserve)
{
  TVER, 16,
  TCNT, 16,
  TRS0, 32,
  TB0, 64,
  TB1, 64,
  TB2, 64,
  TB3, 64,
  TB4, 64,
  TB5, 64,
  TB6, 64,
  TB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  TE0, 2048,
  TE1, 2048,
  TE2, 2048,
  TE3, 2048,
  TE4, 2048,
  TE5, 2048,
  TE6, 2048,
  TE7, 2048,
}
</code></pre>
<p>The QTXB method copies data into first available entry in the TX queue
and returns sequence number used.</p>
<pre><code>// Arg0 is buffer pointer
// Arg1 is length of Data
// Return Seq \#
Method(QTXB, 0x2, Serialized) {
  Name(TBX, 0x0)
  Store(Add(ShiftLeft(1,32),Add(ShiftLeft(Arg1,16),SEQN)),TBX)
  Increment(SEQN)
  // Loop until we find a free entry to populate
  While(One) {
    If(LEqual(And(TB0,0xFFFF),0x0)) {
      Store(TBX,TB0); Store(Arg0,TE0); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB1,0xFFFF),0x0)) {
      Store(TBX,TB1); Store(Arg0,TE1); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB2,0xFFFF),0x0)) {
      Store(TBX,TB2); Store(Arg0,TE2); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB3,0xFFFF),0x0)) {
      Store(TBX,TB3); Store(Arg0,TE3); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB4,0xFFFF),0x0)) {
      Store(TBX,TB4); Store(Arg0,TE4); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB5,0xFFFF),0x0)) {
      Store(TBX,TB5); Store(Arg0,TE5); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB6,0xFFFF),0x0)) {
      Store(TBX,TB6); Store(Arg0,TE6); Return( And(TBX,0xFFFF) )
    }

    If(LEqual(And(TB7,0xFFFF),0x0)) {
      Store(TBX,TB7); Store(Arg0,TE7); Return( And(TBX,0xFFFF) )
    }

    Sleep(5)
  }
}
</code></pre>
<p>The SMRX is shared memory region for RX queues</p>
<pre><code>// Shared memory region
OperationRegion (SMRX, SystemMemory, 0x10060001000, 0x1000)

// Store our actual request to shared memory TX buffer
Field (SMRX, AnyAcc, NoLock, Preserve)
{
  RVER, 16,
  RCNT, 16,
  RRS0, 32,
  RB0, 64,
  RB1, 64,
  RB2, 64,
  RB3, 64,
  RB4, 64,
  RB5, 64,
  RB6, 64,
  RB7, 64,
  Offset(0x100), // First Entry starts at 256 byte offset each entry is 256 bytes
  RE0, 2048,
  RE1, 2048,
  RE2, 2048,
  RE3, 2048,
  RE4, 2048,
  RE5, 2048,
  RE6, 2048,
  RE7, 2048,
}
</code></pre>
<p>The RXDB function takes sequence number as input and will keep looping
through all the entries until we see packet has completed. Sleeps for
5ms between each iteration to allow the OS to do other things and other
ACPI threads can run.</p>
<pre><code>// Allow multiple threads to wait for their SEQ packet at once
// If supporting packet \&gt; 256 bytes need to modify to stitch together packet
Method(RXDB, 0x1, Serialized) {
  Name(BUFF, Buffer(256){})
  // Loop forever until we find our seq
  While (One) {
    If(LEqual(And(RB0,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB0,16),0xFFFF),8), XB0)
      Store(RE0,BUFF); Store(0,RB0); Return( XB0 )
    }

    If(LEqual(And(RB1,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB1,16),0xFFFF),8), XB1)
      Store(RE1,BUFF); Store(0,RB1); Return( XB1 )
    }

    If(LEqual(And(RB2,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB2,16),0xFFFF),8), XB2)
      Store(RE2,BUFF); Store(0,RB2); Return( XB2 )
    }

    If(LEqual(And(RB3,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB3,16),0xFFFF),8), XB3)
      Store(RE3,BUFF); Store(0,RB3); Return( XB3 )
    }

    If(LEqual(And(RB4,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB4,16),0xFFFF),8), XB4)
      Store(RE4,BUFF); Store(0,RB4); Return( XB4 )
    }

    If(LEqual(And(RB5,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB5,16),0xFFFF),8), XB5)
      Store(RE5,BUFF); Store(0,RB5); Return( XB5 )
    }

    If(LEqual(And(RB6,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB6,16),0xFFFF),8), XB6)
      Store(RE6,BUFF); Store(0,RB6); Return( XB6 )
    }

    If(LEqual(And(RB7,0xFFFF),Arg0)) {
      CreateField(BUFF, 0, Multiply(And(ShiftRight(RB7,16),0xFFFF),8), XB7)
      Store(RE7,BUFF); Store(0,RB7); Return( XB7 )
    }

    Sleep(5)
  }

  // If we get here didn't find a matching sequence number
  Return (Ones)
}
</code></pre>
<p>The following is sample code to transmit a ASYNC request and wait for
the data in the RX buffer.</p>
<pre><code>Method(ASYC, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
  Name(BUFF, Buffer(30){})
  CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
  CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
  CreateField(BUFF,16,128,UUID) // UUID of service
  CreateByteField(BUFF,18,CMDD) // Command register
  CreateWordField(BUFF,19,BSQN) // Sequence Number

  // x0 -\&gt; STAT
  Store(20, LENG)
  Store(0x0, CMDD) // EC_ASYNC command
  Local0 = QTXB(BUFF,20) // Copy data to our queue entry and get back SEQN
  Store(Local0,BSQN) // Sequence packet to read from shared memory
  Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
  Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

  If(LEqual(STAT,0x0) ) // Check FF-A successful?
  {
    Return (RXDB(Local0)) // Loop through our RX queue till packet completes
  }
}
</code></pre>
<h2 id="recovery-and-errors-1"><a class="header" href="#recovery-and-errors-1">Recovery and Errors</a></h2>
<p>The eSPI or bus driver is expected to detect if the EC is not responding
and retry. The FFA driver will report back in the status byte if it
cannot successfully talk to the secure world. If there are other
failures generally they should be returned back up through ACPI with a
value of (Ones) to indicate failure condition. This may cause some
features to work incorrectly.</p>
<p>It is also expected that the EC has a watchdog if something on the EC is
hung it should reset and reload on its own. The EC is also responsible
for monitoring that the system is running within safe parameters. The
thermal requests and queries are meant to be advisory in nature and EC
should be able to run independently and safely without any intervention
from the OS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-firmware-management"><a class="header" href="#ec-firmware-management">EC Firmware Management</a></h1>
<p>This service is to provide details about the security state, supported
features, debug, firmware version and firmware update functionality.</p>
<p>NIST SP 800-193 compliance requires failsafe update of primary and
backup EC FW images. EC should run from primary partition while writing
backup partitions and then change flag to indicate backup becomes
primary and primary becomes backup.</p>
<div class="table-wrapper"><table><thead><tr><th>Capability Command</th><th>Description</th></tr></thead><tbody>
<tr><td>EC_CAP_GET_FW_STATE = 0x1</td><td>Return details of FW in EC, DICE, Secure Boot, Version, etc</td></tr>
<tr><td>EC_CAP_GET_SVC_LIST = 0x2</td><td>Get list of services/features that this EC supports</td></tr>
<tr><td>EC_CAP_GET_BID = 0x3</td><td>Read Board ID that is used customized behavior</td></tr>
<tr><td>EC_CAP_TEST_NFY = 0x4</td><td>Create test notification event</td></tr>
</tbody></table>
</div>
<h2 id="get-firmware-state"><a class="header" href="#get-firmware-state">Get Firmware State</a></h2>
<p>Returns start of the overall EC if DICE and secure boot was enabled,
currently running firmware version, EC status like boot failures.</p>
<h3 id="secure-boot-and-dice"><a class="header" href="#secure-boot-and-dice">Secure Boot and DICE</a></h3>
<p>DICE is a specification from the Trusted Computing Group that allows the
MCU to verify the signature of the code that it is executing, thereby
establishing trust in the code. To do this, it has a primary bootloader
program that reads the firmware on flash and using a key that is only
accessible by the ROM bootloader, can verify the authenticity of the
firmware.¬†</p>
<p><a href="https://trustedcomputinggroup.org/wp-content/uploads/Hardware-Requirements-for-Device-Identifier-Composition-Engine-r78_For-Publication.pdf"><span class="underline">Trusted Platform Architecture - Device Identity
Composition Engine
(trustedcomputinggroup.org)</span></a>¬†</p>
<h3 id="input-parameters"><a class="header" href="#input-parameters">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters"><a class="header" href="#output-parameters">Output Parameters</a></h3>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Bits</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FWVersion</td>
<td>16</td>
<td>Version of FW running on EC</td>
</tr>
<tr class="even">
<td>SecureState</td>
<td>8</td>
<td><p>Bit mask representing the secure state of the device</p>
<p>0 ‚Äì DICE is enabled</p>
<p>1 ‚Äì Firmware is signed</p></td>
</tr>
<tr class="odd">
<td>BootStatus</td>
<td>8</td>
<td><p>Boot status and error codes</p>
<p>0 = SUCCESS</p></td>
</tr>
</tbody>
</table>
<h3 id="ffa-acpi-example"><a class="header" href="#ffa-acpi-example">FFA ACPI Example</a></h3>
<pre><code>Method (TFWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,32,FWSD) // Out ‚Äì Raw data response (overlaps with CMDD)

    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID) // Management
    Store(20, LENG)
    Store(0x1, CMDD) // EC_CAP_GET_FW_STATE
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (FWSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="get-features-supported"><a class="header" href="#get-features-supported">Get Features Supported</a></h2>
<p>Get a list of services/features supported by this EC. Several features
like HID devices are optional and may not be present. OEM services may
also be added to this list as additional features supported.</p>
<h3 id="input-parameters-1"><a class="header" href="#input-parameters-1">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-1"><a class="header" href="#output-parameters-1">Output Parameters</a></h3>
<table>
<thead>
<tr class="header">
<th>Field</th>
<th>Bits</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DebugMask</td>
<td>16</td>
<td><p>0 ‚Äì Supports reset reason</p>
<p>1 ‚Äì Supports debug tracing</p></td>
</tr>
<tr class="even">
<td>BatteryMask</td>
<td>8</td>
<td><p>0 ‚Äì Battery 0 present</p>
<p>1 ‚Äì Battery 1 present</p>
<p>‚Ä¶</p></td>
</tr>
<tr class="odd">
<td>FanMask</td>
<td>8</td>
<td><p>0 ‚Äì FAN 0 present</p>
<p>1 ‚Äì FAN 1 present</p>
<p>‚Ä¶</p></td>
</tr>
<tr class="even">
<td>ThermalMask</td>
<td>8</td>
<td>0 ‚Äì Skin TZ present</td>
</tr>
<tr class="odd">
<td>HIDMask</td>
<td>8</td>
<td><p>0 ‚Äì HID0 present</p>
<p>1 ‚Äì HID1 present</p>
<p>‚Ä¶</p></td>
</tr>
<tr class="even">
<td>KeyMask</td>
<td>16</td>
<td><p>0 ‚Äì Power key present</p>
<p>1 ‚Äì LID switch present</p>
<p>2 ‚Äì VolUp Key Present</p>
<p>3 ‚Äì VolDown Key Present</p>
<p>4 ‚Äì Camera Key Present</p></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="ffa-acpi-example-1"><a class="header" href="#ffa-acpi-example-1">FFA ACPI Example</a></h3>
<pre><code>Method(TFET, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){})
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateField(BUFF,144,48,FETD) // Output Data

    Store(20, LENG)
    Store(0x2, CMDD) // EC_CAP_GET_SVC_LIST
    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) {
      Return (FETD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="get-board-id"><a class="header" href="#get-board-id">Get Board ID</a></h2>
<p>EC is often used to read pins or details to determine the HW
configuration based on GPIO‚Äôs or ADC values. This ID allows SW to change
behavior depending on this HW version information.</p>
<h3 id="input-parameters-2"><a class="header" href="#input-parameters-2">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-2"><a class="header" href="#output-parameters-2">Output Parameters</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Bits</th><th>Description</th></tr></thead><tbody>
<tr><td>BoardID</td><td>64</td><td>Vendor defined</td></tr>
</tbody></table>
</div>
<h3 id="ffa-acpi-example-2"><a class="header" href="#ffa-acpi-example-2">FFA ACPI Example</a></h3>
<pre><code>Method(TBID, 0x0, Serialized) {
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){})
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18,CMDD) // Command register
    CreateDwordField(BUFF,18,BIDD) // Output Data
    Store(20, LENG)
    Store(0x3, CMDD) // EC_CAP_GET_BID
    Store(ToUUID("330c1273-fde5-4757-9819-5b6539037502"), UUID)
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) {
      Return (BIDD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="firmware-update"><a class="header" href="#firmware-update">Firmware Update</a></h2>
<p>This should initiate update of a particular firmware in the backup
partition to provide NIST SP 800-193 failsafe compliance. EC firmware
update is planned to be handled through CFU. Further details are
available in CFU specification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-power-service"><a class="header" href="#ec-power-service">EC Power Service</a></h1>
<h2 id="system-power-state"><a class="header" href="#system-power-state">System Power State</a></h2>
<p>OS calls in to notify EC or a change in system power state.</p>
<p>Perform appropriate power sequencing for the SoC from low power states
(S3, S4, S5) to S0, and from S0 to low power states</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-1"><a class="header" href="#battery-service-1">Battery Service</a></h1>
<p>Battery control is monitored through the Modern Power Thermal Framework
(MPTF). See this specification for further details on implementing
firmware for these features. This section outlines the interface
required in ACPI for this framework to function.</p>
<div class="table-wrapper"><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody>
<tr><td>EC_BAT_GET_BIX = 0x1</td><td>Returns information about battery, model, serial number voltage. Note this is a superset of BIF. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BST = 0x2</td><td>Get Battery Status, must also have notify event on state change. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_PSR = 0x3</td><td>Returns whether this power source device is currently online. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_PIF = 0x4</td><td>Returns static information about a power source. (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BPS = 0x5</td><td>Power delivery capabilities of battery at present time. (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BTP = 0x6</td><td>Set battery trip point to generate SCI event (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BPT = 0x7</td><td>Set Battery Power Threshold (MPTF)</td></tr>
<tr><td>EC_BAT_GET_BPC = 0x8</td><td>Returns static variables that are associated with system power characteristics on the battery path and power threshold support settings. (MPTF)</td></tr>
<tr><td>EC_BAT_SET_BMC= 0x9</td><td>Battery Maintenance Control</td></tr>
<tr><td>EC_BAT_GET_BMD = 0xA</td><td>Returns battery information regarding charging and calibration</td></tr>
<tr><td>EC_BAT_GET_BCT = 0xB</td><td>Returns battery charge time.</td></tr>
<tr><td>EC_BAT_GET_BTM = 0xC</td><td>Get estimated runtime of battery while discharging</td></tr>
<tr><td>EC_BAT_SET_BMS = 0xD</td><td>Sets battery capacity sampling time in ms</td></tr>
<tr><td>EC_BAT_SET_BMA = 0xE</td><td>Battery Measurement Average Interval</td></tr>
<tr><td>EC_BAT_GET_STA = 0xF</td><td>Get battery availability</td></tr>
</tbody></table>
</div>
<h2 id="ec_bat_get_bix"><a class="header" href="#ec_bat_get_bix">EC_BAT_GET_BIX</a></h2>
<p>Returns information about battery, model, serial number voltage etc</p>
<h3 id="input-parameters-3"><a class="header" href="#input-parameters-3">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-3"><a class="header" href="#output-parameters-3">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bix-battery-information-extended">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-3"><a class="header" href="#ffa-acpi-example-3">FFA ACPI Example</a></h3>
<pre><code>Method (_BIX) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,1088,BIXD) // Out ‚Äì Raw data response max length

    Store(20, LENG)
    Store(0x1, CMDD) // EC_BAT_GET_BIX
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)


    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BIXD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bst"><a class="header" href="#ec_bat_get_bst">EC_BAT_GET_BST</a></h2>
<p>This object returns the present battery status. Whenever the Battery
State value changes, the system will generate an SCI to notify the OS.</p>
<h3 id="input-parameters-4"><a class="header" href="#input-parameters-4">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-4"><a class="header" href="#output-parameters-4">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bst-battery-status">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-4"><a class="header" href="#ffa-acpi-example-4">FFA ACPI Example</a></h3>
<pre><code>Method (_BST) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(34){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,128,BSTD) // Out ‚Äì Raw data response 4 DWords

    Store(20, LENG)
    Store(0x2, CMDD) // EC_BAT_GET_BST
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BSTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_psr"><a class="header" href="#ec_bat_get_psr">EC_BAT_GET_PSR</a></h2>
<p>Returns whether the power source device is currently in use. This can be
used to determine if system is running off this power supply or adapter.
On mobile systes this will report that the system is not running on the
AC adapter if any of the batteries in the system is being forced to
discharge. In systems that contains multiple power sources, this object
reports the power source‚Äôs online or offline status.</p>
<h3 id="input-parameters-5"><a class="header" href="#input-parameters-5">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-5"><a class="header" href="#output-parameters-5">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#battery-control-methods">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-5"><a class="header" href="#ffa-acpi-example-5">FFA ACPI Example</a></h3>
<pre><code>Method (_PSR) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,32,PSRD) // Out ‚Äì Raw data response (overlaps with CMDD)
    
    Store(20, LENG)
    Store(0x3, CMDD) // EC_BAT_GET_PSR
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (PSRD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_pif"><a class="header" href="#ec_bat_get_pif">EC_BAT_GET_PIF</a></h2>
<p>This object returns information about the Power Source, which remains
constant until the Power Source is changed. When the power source
changes, the platform issues a Notify(0x0) (Bus Check) to the Power
Source device to indicate that OSPM must re-evaluate the _PIF object.</p>
<h3 id="input-parameters-6"><a class="header" href="#input-parameters-6">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-6"><a class="header" href="#output-parameters-6">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#pif-power-source-information">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-6"><a class="header" href="#ffa-acpi-example-6">FFA ACPI Example</a></h3>
<pre><code>Method (_PIF) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,1088,PIFD) // Out ‚Äì Raw data response (overlaps with CMDD)
    Store(20, LENG)
    Store(0x4, CMDD) // EC_BAT_GET_PIF
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (PIFD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bps"><a class="header" href="#ec_bat_get_bps">EC_BAT_GET_BPS</a></h2>
<p>This optional object returns the power delivery capabilities of the
battery at the present time. If multiple batteries are present within
the system, the sum of peak power levels from each battery can be used
to determine the total available power.</p>
<h3 id="input-parameters-7"><a class="header" href="#input-parameters-7">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-7"><a class="header" href="#output-parameters-7">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-7"><a class="header" href="#ffa-acpi-example-7">FFA ACPI Example</a></h3>
<pre><code>Method (_BPS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,136,BPSD) // Out ‚Äì BSP structure 5 integers

    Store(20, LENG)
    Store(0x5, CMDD) // EC_BAT_GET_BPS
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_btp"><a class="header" href="#ec_bat_set_btp">EC_BAT_SET_BTP</a></h2>
<p>This object is used to set a trip point to generate an SCI whenever the
Battery Remaining Capacity reaches or crosses the value specified in the
_BTP object. Required on systems supporting Modern Standby</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/platform-design-for-modern-standby">Platform design for modern standby | Microsoft
Learn</a></p>
<h3 id="input-parameters-8"><a class="header" href="#input-parameters-8">Input Parameters</a></h3>
<p>See ACPI documentation for details</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#btp-battery-trip-point">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-8"><a class="header" href="#output-parameters-8">Output Parameters</a></h3>
<p>None</p>
<h3 id="ffa-acpi-example-8"><a class="header" href="#ffa-acpi-example-8">FFA ACPI Example</a></h3>
<pre><code>Method (_BTP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDWordField(BUFF,19, BTP1) // In ‚Äì Battery Trip Point

    Store(20, LENG)
    Store(0x6, CMDD) // EC_BAT_SET_BTP
    Store(Arg0, BTP1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bpc"><a class="header" href="#ec_bat_get_bpc">EC_BAT_GET_BPC</a></h2>
<p>This optional object returns static values that are used to configure
power threshold support in the platform firmware. OSPM can use the
information to determine the capabilities of power delivery and
threshold support for each battery in the system.</p>
<h3 id="input-parameters-9"><a class="header" href="#input-parameters-9">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-9"><a class="header" href="#output-parameters-9">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpc-battery-power-characteristics">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-9"><a class="header" href="#ffa-acpi-example-9">FFA ACPI Example</a></h3>
<pre><code>Method (_BPC) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(24){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,19,128, BPCD) // Out ‚Äì BPC output Data

    Store(20, LENG)
    Store(0x8, CMDD) // EC_BAT_GET_BPC
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPCD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bpt"><a class="header" href="#ec_bat_set_bpt">EC_BAT_SET_BPT</a></h2>
<p>his optional object may be present under a battery device. OSPM must
read _BPC first to determine the power delivery capability threshold
support in the platform firmware and invoke this Method in order to
program the threshold accordingly. If the platform does not support
battery peak power thresholds, this Method should not be included in the
namespace.</p>
<h3 id="input-parameters-10"><a class="header" href="#input-parameters-10">Input Parameters</a></h3>
<p>See ACPI specification for input parameters</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpt-battery-power-threshold">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-10"><a class="header" href="#output-parameters-10">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bpt-battery-power-threshold">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-10"><a class="header" href="#ffa-acpi-example-10">FFA ACPI Example</a></h3>
<pre><code>Method (_BPT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, BPT1) // In ‚Äì Averaging Interval
    CreateDwordField(BUFF,23, BPT2) // In ‚Äì Threshold ID
    CreateDwordField(BUFF,27, BPT3) // In ‚Äì Threshold Value
    CreateField(BUFF,144,32,BPTD) // Out ‚Äì BPT integer output

    Store(0x30, LENG)
    Store(0x7, CMDD) // EC_BAT_SET_BPT
    Store(Arg0,BPT1)
    Store(Arg1,BPT2)
    Store(Arg2,BPT3)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BPTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bmc"><a class="header" href="#ec_bat_set_bmc">EC_BAT_SET_BMC</a></h2>
<p>This object is used to initiate calibration cycles or to control the
charger and whether or not a battery is powering the system. This object
is only present under a battery device if the _BMD Capabilities Flags
field has bit 0, 1, 2, or 5 set.</p>
<h3 id="input-parameters-11"><a class="header" href="#input-parameters-11">Input Parameters</a></h3>
<p>See ACPI specification for input parameter definition</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bmc-battery-maintenance-control">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="output-parameters-11"><a class="header" href="#output-parameters-11">Output Parameters</a></h3>
<p>None</p>
<h3 id="ffa-acpi-example-11"><a class="header" href="#ffa-acpi-example-11">FFA ACPI Example</a></h3>
<pre><code>Method (_BMC) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDWordField(BUFF,19, BMCF) // In ‚Äì Feature Control Flags

    Store(20, LENG)
    Store(0x9, CMDD) // EC_BAT_SET_BMC
    Store(Arg0,BMCF)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bmd"><a class="header" href="#ec_bat_get_bmd">EC_BAT_GET_BMD</a></h2>
<p>This optional object returns information about the battery‚Äôs
capabilities and current state in relation to battery calibration and
charger control features. If the _BMC object (defined below) is present
under a battery device, this object must also be present. Whenever the
Status Flags value changes, AML code will issue a
Notify(battery_device, 0x82). In addition, AML will issue a
Notify(battery_device, 0x82) if evaluating _BMC did not result in
causing the Status Flags to be set as indicated in that argument to
_BMC. AML is not required to issue Notify(battery_device, 0x82) if the
Status Flags change while evaluating _BMC unless the change does not
correspond to the argument passed to _BMC.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bmd-battery-maintenance-data">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-12"><a class="header" href="#input-parameters-12">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-12"><a class="header" href="#output-parameters-12">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-12"><a class="header" href="#ffa-acpi-example-12">FFA ACPI Example</a></h3>
<pre><code>Method (_BMD) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(40){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,160,BMDD) // Out ‚Äì BMD structure 5 DWords

    Store(20, LENG)
    Store(0xA, CMDD) // EC_BAT_GET_BMD
    Store(Arg0,BMCF)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMDD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_bct"><a class="header" href="#ec_bat_get_bct">EC_BAT_GET_BCT</a></h2>
<p>When the battery is charging, this optional object returns the estimated
time from present to when it is charged to a given percentage of Last
Full Charge Capacity.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bct-battery-charge-time">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-13"><a class="header" href="#input-parameters-13">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-13"><a class="header" href="#output-parameters-13">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-13"><a class="header" href="#ffa-acpi-example-13">FFA ACPI Example</a></h3>
<pre><code>Method (_BCT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(22){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDWordField(BUFF,19, CHLV) // In ‚Äì ChargeLevel
    CreateField(BUFF,144,32,BCTD) // Out ‚Äì Raw data response (overlaps with CMDD)

    Store(20, LENG)
    Store(0xB, CMDD) // EC_BAT_GET_BCT
    Store(Arg0,CHLV)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BCTD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_btm"><a class="header" href="#ec_bat_get_btm">EC_BAT_GET_BTM</a></h2>
<p>This optional object returns the estimated runtime of the battery while
it is discharging.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#btm-battery-time">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-14"><a class="header" href="#input-parameters-14">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-14"><a class="header" href="#output-parameters-14">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h2 id="ec_bat_set_bms"><a class="header" href="#ec_bat_set_bms">EC_BAT_SET_BMS</a></h2>
<p>This object is used to set the sampling time of the battery capacity
measurement, in milliseconds.</p>
<p>The Sampling Time is the duration between two consecutive measurements
of the battery‚Äôs capacities specified in _BST, such as present rate and
remaining capacity. If the OSPM makes two succeeding readings through
_BST beyond the duration, two different results will be returned.</p>
<p>The OSPM may read the Max Sampling Time and Min Sampling Time with _BIX
during boot time, and set a specific sampling time within the range with
_BMS.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bms-battery-measurement-sampling-time">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-15"><a class="header" href="#input-parameters-15">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-15"><a class="header" href="#output-parameters-15">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-14"><a class="header" href="#ffa-acpi-example-14">FFA ACPI Example</a></h3>
<pre><code>Method (_BMS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, BMS1) // In ‚Äì Sampling Time
    CreateField(BUFF,144,32,BMSD) // Out ‚Äì BPT integer output

    Store(20, LENG)
    Store(0xD, CMDD) // EC_BAT_SET_BMS
    Store(Arg0,BMS1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMSD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_set_bma"><a class="header" href="#ec_bat_set_bma">EC_BAT_SET_BMA</a></h2>
<p>This object is used to set the averaging interval of the battery
capacity measurement, in milliseconds. The Battery Measurement Averaging
Interval is the length of time within which the battery averages the
capacity measurements specified in _BST, such as remaining capacity and
present rate.</p>
<p>The OSPM may read the Max Average Interval and Min Average Interval with
_BIX during boot time, and set a specific average interval within the
range with _BMA.</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/10_Power_Source_and_Power_Meter_Devices/Power_Source_and_Power_Meter_Devices.html#bma-battery-measurement-averaging-interval">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="input-parameters-16"><a class="header" href="#input-parameters-16">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-16"><a class="header" href="#output-parameters-16">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-15"><a class="header" href="#ffa-acpi-example-15">FFA ACPI Example</a></h3>
<pre><code>Method (_BMA) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, BMA1) // In ‚Äì Averaging Interval
    CreateField(BUFF,144,32,BMAD) // Out ‚Äì BMA integer output
    
    Store(20, LENG)
    Store(0xE, CMDD) // EC_BAT_SET_BMA
    Store(Arg0,BMS1)
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (BMAD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_bat_get_sta"><a class="header" href="#ec_bat_get_sta">EC_BAT_GET_STA</a></h2>
<p>Returns battery status to the OS along with any error conditions as defined by ACPI specification.</p>
<h3 id="input-parameters-17"><a class="header" href="#input-parameters-17">Input Parameters</a></h3>
<p>None</p>
<h3 id="output-parameters-17"><a class="header" href="#output-parameters-17">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<p><a href="https://uefi.org/htmlspecs/ACPI_Spec_6_4_html/06_Device_Configuration/Device_Configuration.html#sta-device-status">10. Power Source and Power Meter Devices ‚Äî ACPI Specification 6.4
documentation</a></p>
<h3 id="ffa-acpi-example-16"><a class="header" href="#ffa-acpi-example-16">FFA ACPI Example</a></h3>
<pre><code>Method (_STA) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,32,STAD) // Out ‚Äì Raw data with status

    Store(20, LENG)
    Store(0xF, CMDD) // EC_BAT_GET_STA
    Store(ToUUID("25cb5207-ac36-427d-aaef-3aa78877d27e"), UUID) // Battery
    Store(Store(BUFF, \\_SB_.FFA0.FFAC), BUFF)


    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (STAD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="thermal-zone-service"><a class="header" href="#thermal-zone-service">Thermal Zone Service</a></h1>
<p>Battery temperature and other temperatures are read through a modified
thermal interface called Microsoft Temperature Sensor that implements
the _TMP and _DSM functionality. There is also still a generic thermal
zone interface which has a few more entries for system outside of MPTF.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>EC_THM_GET_TMP = 0x1</td><td>Returns the thermal zone‚Äôs current temperature in tenths of degrees.</td></tr>
<tr><td>EC_THM_SET_THRS = 0x2</td><td>Sets the thresholds for high, low and timeout.</td></tr>
<tr><td>EC_THM_GET_THRS = 0x3</td><td>Get thresholds for low and high points</td></tr>
<tr><td>EC_THM_SET_SCP = 0x4</td><td>Set cooling Policy for thermal zone</td></tr>
<tr><td>EC_THM_GET_VAR = 0x5</td><td>Read DWORD variable related to thermal</td></tr>
<tr><td>EC_THM_SET_VAR = 0x6</td><td>Write DWORD variable related to thermal</td></tr>
</tbody></table>
</div>
<h2 id="ec_thm_get_tmp"><a class="header" href="#ec_thm_get_tmp">EC_THM_GET_TMP</a></h2>
<p>The Microsoft Thermal Sensor is a simplified <a href="https://uefi.org/specs/ACPI/6.5/11_Thermal_Management.html?highlight=_tmp">ACPI Thermal Zone
object</a>,
it only keeps the temperature input part of the thermal zone. It is used
as the interface to send temperatures from the hardware to the OS. Like
the thermal zone, Thermal Sensor also supports getting temperatures
through _TMP method.</p>
<h3 id="input-parameters-18"><a class="header" href="#input-parameters-18">Input Parameters</a></h3>
<p>Arg0 ‚Äì Byte Thermal Zone Identifier</p>
<h3 id="output-parameters-18"><a class="header" href="#output-parameters-18">Output Parameters</a></h3>
<p>An Integer containing the current temperature of the thermal zone (in
tenths of degrees Kelvin)</p>
<p>The return value is the current temperature of the thermal zone in
tenths of degrees Kelvin. For example, 300.0K is represented by the
integer 3000.</p>
<h3 id="ffa-acpi-example-17"><a class="header" href="#ffa-acpi-example-17">FFA ACPI Example</a></h3>
<pre><code>Method (_TMP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(38){})
    CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
    CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
    CreateField(BUFF, 128, 128, UUID) // UUID of service
    CreateField(BUFF, 256, 8, CMDD) // Command register
    CreateField(BUFF, 264, 8, TMP1) // In ‚Äì Thermal Zone Identifier
    CreateField(BUFF, 264, 32, TMPD) // Out ‚Äì temperature for TZ

    Store(0x1, CMDD) // EC_THM_GET_TMP
    Store(1,TMP1)
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (TMPD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_thm_set_thrs"><a class="header" href="#ec_thm_set_thrs">EC_THM_SET_THRS</a></h2>
<p>Update thresholds for thermal zone</p>
<p>The platform should inform the OSPM to read _TMP method through
Notify(device, 0x80) when <strong><span class="underline">any</span></strong> of
below conditions is met:¬†</p>
<ul>
<li>The <strong>Timeout</strong> has been met.¬†</li>
</ul>
<!-- end list -->
<ul>
<li>The current temperature crosses the zone specified by
<strong>LowTemperature</strong> or <strong>HighTemperature</strong>.¬†</li>
</ul>
<h3 id="input-parameters-19"><a class="header" href="#input-parameters-19">Input Parameters</a></h3>
<p>Arg0 ‚Äì Byte Thermal Zone Identifier</p>
<p>Arg1 ‚Äì Timeout // Integer (DWORD) in mS</p>
<p>Arg2 ‚Äì LowTemperature // Integer (DWORD)¬†in tenth deg Kelvin</p>
<p>Arg3 - HighTemperature // Integer (DWORD)¬†in tenth deg Kelvin</p>
<h3 id="output-parameters-19"><a class="header" href="#output-parameters-19">Output Parameters</a></h3>
<p>Integer with status</p>
<ul>
<li>
<p>0x00000000: Succeed¬†</p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter¬†</p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision¬†</p>
</li>
<li>
<p>0x00000003: Failure, hardware error¬†</p>
</li>
<li>
<p>Others: Reserved¬†</p>
</li>
</ul>
<h3 id="ffa-acpi-example-18"><a class="header" href="#ffa-acpi-example-18">FFA ACPI Example</a></h3>
<pre><code>Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj}) {
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(‚Äú1f0849fc-a845-4fcf-865c-4101bf8e8d79¬†‚Äù)))
  {

  // Implement function 1 which is update threshold
  If(LEqual(Arg2,One)) {
    // Check to make sure FFA is available and not unloaded
    If(LEqual(\_SB.FFA0.AVAL,One)) {
      Name(BUFF, Buffer(46){})
      CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
      CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
      CreateField(BUFF, 128, 128, UUID) // UUID of service
      CreateField(BUFF, 256, 8, CMDD) // Command register
      CreateField(BUFF, 264, 8, TID1) // In ‚Äì Thermal Zone Identifier
      CreateField(BUFF, 272, 32, THS1) // In ‚Äì Timeout in ms
      CreateField(BUFF, 304, 32, THS2) // In ‚Äì Low threshold tenth Kelvin
      CreateField(BUFF, 336, 32, THS3) // In ‚Äì High threshold tenth Kelvin
      CreateField(BUFF, 264, 32, THSD) // Out ‚Äì Status from EC

      Store(0x2, CMDD) // EC_THM_SET_THRS
      Store(1,TID1)
      Store(Arg0,THS1)
      Store(Arg1,THS2)
      Store(Arg2,THS3)
      Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (THSD)
      } else {
        Return(Zero)
      }
    } else {
      Return(Zero)
    }
  }
}
</code></pre>
<h2 id="ec_thm_get_thrs"><a class="header" href="#ec_thm_get_thrs">EC_THM_GET_THRS</a></h2>
<p>Read back thresholds that have been set or default thresholds that exist
on the EC.</p>
<h3 id="input-parameters-20"><a class="header" href="#input-parameters-20">Input Parameters</a></h3>
<p>Arg0 - Thermal ID ‚Äì Identifier to determine which TZ to read the
thresholds for</p>
<h3 id="output-parameters-20"><a class="header" href="#output-parameters-20">Output Parameters</a></h3>
<p>Arg0 ‚Äì Status // 0 on success or neagtive error code</p>
<p>Arg1 ‚Äì Timeout // Integer (DWORD) in mS</p>
<p>Arg2 ‚Äì LowTemperature // Integer (DWORD)¬†in tenth deg Kelvin</p>
<p>Arg3 - HighTemperature // Integer (DWORD)¬†in tenth deg Kelvin</p>
<h3 id="ffa-acpi-example-19"><a class="header" href="#ffa-acpi-example-19">FFA ACPI Example</a></h3>
<pre><code>Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj}) {
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(‚Äú1f0849fc-a845-4fcf-865c-4101bf8e8d79¬†‚Äù)))
  {
    // Implement function 2 which is update threshold
    If(LEqual(Arg2,Two)) {
      // Check to make sure FFA is available and not unloaded
      If(LEqual(\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(50){})
        CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
        CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
        CreateField(BUFF, 128, 128, UUID) // UUID of service
        CreateField(BUFF, 256, 8, CMDD) // Command register
        CreateField(BUFF, 264, 8, TID1) // In ‚Äì Thermal Zone Identifier
        CreateField(BUFF, 264, 128, THSD) // Out ‚Äì Status from EC

        Store(0x3, CMDD) // EC_THM_GET_THRS
        Store(1,TID1)
        Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

        If(LEqual(STAT,0x0) ) // Check FF-A successful?
        {
          Return (THSD)
        } else {
          Return(Zero)
        }
    } else {
      Return(Zero)
    }
  }
}
</code></pre>
<h2 id="ec_thm_set_scp"><a class="header" href="#ec_thm_set_scp">EC_THM_SET_SCP</a></h2>
<p>This optional object is a control method that OSPM invokes to set the
platform‚Äôs cooling mode policy setting.¬†</p>
<h3 id="input-parameters-21"><a class="header" href="#input-parameters-21">Input Parameters</a></h3>
<p>Arg0 - Identifier to determine which TZ to read the thresholds for</p>
<p>Arg1 -¬†Mode¬†An Integer containing the cooling mode policy code</p>
<p>Arg2 -¬†AcousticLimit¬†An Integer containing the acoustic limit</p>
<p>Arg3 -¬†PowerLimit¬†An Integer containing the power limit</p>
<h3 id="output-parameters-21"><a class="header" href="#output-parameters-21">Output Parameters</a></h3>
<p>Arg0 ‚Äì Status from EC</p>
<ul>
<li>
<p>0x00000000: Succeed¬†</p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter¬†</p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision¬†</p>
</li>
<li>
<p>0x00000003: Failure, hardware error¬†</p>
</li>
<li>
<p>Others: Reserved¬†</p>
</li>
</ul>
<h3 id="ffa-acpi-example-20"><a class="header" href="#ffa-acpi-example-20">FFA ACPI Example</a></h3>
<pre><code>Method (_SCP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(46){})
    CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
    CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
    CreateField(BUFF, 128, 128, UUID) // UUID of service
    CreateField(BUFF, 256, 8, CMDD) // Command register
    CreateField(BUFF, 264, 8, TID1) // In ‚Äì Thermal Zone Identifier
    CreateField(BUFF, 272, 32, SCP1) // In ‚Äì Timeout in ms
    CreateField(BUFF, 304, 32, SCP2) // In ‚Äì Low threshold tenth Kelvin
    CreateField(BUFF, 336, 32, SCP3) // In ‚Äì High threshold tenth Kelvin
    CreateField(BUFF, 264, 32, SCPD) // Out ‚Äì Status from EC

    Store(0x4, CMDD) // EC_THM_SET_SCP
    Store(1,TID1)
    Store(Arg0,SCP1)
    Store(Arg1,SCP2)
    Store(Arg2,SCP3)
    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID) // Thermal
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (SCPD)
    } else {
      Return(Zero)
    }
  } else {
    Return(Zero)
  }
}
</code></pre>
<h2 id="ec_thm_get_var"><a class="header" href="#ec_thm_get_var">EC_THM_GET_VAR</a></h2>
<p>This API is to read a variable from the EC related to thermal. Variables
are defined as GUID‚Äôs and include length of variable to read. In the
case of default MPTF interface it is expecting a 32-bit variable.</p>
<h3 id="input-parameters-22"><a class="header" href="#input-parameters-22">Input Parameters</a></h3>
<p>Arg0 ‚Äì 128-bit UUID the defines the variable</p>
<p>Arg1 ‚Äì 16-bit Length field specifies the length of variable in bytes</p>
<h3 id="output-parameters-22"><a class="header" href="#output-parameters-22">Output Parameters</a></h3>
<p>Arg0 ‚Äì 32-bit status field</p>
<ul>
<li>
<p>0x00000000: Succeed¬†</p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter¬†</p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision¬†</p>
</li>
<li>
<p>0x00000003: Failure, hardware error¬†</p>
</li>
<li>
<p>Others: Reserved¬†</p>
</li>
</ul>
<p>Var ‚Äì Variable length data must match requested length otherwise should
return error code</p>
<h3 id="ffa-acpi-example-21"><a class="header" href="#ffa-acpi-example-21">FFA ACPI Example</a></h3>
<pre><code>Method(GVAR,2,Serialized) {
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(52){})
    CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
    CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
    CreateField(BUFF, 128, 128, UUID) // UUID of service
    CreateField(BUFF, 256, 8, CMDD) // Command register
    CreateField(BUFF, 264, 8, INST) // In ‚Äì Instance ID
    CreateField(BUFF, 272, 16, VLEN) // In ‚Äì Variable Length in bytes
    CreateField(BUFF, 288, 128, VUID) // In ‚Äì Variable UUID
    CreateField(BUFF, 264, 64, RVAL) // Out ‚Äì Variable value

    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
    Store(0x5, CMDD) // EC_THM_GET_VAR
    Store(Arg0,INST) // Save instance ID
    Store(4,VLEN) // Variable is always DWORD here
    Store(Arg1, VUID)
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
  
    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
     Return (RVAL)
    }
  }
  Return (Ones)
}
</code></pre>
<h2 id="ec_thm_set_var"><a class="header" href="#ec_thm_set_var">EC_THM_SET_VAR</a></h2>
<p>This API is to write a variable to the EC related to thermal. Variables
are defined as GUID‚Äôs and include length of variable to write. In the
case of default MPTF interface it is expecting a 32-bit variable.</p>
<h3 id="input-parameters-23"><a class="header" href="#input-parameters-23">Input Parameters</a></h3>
<p>Arg0 ‚Äì 128-bit UUID the defines the variable</p>
<p>Arg1 ‚Äì 16-bit Length field specifies the length of variable in bytes</p>
<p>Var - Variable length field of variable data</p>
<h3 id="output-parameters-23"><a class="header" href="#output-parameters-23">Output Parameters</a></h3>
<p>Arg0 ‚Äì 32-bit status field</p>
<ul>
<li>
<p>0x00000000: Succeed¬†</p>
</li>
<li>
<p>0x00000001: Failure, invalid parameter¬†</p>
</li>
<li>
<p>0x00000002: Failure, unsupported revision¬†</p>
</li>
<li>
<p>0x00000003: Failure, hardware error¬†</p>
</li>
<li>
<p>Others: Reserved¬†</p>
</li>
</ul>
<h3 id="ffa-acpi-example-22"><a class="header" href="#ffa-acpi-example-22">FFA ACPI Example</a></h3>
<pre><code>Method(SVAR,3,Serialized) {
  If(LEqual(\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(60){})
    CreateField(BUFF, 0, 64, STAT) // Out ‚Äì Status
    CreateField(BUFF, 64, 64, RCVD) // ReceiverId(only lower 16-bits are used) 
    CreateField(BUFF, 128, 128, UUID) // UUID of service
    CreateField(BUFF, 256, 8, CMDD) // Command register
    CreateField(BUFF, 264, 8, INST) // In ‚Äì Instance ID
    CreateField(BUFF, 272, 16, VLEN) // In ‚Äì Variable Length in bytes
    CreateField(BUFF, 288, 128, VUID) // In ‚Äì Variable UUID
    CreateField(BUFF, 416, 64, DVAL) // In ‚Äì Variable UUID
    CreateField(BUFF, 264, 64, RVAL) // Out ‚Äì status

    Store(ToUUID("31f56da7-593c-4d72-a4b3-8fc7171ac073"), UUID)
    Store(0x6, CMDD) // EC_THM_SET_VAR
    Store(Arg0,INST) // Save instance ID
    Store(4,VLEN) // Variable is always DWORD here
    Store(Arg1, VUID)
    Store(Arg2,DVAL)
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (RVAL)
    }
  }
  Return (Ones)
}
</code></pre>
<h1 id="fan-service"><a class="header" href="#fan-service">Fan Service</a></h1>
<p>The new MBTF framework depends on reading and writing variables on the
EC to allow the EC to make the best decisions on cooling. The
recommendations from the OS are aggregated on the EC side and decisions
are made on setting FAN speed based on these.</p>
<p>All the control of fan and thermal parameters is done through variable
interface using EC_THM_GET_VAR and EC_THM_SET_VAR.</p>
<h2 id="fan-and-thermal-variables"><a class="header" href="#fan-and-thermal-variables">Fan and Thermal variables</a></h2>
<p>It is optional to implement Dba and Sones.</p>
<table>
<thead>
<tr class="header">
<th><strong>Variable</strong></th>
<th><strong>GUID</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<td>OnTemp</td>
<td>ba17b567-c368-48d5-bc6f-a312a41583c1</td>
<td>Lowest temperature at which the fan is turned on.</td>
</tr>
<td>RampTemp</td>
<td>3a62688c-d95b-4d2d-bacc-90d7a5816bcd</td>
<td>Temperature at which the fan starts ramping from min speed.</td>
</tr>
<td>MaxTemp</td>
<td>dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76</td>
<td>Temperature at top of fan ramp where fan is at maximum speed.</td>
</tr>
<td>CrtTemp</td>
<td>218246e7-baf6-45f1-aa13-07e4845256b8</td>
<td>Critical temperature at which we need to shut down the system.</td>
</tr>
<td>ProcHotTemp</td>
<td>22dc52d2-fd0b-47ab-95b8-26552f9831a5</td>
<td>Temperature at which the EC will assert the PROCHOT notification.</td>
</tr>
<td>MinRpm</td>
<td>db261c77-934b-45e2-9742-256c62badb7a</td>
<td>Minimum RPM FAN speed</td>
</tr>
<td>MinDba (Optional)</td>
<td>0457a722-58f4-41ca-b053-c7088fcfb89d</td>
<td>Minimum Dba from FAN</td>
</tr>
<td><p>MinSones (Optional)</td>
<td>311668e2-09aa-416e-a7ce-7b978e7f88be</td>
<td>Minimum Sones from FAN</td>
</tr>
<td>MaxRpm</td>
<td>5cf839df-8be7-42b9-9ac5-3403ca2c8a6a</td>
<td>Maximum RPM for FAN</td>
</tr>
<td>MaxDba (Optional)</td>
<td>372ae76b-eb64-466d-ae6b-1228397cf374</td>
<td>Maximum DBA for FAN</td>
</tr>
<td>MaxSones (Optional)</td>
<td>6deb7eb1-839a-4482-8757-502ac31b20b7</td>
<td>Maximum Sones for FAN</td>
</tr>
<td>ProfileType</td>
<td>23b4a025-cdfd-4af9-a411-37a24c574615</td>
<td>Set profile for EC, gaming, quiet, lap, etc</td>
</tr>
<td>CurrentRpm</td>
<td>adf95492-0776-4ffc-84f3-b6c8b5269683</td>
<td>The current RPM of FAN</td>
</tr>
<td>CurrentDba (Optional)</td>
<td>4bb2ccd9-c7d7-4629-9fd6-1bc46300ee77</td>
<td>The current Dba from FAN</td>
</tr>
<td>CurrentSones (Optional)</td>
<td>7719d686-02af-48a5-8283-20ba6ca2e940</td>
<td>The current Sones from FAN</td>
</tr>
</tbody>
</table>
<h2 id="acpi-example-of-inputoutput-_dsm"><a class="header" href="#acpi-example-of-inputoutput-_dsm">ACPI example of Input/Output _DSM</a></h2>
<pre><code>// Arg0 GUID
// 07ff6382-e29a-47c9-ac87-e79dad71dd82 - Input
// d9b9b7f3-2a3e-4064-8841-cb13d317669e - Output
// Arg1 Revision
// Arg2 Function Index
// Arg3 Function dependent

Method(_DSM, 0x4, Serialized) {
  // Input Variable
  If(LEqual(ToUuid("07ff6382-e29a-47c9-ac87-e79dad71dd82"),Arg0)) {
    Switch(Arg2) {
      Case(0) {
        // We support function 0-3
        Return(0xf)
      }
      Case(1) {
        Return(GVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"))) // OnTemp
      }
      Case(2) {
        Return(GVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"))) // RampTemp
      }
      Case(3) {
        Return(GVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"))) // MaxTemp
      }
    }
    Return(Ones)
  }

  // Output Variable
  If(LEqual(ToUuid("d9b9b7f3-2a3e-4064-8841-cb13d317669e"),Arg0)) {
    Switch(Arg2) {
      Case(0) {
        // We support function 0-3
        Return(0xf)
      }
      Case(1) {
        Return(SVAR(1,ToUuid("ba17b567-c368-48d5-bc6f-a312a41583c1"),Arg3)) // OnTemp
      }

      Case(2) {
        Return(SVAR(1,ToUuid("3a62688c-d95b-4d2d-bacc-90d7a5816bcd"),Arg3)) // RampTemp
      }

      Case(3) {
        Return(SVAR(1,ToUuid("dcb758b1-f0fd-4ec7-b2c0-ef1e2a547b76"),Arg3)) // MaxTemp
      }
    }
    Return(Ones)
  }
  Return (Ones)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ucsi-interface"><a class="header" href="#ucsi-interface">UCSI Interface</a></h1>
<p>EC must have the ability to interface with a discrete PD controller to
negotiate power contracts/alt-modes with port partner</p>
<p>See the UCSI specification for commands that are required in all UCSI
implementations.</p>
<p><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/usbcon/ucsi">USB-C Connector System Software Interface (UCSI) Driver - Windows
drivers | Microsoft
Learn</a></p>
<p>In addition to the commands marked as¬†<strong>Required</strong>, Windows requires
these commands:</p>
<ul>
<li>
<p>GET_ALTERNATE_MODES</p>
</li>
<li>
<p>GET_CAM_SUPPORTED</p>
</li>
<li>
<p>GET_PDOS</p>
</li>
<li>
<p>SET_NOTIFICATION_ENABLE: The system or controller must support the
following notifications within SET_NOTIFICATION_ENABLE:</p>
<ul>
<li>
<p>Supported Provider Capabilities Change</p>
</li>
<li>
<p>Negotiated Power Level Change</p>
</li>
</ul>
</li>
<li>
<p>GET_CONNECTOR_STATUS: The system or controller must support these
connector status changes within GET_CONNECTOR_STATUS:</p>
<ul>
<li>
<p>Supported Provider Capabilities Change</p>
</li>
<li>
<p>Negotiated Power Level Change</p>
</li>
</ul>
</li>
</ul>
<p><img src="specs/ec_interface/media/image10.png" alt="Diagram of USB Type-C software components." /></p>
<h2 id="ucsi-acpi-interface"><a class="header" href="#ucsi-acpi-interface">UCSI ACPI Interface</a></h2>
<p><img src="specs/ec_interface/media/image11.png" alt="A diagram of a memory Description automatically generated" /></p>
<h3 id="shared-mailbox-interface"><a class="header" href="#shared-mailbox-interface">Shared Mailbox Interface</a></h3>
<p>The following table is the reserved memory structure that must be
reserved and shared with the EC for communication. When using FF-A this
memory region must be statically carved out and 4K aligned and directly
accessible by secure world.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Offset (Bytes)</strong></th><th><strong>Mnemonic</strong></th><th><strong>Description</strong></th><th><strong>Direction</strong></th><th><strong>Size (bits)</strong></th></tr></thead><tbody>
<tr><td>0</td><td>VERSION</td><td>UCSI Version Number</td><td>PPM-&gt;OPM</td><td>16</td></tr>
<tr><td>2</td><td>RESERVED</td><td>Reserved</td><td>N/A</td><td>16</td></tr>
<tr><td>4</td><td>CCI</td><td>USB Type-C Command Status and Connector Change Indication</td><td>PPM-&gt;OPM</td><td>32</td></tr>
<tr><td>8</td><td>CONTROL</td><td>USB Type-C Control</td><td>OPM-&gt;PPM</td><td>64</td></tr>
<tr><td>16</td><td>MESSAGE IN</td><td>USB Type-C Message In</td><td>PPM-&gt;OPM</td><td>128</td></tr>
<tr><td>32</td><td>MESSAGE OUT</td><td>USB Type-C Message Out</td><td>OPM-&gt;PPM</td><td>128</td></tr>
</tbody></table>
</div>
<h3 id="acpi-definitions"><a class="header" href="#acpi-definitions">ACPI Definitions</a></h3>
<pre><code>Device(USBC) {
  Name(_HID,EISAID(‚ÄúUSBC000‚Äù))
  Name(_CID,EISAID(‚ÄúPNP0CA0‚Äù))
  Name(_UID,1)
  Name(_DDN, ‚ÄúUSB Type-C‚Äù)
  Name(_ADR,0x0)

  OperationRegion(USBC, SystemMemory, 0xFFFF0000, 0x30)
  Field(USBC,AnyAcc,Lock,Preserve)
  {
    // USB C Mailbox Interface
    VERS,16, // PPM-\&gt;OPM Version
    RES, 16, // Reservied
    CCI, 32, // PPM-\&gt;OPM CCI Indicator
    CTRL,64, // OPM-\&gt;PPM Control Messages
    MSGI,128, // OPM-\&gt;PPM Message In
    MSGO,128, // PPM-\&gt;OPM Message Out
  }

  Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
  {
    // Compare passed in UUID to Supported UUID
    If(LEqual(Arg0,ToUUID(‚Äú6f8398c2-7ca4-11e4-ad36-631042b5008f‚Äù)))
    {
      // Use FFA to send Notification event down to copy data to EC
      If(LEqual(\\_SB.FFA0.AVAL,One)) {
        Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
        CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
        CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
        CreateField(BUFF,16,128,UUID) // UUID of service
        CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
        CreateField(BUFF,144,1024,FIFD) // Out ‚Äì Msg data

        CreateField(BUFF,0x0,128,UUID)
        // Create USCI Doorbell Event

        Store(20, LENG)
        Store(0x0, CMDD) // UCSI set doorbell
        Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID) // UCSI
        Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

        If(LEqual(STAT,0x0) ) // Check FF-A successful?
        {
          Return (FIFD)
        } else {
          Return(error)?
        }
      } // End AVAL
    } // End UUID
  } // End DSM
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-input-management"><a class="header" href="#ec-input-management">EC Input Management</a></h1>
<p>An EC may have several input devices including LID, Power key, touch and
keyboard. HID based devices requiring low latency input, are recommended
to be connected directly through a non-secure BUS interface such as I2C
or I3C for performance reasons.</p>
<h2 id="lid-state"><a class="header" href="#lid-state">LID State</a></h2>
<p>Monitor sensors that indicate lid state. If lid is opened, potentially
boot the system. If lid is closed, potentially shut down or hibernate
the system.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>ACPI</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>_LID</td><td>Get state of LID device for clamshell designs</td></tr>
</tbody></table>
</div>
<h3 id="acpi-example-for-lid-notificiation"><a class="header" href="#acpi-example-for-lid-notificiation">ACPI Example for LID notificiation</a></h3>
<p>Assuming that LID is managed by the EC during registration we register
for Input Management service for a Virtual ID = 1</p>
<pre><code>Method(_RNY, 0, Serialized) {
  Return( Package() {
    Package(0x2) {
      ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),
      Buffer() {0x1,0x0} // Register event 0x1 for LID
    }
    } )
  }

  Method(_NFY, 2, Serialized) {
    // Arg0 == UUID
    // Arg1 == Notify ID
    If(LEqual(ToUUID("e3168a99-4a57-4a2b-8c5e-11bcfec73406"),Arg0)) {
      Switch(Arg1) {
      Case(1) {
        Notify(\\_SB._LID,0x80)
      }
    }
  }
}
</code></pre>
<h2 id="system-wake-event"><a class="header" href="#system-wake-event">System Wake Event</a></h2>
<p>Ability to wake the system from various external events. This is for
more complicated events that aren‚Äôt a simple GPIO for LID/Power button
that require EC monitoring.</p>
<h2 id="hid-descriptor-interface"><a class="header" href="#hid-descriptor-interface">HID descriptor Interface</a></h2>
<p>Communication with EC must have packet sent/received in HID format so
the OS HIDClass driver can properly understand requests. At this time
HID packets will go over HIDI2C but in future these HID packets could be
included over a single interface.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>HID IOCTL</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>IOCTL_HID_GET_DEVICE_DESCRIPTOR</td><td>Retrieves the device's HID descriptor</td></tr>
<tr><td>IOCTL_HID_GET_DEVICE_ATTRIBUTES</td><td>Retrieves a device's attributes in a HID_DEVICE_ATTRIBUTES structure</td></tr>
<tr><td>IOCTL_HID_GET_REPORT_DESCRIPTOR</td><td>Obtains the report descriptor for the HID device</td></tr>
<tr><td>IOCTL_HID_READ_REPORT</td><td>Returns a report from the device into a class driver-supplied buffer</td></tr>
<tr><td>IOCTL_HID_WRITE_REPORT</td><td>Transmits a class driver-supplied report to the device</td></tr>
<tr><td>IOCTL_HID_GET_FEATURE</td><td>Get capabilities of a feature from the device</td></tr>
<tr><td>IOCTL_HID_SET_FEATURE</td><td>Set/Enable a specific feature on device</td></tr>
<tr><td>IOCTL_HID_GET_INPUT_REPORT</td><td>Get input report from HID device if input device</td></tr>
<tr><td>IOCTL_HID_SET_OUTPUT_REPORT</td><td>Send output HID report to device</td></tr>
<tr><td>IOCTL_HID_GET_STRING</td><td>Get a specific string from device</td></tr>
<tr><td>IOCTL_HID_GET_INDEXED_STRING</td><td>Get a string from device based on index</td></tr>
<tr><td>IOCTL_HID_SEND_IDLE_NOTIFICATION</td><td>Notification to idle device into idle/sleep state</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="ec-time-alarm-service"><a class="header" href="#ec-time-alarm-service">EC Time Alarm Service</a></h1>
<p>The following sections define the operation and definition of the
optional control method-based Time and Alarm device, which provides a
hardware independent abstraction and a more robust alternative to the
Real Time Clock (RTC)</p>
<p>ACPI specification details are in version 6.5 Chapter 9.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#time-and-alarm-device">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5 documentation
(uefi.org)</a></p>
<div class="table-wrapper"><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>EC_TAS_GET_GCP = 0x1</td><td>Get the capabilities of the time and alarm device</td></tr>
<tr><td>EC_TAS_GET_GRT = 0x2</td><td>Get the Real Time</td></tr>
<tr><td>EC_TAS_SET_SRT = 0x3</td><td>Set the Real Time</td></tr>
<tr><td>EC_TAS_GET_GWS = 0x4</td><td>Get Wake Status</td></tr>
<tr><td>EC_TAS_SET_CWS = 0x5</td><td>Clear Wake Status</td></tr>
<tr><td>EC_TAS_SET_STV = 0x6</td><td>Set Timer value for given timer</td></tr>
<tr><td>EC_TAS_GET_TIV = 0x7</td><td>Get Timer value remaining for given timer</td></tr>
</tbody></table>
</div>
<h2 id="ec_tas_get_gcp"><a class="header" href="#ec_tas_get_gcp">EC_TAS_GET_GCP</a></h2>
<p>This object is required and provides the OSPM with a bit mask of the
device capabilities.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#gcp-get-capability">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-24"><a class="header" href="#input-parameters-24">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-24"><a class="header" href="#output-parameters-24">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi"><a class="header" href="#ffa-acpi">FFA ACPI</a></h3>
<pre><code>Method (_GCP) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,32,GCPD) // Out ‚Äì 32-bit integer described above
  
    Store(20, LENG)
    Store(0x1, CMDD) // EC_TAS_GET_GCP
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GCDD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_get_grt"><a class="header" href="#ec_tas_get_grt">EC_TAS_GET_GRT</a></h2>
<p>This object is required if the capabilities bit 2 is set to 1. The OSPM
can use this object to get time. The return value is a buffer containing
the time information as described below.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#grt-get-real-time">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-25"><a class="header" href="#input-parameters-25">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-25"><a class="header" href="#output-parameters-25">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-23"><a class="header" href="#ffa-acpi-example-23">FFA ACPI Example</a></h3>
<pre><code>Method (_GRT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(32){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,144,128,GRTD) // Out ‚Äì 128-bit output structure above

    Store(20, LENG)
    Store(0x2, CMDD) // EC_TAS_GET_GRT
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GRTD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_srt"><a class="header" href="#ec_tas_set_srt">EC_TAS_SET_SRT</a></h2>
<p>This object is required if the capabilities bit 2 is set to 1. The OSPM
can use this object to set the time.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#srt-set-real-time">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-26"><a class="header" href="#input-parameters-26">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-26"><a class="header" href="#output-parameters-26">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-24"><a class="header" href="#ffa-acpi-example-24">FFA ACPI Example</a></h3>
<pre><code>Method (_SRT) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateField(BUFF,152,128,GRTD) // In ‚Äì 128-bit output structure above

    Store(20, LENG)
    Store(0x3, CMDD) // EC_TAS_SET_SRT
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (One)
    }
  }
  Return(Zero)}
}
</code></pre>
<h2 id="ec_tas_get_gws"><a class="header" href="#ec_tas_get_gws">EC_TAS_GET_GWS</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
enables the OSPM to read the status of wake alarms</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#gws-get-wake-alarm-status">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-27"><a class="header" href="#input-parameters-27">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-27"><a class="header" href="#output-parameters-27">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-25"><a class="header" href="#ffa-acpi-example-25">FFA ACPI Example</a></h3>
<pre><code>Method (_GWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, GWS1) // In ‚Äì Dword for timer type AC/DC
    CreateField(BUFF,144,32,GWSD) // Out ‚Äì Dword timer state

    Store(20, LENG)
    Store(0x4, CMDD) // EC_TAS_GET_GWS
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (GWSD)
    } 
  } 
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_cws"><a class="header" href="#ec_tas_set_cws">EC_TAS_SET_CWS</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
enables the OSPM to clear the status of wake alarms</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#cws-clear-wake-alarm-status">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-28"><a class="header" href="#input-parameters-28">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-28"><a class="header" href="#output-parameters-28">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-26"><a class="header" href="#ffa-acpi-example-26">FFA ACPI Example</a></h3>
<pre><code>Method (_CWS) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, GWS1) // In ‚Äì Dword for timer type AC/DC
    CreateField(BUFF,144,32,CWSD) // Out ‚Äì Dword timer state
 
    Store(20, LENG)
    Store(0x5, CMDD) // EC_TAS_SET_CWS
    Store(Arg0,GWS1)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (CWSD)
    }
  } 
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_set_stv"><a class="header" href="#ec_tas_set_stv">EC_TAS_SET_STV</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It sets
the timer to the specified value.¬†</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#stv-set-timer-value">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-29"><a class="header" href="#input-parameters-29">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-29"><a class="header" href="#output-parameters-29">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-27"><a class="header" href="#ffa-acpi-example-27">FFA ACPI Example</a></h3>
<pre><code>Method (_STV) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, GWS1) // In ‚Äì Dword for timer type AC/DC
    CreateDwordField(BUFF,23, GWS2) // In ‚Äì Dword Timer Value
    CreateField(BUFF,144,32,STVD) // Out ‚Äì Dword timer state

    Store(20, LENG)
    Store(0x6, CMDD) // EC_TAS_SET_STV
    Store(Arg0,GWS1)
    Store(Arg1,GWS2)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)
  
    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (STVD)
    }
  }
  Return(Zero)
}
</code></pre>
<h2 id="ec_tas_get_tiv"><a class="header" href="#ec_tas_get_tiv">EC_TAS_GET_TIV</a></h2>
<p>This object is required if the capabilities bit 0 is set to 1. It
returns the remaining time of the specified timer before that expires.</p>
<p><a href="https://uefi.org/specs/ACPI/6.5/09_ACPI_Defined_Devices_and_Device_Specific_Objects.html#tiv-timer-values">9. ACPI-Defined Devices and Device-Specific Objects ‚Äî ACPI
Specification 6.5
documentation</a></p>
<h3 id="input-parameters-30"><a class="header" href="#input-parameters-30">Input Parameters</a></h3>
<p>Input parameters as described in ACPI specification.</p>
<h3 id="output-parameters-30"><a class="header" href="#output-parameters-30">Output Parameters</a></h3>
<p>Should return structure as defined by ACPI specification</p>
<h3 id="ffa-acpi-example-28"><a class="header" href="#ffa-acpi-example-28">FFA ACPI Example</a></h3>
<pre><code>Method (_TIV) {
  // Check to make sure FFA is available and not unloaded
  If(LEqual(\\_SB.FFA0.AVAL,One)) {
    Name(BUFF, Buffer(30){}) // Create buffer for send/recv data
    CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
    CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
    CreateField(BUFF,16,128,UUID) // UUID of service
    CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
    CreateDwordField(BUFF,19, GWS1) // In ‚Äì Dword for timer type AC/DC
    CreateField(BUFF,144,32,TIVD) // Out ‚Äì Dword timer state

    Store(20, LENG)
    Store(0x7, CMDD) // EC_TAS_GET_TIV
    Store(Arg0,GWS1)
    Store(ToUUID("23ea63ed-b593-46ea-b027-8924df88e92f"), UUID) // RTC
    Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

    If(LEqual(STAT,0x0) ) // Check FF-A successful?
    {
      Return (TIVD)
    }
  }
  Return(Zero)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-debug-service"><a class="header" href="#ec-debug-service">EC Debug Service</a></h1>
<p>The debug service is used for telemetry, debug logs, system reset
information etc.</p>
<h2 id="recovery-mode"><a class="header" href="#recovery-mode">Recovery Mode</a></h2>
<p>Put EC into recovery mode for development flashing and debugging.</p>
<h2 id="dump-debug-state"><a class="header" href="#dump-debug-state">Dump Debug State</a></h2>
<p>EC should be able to support typical engineering requests, such as
getting detailed subsystem information, setting/getting GPIOs, etc, for
design verification and benchtop testing.</p>
<h2 id="telemetry"><a class="header" href="#telemetry">Telemetry</a></h2>
<p>Ability to communicate with the HLOS event logging system, and record EC
critical events for later analysis.</p>
<h2 id="system-boot-state"><a class="header" href="#system-boot-state">System Boot State</a></h2>
<p>In many designs, OEMs will desire indication that the system is
responding to a power on request. This could be a logo display on the
screen or a bezel LED. EC should be able to control these devices during
the boot sequence.</p>
<p>During first boot sequence EC may also be initialized and setup its
services. Needs to know when OS is up to send notification for events
that are only used by OS.</p>
<h2 id="memory-mapped-transactions"><a class="header" href="#memory-mapped-transactions">Memory Mapped Transactions</a></h2>
<p>There are two cases where you may want to use the memory mapped
transactions. The first is if you have a large buffer you need to
transfer data between EC and HLOS like a debug buffer. The second use
case is if you want to emulate an eSPI memory mapped interface for
compatibility with legacy devices.</p>
<p>For this mode to work you will need memory carved out which is dedicated
and shared between HLOS and secure world. In your UEFI memory map this
memory should be marked as EfiMemoryReservedType so that the OS will not
use or allocate the memory. In your SP manifest file you will also need
to add access to this physical memory range. It needs to be aligned on a
4K boundary and a multiple of 4K. This memory region is carved out and
must never be used for any other purpose. Since the memory is shared
with HLOS there is also no security surrounding accesses to the memory.</p>
<h3 id="example-memory-mapped-interface"><a class="header" href="#example-memory-mapped-interface">Example Memory Mapped Interface</a></h3>
<pre><code>// Map 4K memory region
OperationRegion(ABCD, SystemMemory, 0xFFFF0000, 0x1000)

// Map fields in region if you want to access or set via ACPI
Field(ABCD,AnyAcc,Lock,Preserve) {
  VER,16, // Version
  RES, 16, // Reserved
  VAR1,32, // 32-bit variable1
  VAR2,64, // 64-bit variable1
  VAR3,128, // 128-bit variable1
}

// DSM Method to send sync event
Method(_DSM,4,Serialized,0,UnknownObj, {BuffObj, IntObj,IntObj,PkgObj})
{
  // Compare passed in UUID to Supported UUID
  If(LEqual(Arg0,ToUUID(‚Äú6f8398c2-7ca4-11e4-ad36-631042b5008f‚Äù)))
  {
    // Use FFA to send Notification event down to copy data to EC
    If(LEqual(\\_SB.FFA0.AVAL,One)) {

      Name(BUFF, Buffer(144){}) // Create buffer for send/recv data
      CreateByteField(BUFF,0,STAT) // Out ‚Äì Status for req/rsp
      CreateByteField(BUFF,1,LENG) // In/Out ‚Äì Bytes in req, updates bytes returned
      CreateField(BUFF,16,128,UUID) // UUID of service
      CreateByteField(BUFF,18, CMDD) // In ‚Äì First byte of command
      CreateField(BUFF,144,1024,FIFD) // Out ‚Äì Msg data

      // Create Doorbell Event
      Store(20, LENG)
      Store(0x0, CMDD) // UCSI set doorbell
      Store(ToUUID("daffd814-6eba-4d8c-8a91-bc9bbf4aa301"), UUID)
      Store(Store(BUFF, \_SB_.FFA0.FFAC), BUFF)

      If(LEqual(STAT,0x0) ) // Check FF-A successful?
      {
        Return (Zero)
      } else {
        Return(One)
      }
    } // End AVAL
  } // End UUID
} // End DSM

</code></pre>
<p>Any updates from the EC come back through a notification event
registered in the FFA for this particular service.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-manufacturing-service"><a class="header" href="#ec-manufacturing-service">EC Manufacturing Service</a></h1>
<p>This service should contain all the functionality that is need to
perform self test, validation of the EC and special manufacturing modes.
This service should be disabled on retail devices or at least protected
to prevent unwanted modes.</p>
<h2 id="self-test"><a class="header" href="#self-test">Self Test</a></h2>
<p>EC should perform self test and return results/details of test
validation</p>
<h2 id="set-calibration-data"><a class="header" href="#set-calibration-data">Set Calibration Data</a></h2>
<p>Have ability to store factory calibrations and setup information into EC
non-volatile memory. For instance keyboard language information, or
thermistor calibration values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ec-oem-service"><a class="header" href="#ec-oem-service">EC OEM Service</a></h1>
<p>Any OEM special custom features should be put in their own service
sandbox to support OEM specific features. This will prevent definitions
from colliding with other services.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sample-system-implementation-1"><a class="header" href="#sample-system-implementation-1">Sample System Implementation</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
