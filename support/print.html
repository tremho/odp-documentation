<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Third Party Support</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Third Party Support</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="third-party-support"><a class="header" href="#third-party-support">Third Party Support</a></h1>
<p>There are a number of 3rd party crates that are useful for this type of development.  Of course, almost any crate could be used - mindful of any dependencies, of course - but there are a couple of notable packages that deserve some special attention.</p>
<h3 id="embassy"><a class="header" href="#embassy">Embassy</a></h3>
<p>Embassy is a Rust framework designed for microcontroller development, and has common Hardware Abstraction Layer support for many chipsets.<br />
It leverages Rust's built-in async/await features to provide multitasking that is faster and smaller than a traditional RTOS implementation.
It provides consistent timing abstractions, task prioritization, and supports low-power operation, networking, bluetooth, and USB features.
Boot loader and firmware update support is also provided.</p>
<h3 id="hafnium"><a class="header" href="#hafnium">Hafnium</a></h3>
<p>Hafnium is a Secure Partition Manager for Arm processors. Hafnium itself is maintained as part of the TrustedFirmware organization.
https://www.trustedfirmware.org/projects/hafnium
https://hafnium.readthedocs.io/en/latest/index.html</p>
<p>For implementing under ODP in Arm Hafnium is assumed to be available in the environment that supports it.</p>
<h3 id="dice"><a class="header" href="#dice">DICE</a></h3>
<p>The Device Identifier Composition Engine is a <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG-Endorsement-Architecture-for-Devices-V1-R38_pub.pdf">specification</a> from the <a href="https://trustedcomputinggroup.org/what-is-a-device-identifier-composition-engine-dice/">Trusted Computing Group</a></p>
<p>In essence, DICE describes a crytography library used to validate signed payloads in a public/private key fashion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-embassy"><a class="header" href="#using-embassy">Using Embassy</a></h1>
<p>Embassy provides abstractions for higher-level operations that work across a number of different microcontroller devices in similar ways.  There are layers to this design.</p>
<h2 id="pac"><a class="header" href="#pac">PAC</a></h2>
<p>The Peripheral access crate is the lowest level of this abstraction. One can always write
directly to memory addresses to control their hardware, but the PAC at least raises this to
a symbolic level with consistent semantics.</p>
<p>For example, this code is used to access a GPIO-based LED</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Setup LED
    let gpiob = pac::GPIOB;
    const LED_PIN: usize = 14;
    gpiob.pupdr().modify(|w| w.set_pupdr(LED_PIN, vals::Pupdr::FLOATING));
    gpiob.otyper().modify(|w| w.set_ot(LED_PIN, vals::Ot::PUSH_PULL));
    gpiob.moder().modify(|w| w.set_moder(LED_PIN, vals::Moder::OUTPUT));
<span class="boring">}</span></code></pre></pre>
<p>The actual memory mapping is done by the PAC layer.</p>
<h2 id="hal"><a class="header" href="#hal">HAL</a></h2>
<p>The next level of abstraction is the Hardware Abstraction Layer.  The HAL wraps features of the hardware itself (clock, GPIO, temp, etc) into apis relevant to that hardware.</p>
<p>In a HAL implementation, the code relevant to LED control would be simplified to this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use embassy_stm32::gpio::{Input, Level, Output, Pull, Speed};

//...
let mut led = Output::new(p.PB14, Level::High, Speed::VeryHigh);
led.set_high();
//...
led.set_low();
<span class="boring">}</span></code></pre></pre>
<p>These abstraction layers serve to provide standardized efficiency for common hardware operations while still maintaining complete control.</p>
<h2 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h2>
<p>Responding to interrupts allows the code to respond asynchronously for a registered hardware action to trigger while either performing another task or simply waiting in low-power mode for something to happen.</p>
<h2 id="async-executor"><a class="header" href="#async-executor">async executor</a></h2>
<p>Building on this concept, we arrive at the Embassy asynchronous executor (aka Spawner) that allows a set of tasks that can be run in a cooperative asynchronous mode.  When a task blocks to wait for IO, the executor can switch to run another task.<br />
The <a href="https://embassy.dev/book/">"Embassy Book"</a> lists the following key features of the Embassy Executor:</p>
<ul>
<li>
<p>No alloc, no heap needed. Task are statically allocated.</p>
</li>
<li>
<p>No "fixed capacity" data structures, executor works with 1 or 1000 tasks without needing config/tuning.</p>
</li>
<li>
<p>Integrated timer queue: sleeping is easy, just do Timer::after_secs(1).await;.</p>
</li>
<li>
<p>No busy-loop polling: CPU sleeps when there’s no work to do, using interrupts or WFE/SEV.</p>
</li>
<li>
<p>Efficient polling: a wake will only poll the woken task, not all of them.</p>
</li>
<li>
<p>Fair: a task can’t monopolize CPU time even if it’s constantly being woken. All other tasks get a chance to run before a given task gets polled for the second time.</p>
</li>
<li>
<p>Creating multiple executor instances is supported, to run tasks at different priority levels. This allows higher-priority tasks to preempt lower-priority tasks.</p>
</li>
</ul>
<h2 id="consistent-time"><a class="header" href="#consistent-time">Consistent Time</a></h2>
<p>Embassy provides time drivers for key platforms.  This abstraction greatly simplifies common timing tasks and provides portable semantics.</p>
<h2 id="bootloader-and-peripheral-support"><a class="header" href="#bootloader-and-peripheral-support">Bootloader and peripheral support</a></h2>
<p>Embassy also features a bootloader and firmware update support. This allows you to flash update the firmware in a power-safe manner. Verification features are also available.</p>
<p>Embassy has API support for Networking, USB, WiFi, LoRa, and Bluetooth that may be leveraged,
as well as examples for resource sharing across common bus types (such as SPI and I2C).</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Implementing ODP patterns under Embassy is a highly viable and preferred route since it removes many of the low-level areas of tedious and error-prone mapping tasks and implements proven working designs for the tougher problems of multitasking, timing, and resource sharing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hafnium-1"><a class="header" href="#hafnium-1">Hafnium</a></h1>
<p>The purpose of Hafnium is to provide memory isolation between a set of security domains, to better separate untrusted code from security-critical code. It is implemented as a type-1 hypervisor, where each security domain is a VM.</p>
<p>Hafnium is a type-1 hypervisor, meaning it runs directly on the bare metal hardware rather than being hosted by an underlying operating system (as with type-2 hypervisors like VirtualBox). This allows it to manage CPU and memory resources with minimal overhead, and to enforce strong isolation between security domains at the hardware level.</p>
<p>In an ODP system, where critical components may be implemented in Rust and less trusted components may be written in other languages or come from third parties, Hafnium allows these to coexist in separate Secure Partitions (akin to VMs). Each partition has its own memory space, and interaction between them is typically done via FF-A, shared memory regions, or secure monitor calls (SMCs). This architecture ensures that even a compromised component cannot directly affect or read the memory of others—enforcing strong security boundaries with hardware support.</p>
<p>Hafnium is not a Rust implementation. It is a C++ based hypervisor maintained by the TrustedFirmware Organiziation.  An ODP implementation may use the exposed entry points of this API to interact with it for a secure implementation that isolates individual component code.</p>
<pre class="mermaid">graph TD
    Hafnium[Hafnium Hypervisor]

    PartitionA[Secure Partition A]
    PartitionB[Secure Partition B]

    MemoryA[Shared Memory A]
    MemoryB[Shared Memory B]

    PartitionA --&gt; |SMC|Hafnium
    PartitionB --&gt; |SMC|Hafnium

    PartitionA &lt;--&gt; MemoryA
    PartitionB &lt;--&gt; MemoryB

    MemoryA ---&gt; MemoryB
</pre>
<p><em>This diagram shows the interaction between two partitions, isolated, communicating with Hafnium and optionally from A to B via shared memory.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dice-1"><a class="header" href="#dice-1">DICE</a></h1>
<p>"DICE is a hardware Root-of-Trust (RoT) used to protect the devices and components where a TPM would be impractical or infeasible. When a TPM is present, DICE is used to protect communication with the TPM and provides the Root of Trust for Measurement (RTM) for the platform. DICE was designed to close critical gaps in infrastructure and help to establish safeguarding measures for devices. The DICE RoT can also be easily integrated into existing infrastructure, with the architecture being flexible and interoperable with existing security standards."</p>
<p>DICE (Device Identifier Composition Engine) specifies a hardware Root-of-Trust (RoT) scheme designed to secure the firmware for devices and components in a system where a Trusted Partition Manager (TPM) may not be available, and/or to protect the TPM if it does exist.</p>
<p>Essentially, DICE is used to validate firmware through digital signatures and similar crytographic mechanisms. This prevents unsanctioned firmware updates to be applied or executed.</p>
<p>The DICE specification is not the <em>only</em> way in which a system may be able to validate and secure it's firmware, but it is a proven and certified approach.</p>
<p>While there is no Rust crate that implements this per-se, there are certainly core cryptographic libraries available that can be used to implement the specification.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
