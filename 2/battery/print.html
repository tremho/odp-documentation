<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Battery and Power Management</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Battery and Power Management</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="battery-and-power-management"><a class="header" href="#battery-and-power-management">Battery and Power Management</a></h1>
<p>This example shows how to implement a mock battery service as part of the Embedded Controller (EC) power management system.</p>
<p>In this sample, we are going to implement a complete battery service subsystem.</p>
<h2 id="relevant-repositories"><a class="header" href="#relevant-repositories">Relevant Repositories</a></h2>
<p>We don't need to reinvent any wheels here. The ODP resources include ample template code and examples we can refer to for such a task. It is useful to identify which repositories contain these resources:</p>
<h3 id="soc-embedded-controller"><a class="header" href="#soc-embedded-controller">soc-embedded-controller</a></h3>
<p>This repository provides the core EC functionality, which in this case is centered around power policy and regulation.</p>
<p>Although it includes integration code for an <code>imxrt</code> board, the repository is structured to make portability to other integrations relatively straightforward. We will refer to this often as we work on our own (virtual) battery service implementation.</p>
<p>We’ll begin with the battery service — one of the embedded services — and later return here to integrate our battery into the broader scope of power management.</p>
<h3 id="embedded-services"><a class="header" href="#embedded-services">embedded-services</a></h3>
<p>We've touched on this before in <a href="../embedded_services/index.html">Embedded Services</a>, where we examined a Thermal subsystem implementation and explored variations between secure ARM-based and legacy x86_64-based systems.</p>
<p>We'll return to both of these concepts later. For now, we’ll focus on implementing a Battery subsystem and related Power Policy services. After that, we’ll fold in Thermal support and revisit the secure vs. non-secure implementations.</p>
<h3 id="embedded-batteries"><a class="header" href="#embedded-batteries">embedded-batteries</a></h3>
<p>This repository defines the Hardware Abstraction Layer (HAL) for a battery, tailored to the specific IC hardware being targeted. It builds a layered API chain upward, making most of the code portable and reusable across different integrations.</p>
<hr />
<h3 id="the-smart-battery"><a class="header" href="#the-smart-battery">The Smart Battery</a></h3>
<p>Batteries are ubiquitous in today’s portable devices. With many types of batteries serving various applications and provided by many vendors, the <a href="https://sbs-forum.org/specs/sbdat110.pdf">Smart Battery Data Specification</a> offers a standard to normalize this diversity.</p>
<p>Published by the Smart Battery System Implementers Forum (SBS-IF), this specification defines both electrical characteristics and — more importantly for us — the data and communication semantics of battery state.</p>
<p>Let's explore how this specification informs our implementation.</p>
<h4 id="battery-information"><a class="header" href="#battery-information">Battery Information</a></h4>
<p>A battery provides dynamic information (e.g., remaining charge), static metadata (e.g., make/model/serial/version), and operational parameters (e.g., recommended charge voltage/current).</p>
<p>As explored in <a href="...">...</a>, some of this information is exposed through direct hardware interfaces (e.g., GPIO or MMIO), while others originate from firmware logic or are derived dynamically.</p>
<p>Batteries typically report their state over a bus when queried and may also broadcast alarms when thresholds are breached.</p>
<p>The SBS specification outlines these functions that a smart battery should implement. These define a consistent set of data points and behaviors that other power management components can rely on:</p>
<ul>
<li><code>ManufacturerAccess</code> – Optional, manufacturer-specific 16-bit value.</li>
<li><code>RemainingCapacityAlarm</code> – Battery capacity threshold at which an alert should be raised.</li>
<li><code>RemainingTimeAlarm</code> – Estimated time remaining before an alert should be raised.</li>
<li><code>BatteryMode</code> – Flags indicating operational states or supported features.</li>
<li><code>AtRate</code> – Charging/discharging rate used in subsequent time estimations.</li>
<li><code>AtRateTimeToFull</code> – Time to full charge at the given rate.</li>
<li><code>AtRateTimeToEmpty</code> – Time to depletion at the given rate.</li>
<li><code>AtRateTimeOK</code> – Whether the battery can sustain the given rate for at least 10 seconds.</li>
<li><code>Temperature</code> – Battery temperature.</li>
<li><code>Voltage</code> – Battery voltage.</li>
<li><code>Current</code> – Charge or discharge current.</li>
<li><code>AverageCurrent</code> – One-minute rolling average of current.</li>
<li><code>MaxError</code> – Expected error margin in charge calculations.</li>
<li><code>RelativeStateOfCharge</code> – % of full charge capacity remaining.</li>
<li><code>AbsoluteStateOfCharge</code> – % of design capacity remaining.</li>
<li><code>RemainingCapacity</code> – In mAh or Wh, based on a capacity mode flag.</li>
<li><code>FullChargeCapacity</code> – In mAh or Wh, based on capacity mode.</li>
<li><code>RunTimeToEmpty</code> – Estimated minutes remaining.</li>
<li><code>AverageTimeToEmpty</code> – One-minute average of minutes to empty.</li>
<li><code>AverageTimeToFull</code> – One-minute average of minutes to full charge.</li>
<li><code>BatteryStatus</code> – Flags indicating current state conditions.</li>
<li><code>CycleCount</code> - Number of cycles (a measure of wear). A cycle is the amount of discharge approximately equal to the value of the DesignCapacity.</li>
<li><code>DesignCapacity</code> - The theoretical capacity of a new battery pack.</li>
<li><code>DesignVoltage</code> - The theoritical voltage of a new battery pack.</li>
<li><code>SpecificationInfo</code> - Version and scaling specification info</li>
<li><code>ManufactureDate</code> - The data of manufacture as a bit-packed integer</li>
<li><code>SerialNumber</code> - the manufacturer assigned serial number of this battery pack.</li>
<li><code>ManufacturerName</code> - Name of the manufacturer</li>
<li><code>DeviceName</code> - Name of battery model.</li>
<li><code>DeviceChemistry</code> - String defining the battery chemical type</li>
<li><code>ManufacturerData</code> - (optional) proprietary manufacturer data.</li>
</ul>
<p>Please refer to the actual specification for details.  For example, functions referring to capacity may report in either current (mAh) or wattage (Wh) depending upon the current state of the CAPACITY_MODE flag (found in BatteryMode).</p>
<p>Some systems may support removable batteries, and such conditions must be accounted for in those designs.</p>
<hr />
<h2 id="a-mock-battery"><a class="header" href="#a-mock-battery">A Mock Battery</a></h2>
<p>In our example, we will use a microcontroller board as our EC but will not focus on real battery or charger hardware at this stage.</p>
<p>This allows us to begin development without sourcing specific hardware while still implementing nearly all of the system’s behavior. In the end, we will have a fully functional—albeit artificial—battery subsystem.</p>
<p>Once complete, this mock can be replaced with hardware-specific IO bindings, without requiring changes to the higher-level system logic.</p>
<p>Next we will look at what resources in the ODP repositories we will be working with as we build our battery implementation.</p>
<!--[Return to Library](../../Library.html) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mock-battery-project"><a class="header" href="#a-mock-battery-project">A Mock Battery Project</a></h1>
<p>In the previous section, we saw how the <em>Smart Battery Specification (SBS)</em> defines a set of functions that a Smart Battery service should implement.</p>
<p>In this section, we are going to review how these traits are defined in Rust within the <a href="https://github.com/OpenDevicePartnership/embedded-services/">embedded-services repository</a>, and we are going to import these structures into our own workspace as we build our mock battery.
In subsequent sections we'll connect the battery into the supporting upstream EC service framwork.</p>
<h2 id="setting-up-for-development"><a class="header" href="#setting-up-for-development">Setting up for development</a></h2>
<p>We are going to create a project space that contains a folder for our battery code, and the dependent repository clones.</p>
<p>So, start by finding a suitable location on your local computer and create the workpace:</p>
<pre><code>mkdir battery_project
cd battery_project
mkdir mock_battery
</code></pre>
<p>Now, we are going to clone the embedded-batteries directory and build the crates it exports.</p>
<p><em>(from the <code>battery_project</code> directory):</em></p>
<pre><code>git clone git@github.com:OpenDevicePartnership/embedded-batteries.git
cd embedded-batteries
cargo build
</code></pre>
<p>Now, we can go into our project space and start our own work.  Within the battery_project directory, create this project structure:</p>
<pre><code>mock_battery/
  src/ 
   - mock_battery.rs
  Cargo.toml 
  
Cargo.toml  
</code></pre>
<p>note there are two <code>Cargo.toml</code> files here. One is within the <code>battery_project</code> root folder and the other is at the root of <code>mock_battery</code>.  The <code>mock_battery.rs</code> file resides within the <code>mock_battery/src</code> directory.</p>
<p>The contents of the <code>battery_project/Cargo.toml</code> file should contain:</p>
<pre><code>[workspace]
resolver = "2"
members = [
    "mock_battery"
]

</code></pre>
<p>and the contents of the <code>battery_project/mock_battery/Cargo.toml</code> file should be set to:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
</code></pre>
<p>This structure and the <code>Cargo.toml</code> definitions just define a minimal skeleton for the dependencies we will be adding to as we continue to build our mock battery implementation and work it into the larger ODP framework.</p>
<p>the <code>mock_battery.rs</code> file can be empty for now.  We will define its contents in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-odp-repositories-for-defined-battery-traits"><a class="header" href="#using-the-odp-repositories-for-defined-battery-traits">Using the ODP repositories for defined Battery Traits</a></h1>
<p>In the previous step we set up our project workspace so that we can import from the ODP framework. In this step we will define the traits that our mock battery will expose.</p>
<h1 id="implementing-the-defined-traits"><a class="header" href="#implementing-the-defined-traits">Implementing the defined traits</a></h1>
<p>From the overview discussion you will recall that the SBS specification defines the Smart Battery with a series of functions that will return required data in expected ways.
Not surprisingly, then, we will find that the embedded-batteries crate we have imported defines these functions as traits to a SmartBattery trait.  If you are new to Rust, recall that if this were, say, C++ or Java, we would call this the SmartBattery <em>class</em>, or an <em>interface</em>.  These are <em>almost</em> interchangeable terms, but there are differences.  See <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">this definition</a> for more detail on that.</p>
<p>If we look through the <code>embedded-batteries</code> repository, we will see the SmartBattery trait defines the same functions we saw in the specification (except for the optional proprietary manufacturer facilitations).</p>
<p>So our job now is to implement these functions with data that comes from our battery - our Mock Battery.</p>
<p>We'll start off our <code>mock_battery.rs</code> file with this:</p>
<pre><code>use embedded_batteries::smart_battery::{
    SmartBattery, CapacityModeValue, CapacityModeSignedValue, BatteryModeFields,
    BatteryStatusFields, SpecificationInfoFields, ManufactureDate, ErrorType, 
    ErrorKind
};

#[derive(Debug)]
pub enum MockBatteryError {}

impl core::fmt::Display for MockBatteryError {
    fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
        write!(f, "MockBatteryError")
    }
}

use embedded_batteries::smart_battery::Error;

impl Error for MockBatteryError {
    fn kind(&amp;self) -&gt; ErrorKind {
        ErrorKind::Other
    }    
}

pub struct MockBattery;

impl ErrorType for MockBattery {
    type Error = MockBatteryError;
}

impl SmartBattery for MockBattery {
    fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    fn set_remaining_capacity_alarm(&amp;mut self, _val: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn set_remaining_time_alarm(&amp;mut self, _val: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::default())
    }

    fn set_battery_mode(&amp;mut self, _val: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    fn set_at_rate(&amp;mut self, _val: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    fn temperature(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2950) // 29.5°C in deciKelvin
    }

    fn voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7500) // mV
    }

    fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1500)
    }

    fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1400)
    }

    fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(1)
    }

    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }

    fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(85)
    }

    fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4200))
    }

    fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4800))
    }

    fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(60)
    }

    fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(75)
    }

    fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(30)
    }

    fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2000)
    }

    fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(8400)
    }

    fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::default())
    }

    fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(100)
    }

    fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(5000))
    }

    fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7800)
    }

    fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::default())
    }

    fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(12345)
    }

    fn manufacturer_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MockBatteryCorp";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MB-4200";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_chemistry(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"Li-Ion";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }
}

</code></pre>
<p>Yes, that's a bit long, but it's not particularly complex.
We'll unpack what all this is in a moment.  For now, let's verify this Rust code is valid and that we've imported from the ODP repository properly.</p>
<p>Type</p>
<pre><code>cargo build
</code></pre>
<p>at the project root.
This will produce an error saying the build fails because there are no targets specified in the manifest.<br />
This is because we haven't made our mock_battery public.</p>
<p>Create a file named <code>lib.rs</code> in the <code>src</code> folder and give it this content</p>
<pre><code>pub mod mock_battery;
</code></pre>
<p>And then try the build again. This time it should build without error.</p>
<h2 id="whats-in-there"><a class="header" href="#whats-in-there">What's in there</a></h2>
<p>The code in <code>mock_battery.rs</code> starts out with a <code>use</code> statement that imports what we will need from the <code>embedded-batteries::smart_battery</code> crate.</p>
<p>The next section defines a simple custom error type for use in our mock battery implementation. This MockBatteryError enum currently has no variants — it serves as a placeholder that allows our code to conform to the expected error traits used by the broader embedded_batteries framework.</p>
<p>By implementing core::fmt::Display, we ensure that error messages can be printed in a readable form (here, just "MockBatteryError"). Then, by implementing the embedded_batteries::smart_battery::Error trait, we allow this error to be returned in contexts where the smart battery interface expects a well-formed error object. The .kind() method returns ErrorKind::Other to indicate a generic error category.</p>
<p>This scaffolding allows our mock implementation to slot into the service framework cleanly, even if the actual logic is still forthcoming.</p>
<p>Finally, we get to the SmartBattery implementation for our MockBattery.  As you might guess, this simply implements each of the functions of the trait as declared, by simply returning an arbitrary representative return value for each.  We'll make these values more meaningful later, but for now, it's pretty minimalist.</p>
<h2 id="now-to-expose-this-to-the-service"><a class="header" href="#now-to-expose-this-to-the-service">Now to expose this to the service</a></h2>
<p>We have defined the battery traits and given our simulated placeholder values for our mock battery here.
If we were implementing a real battery, the process would follow the same pattern except that instead of the literal values we've assigned, we would
call upon our Hardware Abstraction Layer (HAL) implementation modules to pull these values from the actual hardware circuitry, per manufacturer design (i.e. GPIO or MMIO).
But before any of this is useful, it needs to be exposed to the service layer.  In the next step, we'll do a simple test that shows we can expose these values, and then we'll implement the service layer that conveys these up the chain in response to service messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-implementation"><a class="header" href="#battery-service-implementation">Battery Service implementation</a></h1>
<p>In the previous step, we defined the traits of our mock battery.  In this step, we will begin to implement the service layer that defines the messaging between the battery and the controller controller service.</p>
<p>Before we implement the actual service, however, let's write a quick test/example to illustrate these values being extracted from our battery traits.</p>
<h2 id="create-mainrs-file-for-mock_battery"><a class="header" href="#create-mainrs-file-for-mock_battery">Create main.rs file for mock_battery</a></h2>
<p>In your mock_battery project create <code>src/main.rs</code> with this content:</p>
<pre><code>use mock_battery::mock_battery::MockBattery;
use embedded_batteries::smart_battery::SmartBattery;

fn main() {
    let mut battery = MockBattery;

    let voltage = battery.voltage().unwrap();
    let soc = battery.relative_state_of_charge().unwrap();
    let temp = battery.temperature().unwrap();

    println!("Voltage: {} mV", voltage);
    println!("State of Charge: {}%", soc);
    println!("Temperature: {} deci-K", temp);
}
</code></pre>
<p>and type <code>cargo run</code> to build and execute it.
After it builds and runs successfully, you should see output similar to this:</p>
<pre><code>Voltage: 7500 mV
State of Charge: 88%
Temperature: 2950 deci-K
</code></pre>
<p>Note that you can execute <code>Cargo run</code> in this case both from either the <code>battery_project/mock_battery</code> or <code>battery_project</code> directories.<br />
As we continue with the integration, we will only be able to build and execute from the <code>battery_project</code> root, so you may want to get used to running from there.</p>
<p>We're going to replace this main.rs very shortly in an upcoming step, and this print to console behavior will be removed.  But for now it's a good sanity check of what you have built so far.
Later, we'll turn checks like this into meaningful unit tests.</p>
<p>We'll move ahead with forwarding this information up to the battery service controller,
but for now, pat yourself on the back, pour yourself a cup of coffee, and take a moment to review the pattern you have walked through:</p>
<ul>
<li>Identified the traits needed for the battery per spec as reflected in the <code>SmartBattery</code> trait imported from the ODP embedded-batteries repository</li>
<li>Implemented a HAL layer to retrieve these values from the hardware (We conveniently skipped this part because this is a mock battery)</li>
<li>Implemented the traits to return these values per the <code>SmartBattery</code> trait</li>
<li>Created a simple sanity check to prove these values are available at runtime.</li>
</ul>
<p>Next, we'll look at the ODP embedded-services repository and the battery-service support we find there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service"><a class="header" href="#battery-service">Battery Service</a></h1>
<p>We've successfully exposed and proven our implementation of battery traits and their values for our mock battery.
In this step, we'll continue our integration by connecting to a battery service.</p>
<h2 id="battery-service-1"><a class="header" href="#battery-service-1">Battery-service</a></h2>
<p>The ODP repository embedded-services has the battery-service we need for this, as well as the power-policy infracture support that uses it.</p>
<p>We will bring that into our scope now.</p>
<p>In the <code>battery_project</code> directory, where you previously cloned <code>embedded-batteries</code>, now clone <code>embedded-services</code> in much the same way with the command</p>
<pre><code>git clone git@github.com:OpenDevicePartnership/embedded-services.git
</code></pre>
<p>and then build it</p>
<pre><code>cd embedded-services
cargo build
</code></pre>
<h3 id="a-mock-battery-device"><a class="header" href="#a-mock-battery-device">A Mock Battery Device</a></h3>
<p>To fit the design of the ODP battery service, we first need to create a wrapper that contains our MockBattery and a Device Trait.  We need to implement <code>DeviceContainer</code> for this wrapper and reference that <code>Device</code>.
Then we will register the wrapper with <code>register_device(...)</code> and we will have an async loop that awaits commands on the <code>Device</code>'s <code>channel</code>, executes them, and updates state.</p>
<h4 id="import-the-battery-service-from-the-odp-crate"><a class="header" href="#import-the-battery-service-from-the-odp-crate">Import the battery-service from the ODP crate</a></h4>
<p>We built the crate in the previous step. We now need to remember to update our Cargo.toml to know where to find it.
Open the <code>Cargo.toml</code> file of your mock-battery project and add this battery-service path
so that your <code>[dependencies]</code> section now looks like this:</p>
<pre><code>[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
battery-service = { path = "../embedded-services/battery-service" }
</code></pre>
<p>This will allow us to import what we need for the next steps.</p>
<h3 id="define-the-mockbatterydevice-wrapper"><a class="header" href="#define-the-mockbatterydevice-wrapper">Define the MockBatteryDevice wrapper</a></h3>
<p>In your mock_battery project <code>src</code> folder, create a new file named <code>mock_battery_device.rs</code> and give it this content:</p>
<pre><code>use crate::mock_battery::MockBattery;
use embedded_services::power::policy::DeviceId;
use embedded_services::power::policy::action::device::AnyState;
use embedded_services::power::policy::device::{
    Device, DeviceContainer, CommandData, ResponseData//, State
};
// use embedded_services::intrusive_list::Node;


pub struct MockBatteryDevice {
    #[allow(dead_code)] // Prevent unused warning for MockBattery -- not used yet   
    battery: MockBattery,
    device: Device,
}

impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }

    pub fn device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }

    pub async fn run(&amp;self) {
        loop {
            let cmd = self.device.receive().await;

            // Access command using the correct method
            let request = &amp;cmd.command; 

            match request {
                CommandData::ConnectConsumer(cap) =&gt; {
                    println!("Received ConnectConsumer for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    // Safe placeholder: detach any existing state
                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::ConnectProvider(cap) =&gt; {
                    println!("Received ConnectProvider for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::Disconnect =&gt; {
                    println!("Received Disconnect");

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(e) = dev.detach().await {
                                println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; {
                            println!("Already disconnected or idle");
                        }
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }
            }
        }
    }
}

impl DeviceContainer for MockBatteryDevice {
    fn get_power_policy_device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }
}
</code></pre>
<p>What we've done here is:</p>
<ul>
<li>
<p>Imported what we need from the ODP repositories for both the SmartBattery definition from <code>embedded-batteries</code> and the battery service components from <code>embedded-services</code> crates as as our own local MockBattery definition.</p>
</li>
<li>
<p>Define and implement our MockBatteryDevice</p>
</li>
<li>
<p>implement a run loop for our MockBatteryDevice</p>
</li>
</ul>
<h4 id="including-embedded-services"><a class="header" href="#including-embedded-services">Including embedded-services</a></h4>
<p>We previously imported what we needed for the <code>battery-service</code> from <code>embedded-services</code> but now we need imports from <code>embedded-services</code> itself, so we must add this line
to the <code>[dependencies]</code> section of <code>mock_battery/Cargo.toml</code>:</p>
<pre><code>embedded-services = { path = "../embedded-services/embedded-service" }
</code></pre>
<h4 id="including-mock_battery_device"><a class="header" href="#including-mock_battery_device">Including mock_battery_device</a></h4>
<p>Just like we had to inform the build of our mock_battery, we need to do likewise with mock_battery_device.  So edit <code>lib.rs</code> and to this:</p>
<pre><code>pub mod mock_battery;
pub mod mock_battery_device;
</code></pre>
<h3 id="registering-our-device"><a class="header" href="#registering-our-device">Registering our device</a></h3>
<p>We need to register and run our device, but here's where we need to make a deviation. The embedded-services functions expect an asynchronous model.  In our embedded target, we will no doubt want to use the async executor from <a href="../../3/support/embassy.html#async-executor">Embassy</a> for this, but since for the moment we are still building and running on the desktop, we need a different option.  For desktop support, we will be using the <code>tokio</code> crate for async support.</p>
<p>This divergent juncture is also an excellent opportunity to demonstrate how two different implementation options might be selected using Feature flags, so we'll do that here.</p>
<h4 id="set-up-cargotoml"><a class="header" href="#set-up-cargotoml">Set up Cargo.toml</a></h4>
<p>We can set up for features in <code>Cargo.toml</code> of <code>mock_battery</code> by adding this section:</p>
<pre><code>[features]
default = ["desktop"]
desktop = ["tokio"]
embedded = ["embassy-executor"]
</code></pre>
<p>To support async, we will use Embassy for the embedded build.  This is supported by the ODP framework as well, so we will want to match it's dependencies here.</p>
<p>For desktop builds, we can use <code>tokio</code> for this.</p>
<p>We will need to import the <code>tokio</code> crate from <code>crates.io</code> to support the desktop implementation.
We import <code>embassy-executor</code> from <code>git</code>, since this must match the one referenced by the ODP framework.</p>
<p>We can do that by adding these lines to our <code>[dependencies]</code> section:</p>
<pre><code># Optional runtimes
tokio = { version = "1", features = ["full"], optional = true }
embassy-executor = { git = "https://github.com/embassy-rs/embassy", package = "embassy-executor", features = ["arch-std","executor-thread"], optional = true }

</code></pre>
<p>we mark them as optional, because they will only be used for their repective builds.</p>
<h4 id="updating-the-dependencies"><a class="header" href="#updating-the-dependencies">Updating the dependencies</a></h4>
<p>We now must make some edits to our top-level (<code>battery_project</code>) <code>Cargo.toml</code> file to reflect the new dependencies.</p>
<p>Add the references to <code>member</code> list of the <code>[workspace]</code> section:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-services/embedded-service",
    "embedded-services/battery-service",
    "embedded-batteries/embedded-batteries"
]
</code></pre>
<p>and create a new <code>[workspace.depedencies]</code> section in this file as well:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
</code></pre>
<p>This reconciles the name from 'embedded-service' to 'embedded-services'.</p>
<h4 id="unavoidable-detail-ahead-dependency-overrides"><a class="header" href="#unavoidable-detail-ahead-dependency-overrides">Unavoidable Detail Ahead: Dependency Overrides</a></h4>
<p>At this point, you'll encounter a wall of configuration. Unfortunately, the current structure of the service crates requires us to explicitly patch and align many transitive dependencies to avoid conflicts—especially around async runtime and HAL crates.</p>
<p>This may feel excessive, but it’s a one-time setup step to align everything cleanly for builds targeting either desktop or embedded systems. Once it’s in place, the rest of the work proceeds smoothly.</p>
<p>Add the following lines to the <code>[workspace.dependencies]</code> section:</p>
<pre><code># These align versions of crates used across embedded-services, battery-service,
# and embassy dependencies to avoid mismatched or duplicated transitive dependencies.
bitfield = "0.17.0"
bitflags = "2.8.0"
bitvec = { version = "1.0.1", default-features = false }
cfg-if = "1.0.0"
chrono = { version = "0.4", default-features = false }
cortex-m = "0.7.6"
cortex-m-rt = "0.7.5"
critical-section = "1.1"
defmt = "0.3"
document-features = "0.2.7"

embassy-executor     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-executor" }
embassy-futures      = { git = "https://github.com/embassy-rs/embassy", package = "embassy-futures" }
embassy-sync         = { git = "https://github.com/embassy-rs/embassy", package = "embassy-sync" }
embassy-time         = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time" }
embassy-time-driver  = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time-driver" }

embedded-batteries-async = { path = "embedded-batteries/embedded-batteries-async" }
embedded-cfu-protocol    = { git = "https://github.com/OpenDevicePartnership/embedded-cfu" }
embedded-hal             = "1.0"
embedded-hal-async       = "1.0"
embedded-hal-nb          = "1.0"
embedded-io              = "0.6.1"
embedded-io-async        = "0.6.1"
embedded-storage         = "0.3"
embedded-storage-async   = "0.4.1"
embedded-usb-pd          = { git = "https://github.com/OpenDevicePartnership/embedded-usb-pd", default-features = false }

fixed     = "1.23.1"
heapless  = "0.8.*"
log       = "0.4"
postcard  = "1.*"
rand_core = "0.6.4"
serde     = { version = "1.0.*", default-features = false }
tps6699x  = { git = "https://github.com/OpenDevicePartnership/tps6699x" }
</code></pre>
<p>And, finally, add this patch section so that Cargo does not try to load embassy from <code>crates.io</code> despite other declarations:</p>
<pre><code>[patch.crates-io]
embassy-executor = { git = "https://github.com/embassy-rs/embassy", package = "embassy-executor" }
embassy-time     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-time" }
embassy-sync     = { git = "https://github.com/embassy-rs/embassy", package = "embassy-sync" }
embassy-futures  = { git = "https://github.com/embassy-rs/embassy", package = "embassy-futures" }
</code></pre>
<p>You should now be able to run <code>cargo build</code> from the <code>battery_project</code> directory without errors.</p>
<h4 id="two-versions-of-main"><a class="header" href="#two-versions-of-main">Two versions of main</a></h4>
<p>Our register-and-run main function will have two versions. One for desktop (the default, and the one we just built in the previous step), and one for embedded.</p>
<p>In the <code>mock_battery</code> directory, create the file <code>embedded_main.rs</code> that we will use for our embedded target.  Give it this content:</p>
<pre><code>use embassy_executor::Spawner;
use embedded_services::power::policy::register_device;
use embedded_services::power::policy::DeviceId;
use mock_battery::mock_battery_device::MockBatteryDevice;

#[embassy_executor::main]
async fn main(_spawner: Spawner) {

    let dev = Box::leak(Box::new(MockBatteryDevice::new(DeviceId(0))));
    
    register_device(dev).await.unwrap();
    dev.run().await;
}

pub fn run() {
    // Stub for build compatibility when running on non-embedded platform
    panic!("This binary must be built for an embedded target");
}

</code></pre>
<p>and create a file named <code>desktop_main.rs</code> with this content:</p>
<pre><code>use embedded_services::power::policy::register_device;
use embedded_services::power::policy::DeviceId;
use mock_battery::mock_battery_device::MockBatteryDevice;


pub async fn run() {

    let dev = Box::leak(Box::new(MockBatteryDevice::new(DeviceId(0))));
    
    register_device(dev).await.unwrap();
    dev.run().await;
}

// Stub for build compatibility when running on non-embedded platform
#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _critical_section_1_0_acquire() {}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _critical_section_1_0_release() {}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _embassy_time_now() -&gt; u64 {
    0
}

#[cfg(feature = "desktop")]
#[unsafe(no_mangle)]
pub extern "C" fn _embassy_time_schedule_wake(_timestamp: u64) {}
</code></pre>
<p>Build the desktop version with</p>
<pre><code>cargo build --features desktop
</code></pre>
<p>and build the embedded version with</p>
<pre><code>cargo build --features embedded --no-default-features
</code></pre>
<p>Both should build without errors.</p>
<p>Note that <code>cargo build</code> by itself defaults to the desktop option.</p>
<p>The <code>--no-default-features</code> flag is required for the embedded option because of the exclusivity of the feature options.</p>
<p>Also note that you might optionally add <code> -p mock_battery</code> to this command to definitively say which workspace project to build, but this will be the default anyway since it is the only one that takes these features.</p>
<h4 id="no-output"><a class="header" href="#no-output">No output</a></h4>
<p>If you try to do a <code>cargo run</code> for the embedded build you will see an error that it can't do that without an embedded target -- which we will get to in good time.</p>
<p>If you do a <code>cargo run</code> for the desktop build you will not see any output, and will have to use <code>ctrl-c</code> to break and exit the program.</p>
<p>This is because we changed our main function (for both feature targets) to register and wait for commands from the service, and we haven't done that yet.  So nothing is going to appear until we do.</p>
<p>We'll be doing that in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-action"><a class="header" href="#battery-service-action">Battery Service Action</a></h1>
<p>Previously, we created our mock battery and wrapped it as a Device that could be inserted into a service.  Now we are going to do that so we can see our battery in action.</p>
<p><em>TODO</em></p>
<p><a href="../../library.html">Return to Library</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
