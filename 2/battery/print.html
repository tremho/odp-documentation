<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Battery and Power Management</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Battery and Power Management</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="battery-and-power-management"><a class="header" href="#battery-and-power-management">Battery and Power Management</a></h1>
<p>This example shows how to implement a mock battery service as part of the Embedded Controller (EC) power management system.</p>
<p>In this sample, we are going to implement a complete battery service subsystem.</p>
<h2 id="relevant-repositories"><a class="header" href="#relevant-repositories">Relevant Repositories</a></h2>
<p>We don't need to reinvent any wheels here. The ODP resources include ample template code and examples we can refer to for such a task. It is useful to identify which repositories contain these resources:</p>
<h3 id="embedded-services"><a class="header" href="#embedded-services">embedded-services</a></h3>
<p>We've touched on this before in <a href="../embedded_services/index.html">Embedded Services</a>, where we examined a Thermal subsystem implementation and explored variations between secure ARM-based and legacy x86_64-based systems.</p>
<p>We'll return to both of these concepts later. For now, we‚Äôll focus on implementing a Battery subsystem and related Power Policy services. After that, we‚Äôll fold in Thermal support and revisit the secure vs. non-secure implementations.</p>
<h3 id="embedded-batteries"><a class="header" href="#embedded-batteries">embedded-batteries</a></h3>
<p>This repository defines the Hardware Abstraction Layer (HAL) for a battery, tailored to the specific IC hardware being targeted. It builds a layered API chain upward, making most of the code portable and reusable across different integrations.</p>
<h3 id="embassy"><a class="header" href="#embassy">embassy</a></h3>
<p>Although our first exercises will be limited to simple desktop tests, we will then be building for an embedded context and that will require us to use features from <a href="https://embassy.dev/">Embassy</a> both directly and indirectly.</p>
<h3 id="soc-embedded-controller"><a class="header" href="#soc-embedded-controller">soc-embedded-controller</a></h3>
<p>This repository provides the core EC functionality, which in this case is centered around power policy and regulation.</p>
<p>We will refer to this later as we work on our own (virtual) battery service implementation.</p>
<p>We‚Äôll begin with the battery service ‚Äî one of the embedded services ‚Äî and later return here to integrate our battery into the broader scope of power management.</p>
<hr />
<h3 id="the-smart-battery"><a class="header" href="#the-smart-battery">The Smart Battery</a></h3>
<p>Batteries are ubiquitous in today‚Äôs portable devices. With many types of batteries serving various applications and provided by many vendors, the <a href="https://sbs-forum.org/specs/sbdat110.pdf">Smart Battery Data Specification</a> offers a standard to normalize this diversity.</p>
<p>Published by the Smart Battery System Implementers Forum (SBS-IF), this specification defines both electrical characteristics and ‚Äî more importantly for us ‚Äî the data and communication semantics of battery state.</p>
<p>Let's explore how this specification informs our implementation.</p>
<h4 id="battery-information"><a class="header" href="#battery-information">Battery Information</a></h4>
<p>A battery provides dynamic information (e.g., remaining charge), static metadata (e.g., make/model/serial/version), and operational parameters (e.g., recommended charge voltage/current).</p>
<p>As explored in <a href="...">...</a>, some of this information is exposed through direct hardware interfaces (e.g., GPIO or MMIO), while others originate from firmware logic or are derived dynamically.</p>
<p>Batteries typically report their state over a bus when queried and may also broadcast alarms when thresholds are breached.</p>
<p>The SBS specification outlines these functions that a smart battery should implement. These define a consistent set of data points and behaviors that other power management components can rely on:</p>
<ul>
<li><code>ManufacturerAccess</code> ‚Äì Optional, manufacturer-specific 16-bit value.</li>
<li><code>RemainingCapacityAlarm</code> ‚Äì Battery capacity threshold at which an alert should be raised.</li>
<li><code>RemainingTimeAlarm</code> ‚Äì Estimated time remaining before an alert should be raised.</li>
<li><code>BatteryMode</code> ‚Äì Flags indicating operational states or supported features.</li>
<li><code>AtRate</code> ‚Äì Charging/discharging rate used in subsequent time estimations.</li>
<li><code>AtRateTimeToFull</code> ‚Äì Time to full charge at the given rate.</li>
<li><code>AtRateTimeToEmpty</code> ‚Äì Time to depletion at the given rate.</li>
<li><code>AtRateTimeOK</code> ‚Äì Whether the battery can sustain the given rate for at least 10 seconds.</li>
<li><code>Temperature</code> ‚Äì Battery temperature.</li>
<li><code>Voltage</code> ‚Äì Battery voltage.</li>
<li><code>Current</code> ‚Äì Charge or discharge current.</li>
<li><code>AverageCurrent</code> ‚Äì One-minute rolling average of current.</li>
<li><code>MaxError</code> ‚Äì Expected error margin in charge calculations.</li>
<li><code>RelativeStateOfCharge</code> ‚Äì % of full charge capacity remaining.</li>
<li><code>AbsoluteStateOfCharge</code> ‚Äì % of design capacity remaining.</li>
<li><code>RemainingCapacity</code> ‚Äì In mAh or Wh, based on a capacity mode flag.</li>
<li><code>FullChargeCapacity</code> ‚Äì In mAh or Wh, based on capacity mode.</li>
<li><code>RunTimeToEmpty</code> ‚Äì Estimated minutes remaining.</li>
<li><code>AverageTimeToEmpty</code> ‚Äì One-minute average of minutes to empty.</li>
<li><code>AverageTimeToFull</code> ‚Äì One-minute average of minutes to full charge.</li>
<li><code>BatteryStatus</code> ‚Äì Flags indicating current state conditions.</li>
<li><code>CycleCount</code> - Number of cycles (a measure of wear). A cycle is the amount of discharge approximately equal to the value of the DesignCapacity.</li>
<li><code>DesignCapacity</code> - The theoretical capacity of a new battery pack.</li>
<li><code>DesignVoltage</code> - The theoritical voltage of a new battery pack.</li>
<li><code>SpecificationInfo</code> - Version and scaling specification info</li>
<li><code>ManufactureDate</code> - The data of manufacture as a bit-packed integer</li>
<li><code>SerialNumber</code> - the manufacturer assigned serial number of this battery pack.</li>
<li><code>ManufacturerName</code> - Name of the manufacturer</li>
<li><code>DeviceName</code> - Name of battery model.</li>
<li><code>DeviceChemistry</code> - String defining the battery chemical type</li>
<li><code>ManufacturerData</code> - (optional) proprietary manufacturer data.</li>
</ul>
<p>Please refer to the actual specification for details.  For example, functions referring to capacity may report in either current (mAh) or wattage (Wh) depending upon the current state of the CAPACITY_MODE flag (found in BatteryMode).</p>
<p>Some systems may support removable batteries, and such conditions must be accounted for in those designs.</p>
<hr />
<h2 id="a-mock-battery"><a class="header" href="#a-mock-battery">A Mock Battery</a></h2>
<p>In our example, we will use a microcontroller board as our EC but will not focus on real battery or charger hardware at this stage.</p>
<p>This allows us to begin development without sourcing specific hardware while still implementing nearly all of the system‚Äôs behavior. In the end, we will have a fully functional‚Äîalbeit artificial‚Äîbattery subsystem.</p>
<p>Once complete, this mock can be replaced with hardware-specific IO bindings, without requiring changes to the higher-level system logic.</p>
<p>Next we will look at what resources in the ODP repositories we will be working with as we build our battery implementation.</p>
<!--[Return to Library](../../Library.html) -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-mock-battery-project"><a class="header" href="#a-mock-battery-project">A Mock Battery Project</a></h1>
<p>In the previous section, we saw how the <em>Smart Battery Specification (SBS)</em> defines a set of functions that a Smart Battery service should implement.</p>
<p>In this section, we are going to review how these traits are defined in Rust within the <a href="https://github.com/OpenDevicePartnership/embedded-services/">embedded-services repository</a>, and we are going to import these structures into our own workspace as we build our mock battery.
In subsequent sections we'll connect the battery into the supporting upstream EC service framwork.</p>
<h2 id="setting-up-for-development"><a class="header" href="#setting-up-for-development">Setting up for development</a></h2>
<p>We are going to create a project space that contains a folder for our battery code, and the dependent repository clones.</p>
<p>So, start by finding a suitable location on your local computer and create the workpace:</p>
<pre><code>mkdir battery_project
cd battery_project
git init
</code></pre>
<p>This will create a workspace root for us and establish it as a git repository (not attached).</p>
<p>Now, we are going to bring the embedded-batteries directory
into our workspace and build the crates it exports.</p>
<p><em>(from the <code>battery_project</code> directory):</em></p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-batteries
</code></pre>
<p>Now, we can create our project space and start our own work.  Within the battery_project directory, create a folder named mock_battery and give it this project structure:</p>
<pre><code>mock_battery/
  src/ 
   - lib.rs
   - mock_battery.rs
  Cargo.toml 
  
Cargo.toml  
</code></pre>
<p>note there are two <code>Cargo.toml</code> files here. One is within the <code>battery_project</code> root folder and the other is at the root of <code>mock_battery</code>.  The <code>mock_battery.rs</code> file resides within the <code>mock_battery/src</code> directory.</p>
<p>The contents of the <code>battery_project/Cargo.toml</code> file should contain:</p>
<pre><code>[workspace]
resolver = "2"
members = [
    "mock_battery"
]

</code></pre>
<p>and the contents of the <code>battery_project/mock_battery/Cargo.toml</code> file should be set to:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
</code></pre>
<p>This structure and the <code>Cargo.toml</code> definitions just define a minimal skeleton for the dependencies we will be adding to as we continue to build our mock battery implementation and work it into the larger ODP framework.</p>
<p>The <code>lib.rs</code> file is used to tell Rust which modules are part of the project. Set it's contents to:</p>
<pre><code>pub mod mock_battery;
</code></pre>
<p>the <code>mock_battery.rs</code> file can be empty for now.  We will define its contents in the next section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-odp-repositories-for-defined-battery-traits"><a class="header" href="#using-the-odp-repositories-for-defined-battery-traits">Using the ODP repositories for defined Battery Traits</a></h1>
<p>In the previous step we set up our project workspace so that we can import from the ODP framework. In this step we will define the traits that our mock battery will expose.</p>
<h1 id="implementing-the-defined-traits"><a class="header" href="#implementing-the-defined-traits">Implementing the defined traits</a></h1>
<p>From the overview discussion you will recall that the SBS specification defines the Smart Battery with a series of functions that will return required data in expected ways.
Not surprisingly, then, we will find that the embedded-batteries crate we have imported defines these functions as traits to a SmartBattery trait.  If you are new to Rust, recall that if this were, say, C++ or Java, we would call this the SmartBattery <em>class</em>, or an <em>interface</em>.  These are <em>almost</em> interchangeable terms, but there are differences.  See <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">this definition</a> for more detail on that.</p>
<p>If we look through the <code>embedded-batteries</code> repository, we will see the SmartBattery trait defines the same functions we saw in the specification (except for the optional proprietary manufacturer facilitations).</p>
<p>So our job now is to implement these functions with data that comes from our battery - our Mock Battery.</p>
<p>We'll start off our <code>mock_battery.rs</code> file with this:</p>
<pre><code>use embedded_batteries::smart_battery::{
    SmartBattery, CapacityModeValue, CapacityModeSignedValue, BatteryModeFields,
    BatteryStatusFields, SpecificationInfoFields, ManufactureDate, ErrorType, 
    ErrorKind
};

#[derive(Debug)]
pub enum MockBatteryError {}

impl core::fmt::Display for MockBatteryError {
    fn fmt(&amp;self, f: &amp;mut core::fmt::Formatter&lt;'_&gt;) -&gt; core::fmt::Result {
        write!(f, "MockBatteryError")
    }
}

use embedded_batteries::smart_battery::Error;

impl Error for MockBatteryError {
    fn kind(&amp;self) -&gt; ErrorKind {
        ErrorKind::Other
    }    
}

pub struct MockBattery;

impl ErrorType for MockBattery {
    type Error = MockBatteryError;
}

impl SmartBattery for MockBattery {
    fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    fn set_remaining_capacity_alarm(&amp;mut self, _val: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn set_remaining_time_alarm(&amp;mut self, _val: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::default())
    }

    fn set_battery_mode(&amp;mut self, _val: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    fn set_at_rate(&amp;mut self, _val: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    fn temperature(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2950) // 29.5¬∞C in deciKelvin
    }

    fn voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7500) // mV
    }

    fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1500)
    }

    fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(1400)
    }

    fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(1)
    }

    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }

    fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(85)
    }

    fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4200))
    }

    fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(4800))
    }

    fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(60)
    }

    fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(75)
    }

    fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(30)
    }

    fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(2000)
    }

    fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(8400)
    }

    fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::default())
    }

    fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(100)
    }

    fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(5000))
    }

    fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(7800)
    }

    fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::default())
    }

    fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(12345)
    }

    fn manufacturer_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MockBatteryCorp";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_name(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"MB-4200";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }

    fn device_chemistry(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        let name = b"Li-Ion";
        buf[..name.len()].copy_from_slice(name);
        Ok(())
    }
}

</code></pre>
<p>Yes, that's a bit long, but it's not particularly complex.
We'll unpack what all this is in a moment.  For now, let's verify this Rust code is valid and that we've imported from the ODP repository properly.</p>
<p>Type</p>
<pre><code>cargo build
</code></pre>
<p>at the project root.
This should build without error.</p>
<h2 id="whats-in-there"><a class="header" href="#whats-in-there">What's in there</a></h2>
<p>The code in <code>mock_battery.rs</code> starts out with a <code>use</code> statement that imports what we will need from the <code>embedded-batteries::smart_battery</code> crate.</p>
<p>The next section defines a simple custom error type for use in our mock battery implementation. This MockBatteryError enum currently has no variants ‚Äî it serves as a placeholder that allows our code to conform to the expected error traits used by the broader embedded_batteries framework.</p>
<p>By implementing core::fmt::Display, we ensure that error messages can be printed in a readable form (here, just "MockBatteryError"). Then, by implementing the embedded_batteries::smart_battery::Error trait, we allow this error to be returned in contexts where the smart battery interface expects a well-formed error object. The .kind() method returns ErrorKind::Other to indicate a generic error category.</p>
<p>This scaffolding allows our mock implementation to slot into the service framework cleanly, even if the actual logic is still forthcoming.</p>
<p>Finally, we get to the SmartBattery implementation for our MockBattery.  As you might guess, this simply implements each of the functions of the trait as declared, by simply returning an arbitrary representative return value for each.  We'll make these values more meaningful later, but for now, it's pretty minimalist.</p>
<h2 id="now-to-expose-this-to-the-service"><a class="header" href="#now-to-expose-this-to-the-service">Now to expose this to the service</a></h2>
<p>We have defined the battery traits and given our simulated placeholder values for our mock battery here.
If we were implementing a real battery, the process would follow the same pattern except that instead of the literal values we've assigned, we would
call upon our Hardware Abstraction Layer (HAL) implementation modules to pull these values from the actual hardware circuitry, per manufacturer design (i.e. GPIO or MMIO).
But before any of this is useful, it needs to be exposed to the service layer.  In the next step, we'll do a simple test that shows we can expose these values, and then we'll implement the service layer that conveys these up the chain in response to service messages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-values"><a class="header" href="#battery-values">Battery values</a></h1>
<p>In the previous step, we defined the traits of our mock battery.  In this step, we will begin to implement the service layer that defines the messaging between the battery and the controller controller service.</p>
<p>Before we implement the actual service, however, let's write a quick test/example to illustrate these values being extracted from our battery traits.</p>
<h2 id="create-mainrs-file-for-mock_battery"><a class="header" href="#create-mainrs-file-for-mock_battery">Create main.rs file for mock_battery</a></h2>
<p>In your mock_battery project create <code>src/main.rs</code> with this content:</p>
<pre><code>use mock_battery::mock_battery::MockBattery;
use embedded_batteries::smart_battery::SmartBattery;

fn main() {
    let mut battery = MockBattery;

    let voltage = battery.voltage().unwrap();
    let soc = battery.relative_state_of_charge().unwrap();
    let temp = battery.temperature().unwrap();

    println!("Voltage: {} mV", voltage);
    println!("State of Charge: {}%", soc);
    println!("Temperature: {} deci-K", temp);
}
</code></pre>
<p>and type <code>cargo run</code> to build and execute it.
After it builds and runs successfully, you should see output similar to this:</p>
<pre><code>Voltage: 7500 mV
State of Charge: 88%
Temperature: 2950 deci-K
</code></pre>
<p>Note that you can execute <code>Cargo run</code> in this case both from either the <code>battery_project/mock_battery</code> or <code>battery_project</code> directories.<br />
As we continue with the integration, we will only be able to build and execute from the <code>battery_project</code> root, so you may want to get used to running from there.</p>
<p>We're going to replace this main.rs very shortly in an upcoming step, and this print to console behavior will be removed.  But for now it's a good sanity check of what you have built so far.
Later, we'll turn checks like this into meaningful unit tests.</p>
<p>We'll move ahead with forwarding this information up to the battery service controller,
but for now, pat yourself on the back, pour yourself a cup of coffee, and take a moment to review the pattern you have walked through:</p>
<ul>
<li>Identified the traits needed for the battery per spec as reflected in the <code>SmartBattery</code> trait imported from the ODP embedded-batteries repository</li>
<li>Implemented a HAL layer to retrieve these values from the hardware (We conveniently skipped this part because this is a mock battery)</li>
<li>Implemented the traits to return these values per the <code>SmartBattery</code> trait</li>
<li>Created a simple sanity check to prove these values are available at runtime.</li>
</ul>
<p>Next, we'll look at the ODP embedded-services repository and the battery-service support we find there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-for-the-embedded-target"><a class="header" href="#building-for-the-embedded-target">Building for the Embedded Target</a></h1>
<p>We've validated our simplistic mock battery has implemented basic traits, and we've been able to do that with a generic build on the desktop.
To go much further, we need to start building for the embedded controller context that this component is designed to run as - targeted for a microcontroller, without standard library dependencies.</p>
<p>Which development board we use at this point isn‚Äôt critical. Our mock battery and simulated components will remain software-only for now, so we don‚Äôt need physical hardware peripherals or a fully implemented HAL. Later, when we explore advanced features like ARM TrustZone or Hafnium hypervisor integration, we may need a specific Cortex-M board ‚Äî but those can be hard to source. So rather than lock ourselves in too early, we‚Äôll keep this next section general and adaptable to what you may already have.</p>
<p>In particular, if you've followed the excellent  <a href="https://docs.rust-embedded.org/book/">Rust Embedded Book</a>, there's a good chance you already have an STM32 Discovery board on hand. These boards are inexpensive, well-supported, and ideal for this stage of development.</p>
<p>The examples here will use the STM32F3 Discovery board. If you're using a different board, you may need to adjust your configuration accordingly. That said, our code will aim to be as portable and HAL-independent as possible.</p>
<h2 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h2>
<p>To build for an embedded target, we need to prepare our development environment with a few important tools and configuration files.</p>
<p>While there are many variations depending on target board and host OS, we will aim to keep this setup as broadly compatible and standard as possible.</p>
<h3 id="installing-the-embedded-rust-toolchain"><a class="header" href="#installing-the-embedded-rust-toolchain">Installing the Embedded Rust Toolchain</a></h3>
<p>The standard Rust toolchain needs a few additions to suppor cross-compiling for emedded targets.</p>
<p>Staying within your current <code>battery_project</code> workspace,
run</p>
<pre><code>rustup target add thumbv7em-none-eabihf
</code></pre>
<h3 id="including-embassy"><a class="header" href="#including-embassy">Including Embassy</a></h3>
<p>Many of the embedded features supported by ODP rely on dependencies of Embassy, and we will also want to use many of Embassy's framework support to simplify our construction.
To keep things as consistent as possible, we will be bringing in the Embassy repository as another submodule, similar to what we did with <code>embedded-batteries</code></p>
<p>At the <code>battery_project</code> root:</p>
<pre><code>git submodule add https://github.com/embassy-rs/embassy.git
</code></pre>
<h3 id="updating-the-configuration-files"><a class="header" href="#updating-the-configuration-files">Updating the configuration files</a></h3>
<p>In <code>mock_battery/Cargo.toml</code>, update the contents to look like this:</p>
<pre><code>[package]
name = "mock_battery"
version = "0.1.0"
edition = "2024"


[dependencies]
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embassy-executor = { path = "../embassy/embassy-executor", optional = true }

[features]
default = ["embedded"]
embedded = ["embassy-executor"]
</code></pre>
<p>At the top-level Cargo.toml (<code>battery_project/Cargo.toml</code>), update the workspace members to include the new local crates:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embassy/embassy-executor"
]
</code></pre>
<p>Now you should be able to build with</p>
<pre><code>cargo build
</code></pre>
<p>That should build properly.
Now let's see if we can target our embedded toolchain.
enter</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>This will produce a number of errors because we still have the old <code>println!</code> statements in there from the previous example.
We also need to better prepare the code for a "no-std" environment.</p>
<p>Replace the current <code>main.rs</code> content with this new version:</p>
<pre><code>#![no_std]
#![no_main]

use embedded_batteries::smart_battery::SmartBattery;
use mock_battery::mock_battery::MockBattery;
use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let mut battery = MockBattery;

    let _ = battery.voltage();
    let _ = battery.relative_state_of_charge();
    let _ = battery.temperature();

    loop {}
}

#[panic_handler]
fn panic(_info: &amp;core::panic::PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>You can see we're not only not printing anything to the output here, we have specifically declared <code>#![no_std]</code> and provided a <code>#[panic_handler]</code> that normally would be supplied by std.</p>
<p>One more thing to do.  In <code>lib.rs</code>, add <code>#![no_std]</code> at the top of that file as well.</p>
<pre><code>#![no_std]
pub mod mock_battery;
</code></pre>
<p>Now</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>should build without issue.</p>
<p>In the next section, we will look at writing Unit Tests to prove out the behaviors of our mock battery and provide some simulation of charge behaviors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-preparation"><a class="header" href="#battery-service-preparation">Battery Service Preparation</a></h1>
<p>We've successfully exposed and proven our implementation of battery traits and their values for our mock battery,
and built for an embedded target.
In this step, we'll continue our integration by connecting to a battery service, but that requires some setup to cover first.</p>
<h2 id="battery-service"><a class="header" href="#battery-service">Battery-service</a></h2>
<p>The ODP repository <code>embedded-services</code> has the <code>battery-service</code> we need for this, as well as the power-policy infracture support that uses it.</p>
<p>The ODP repository <code>embedded-cfu</code> is also needed here,
as is <code>embedded-usb-pd</code>.</p>
<p>We will bring these into our scope now.</p>
<p>In the <code>battery_project</code>, we'll bring these in with the commands:</p>
<pre><code>git submodule add https://github.com/OpenDevicePartnership/embedded-services

git submodule add git@github.com:OpenDevicePartnership/embedded-cfu

git submodule add git@github.com:OpenDevicePartnership/embedded-usb-pd

</code></pre>
<h3 id="a-mock-battery-device"><a class="header" href="#a-mock-battery-device">A Mock Battery Device</a></h3>
<p>To fit the design of the ODP battery service, we first need to create a wrapper that contains our MockBattery and a Device Trait.  We need to implement <code>DeviceContainer</code> for this wrapper and reference that <code>Device</code>.
Then we will register the wrapper with <code>register_device(...)</code> and we will have an async loop that awaits commands on the <code>Device</code>'s <code>channel</code>, executes them, and updates state.</p>
<h4 id="import-the-battery-service-from-the-odp-crate"><a class="header" href="#import-the-battery-service-from-the-odp-crate">Import the battery-service from the ODP crate</a></h4>
<p>One of the service definitions from the <code>embedded-services</code> repository we brought into scope is the <code>battery-service</code>.
We now need to update our Cargo.toml to know where to find it.
Open the <code>Cargo.toml</code> file of your mock-battery project and add the dependency to the battery-service path to our Cargo.toml.  We will also need a reference to <code>embedded-services</code> itself for various support needs.  Update your <code>mock_battery/Cargo.toml</code> so that your <code>[dependencies]</code> section now looks like this:</p>
<pre><code>[dependencies]
cortex-m-rt = "0.7.3"
static_cell = "2.0.0"
embedded-batteries = { path = "../embedded-batteries/embedded-batteries" }
embedded-batteries-async = { path = "../embedded-batteries/embedded-batteries-async" }
battery-service = { path = "../embedded-services/battery-service" }
embedded-services = { path = "../embedded-services/embedded-service" }
</code></pre>
<p>This will allow us to import what we need for the next steps.</p>
<h3 id="define-the-mockbatterydevice-wrapper"><a class="header" href="#define-the-mockbatterydevice-wrapper">Define the MockBatteryDevice wrapper</a></h3>
<p>In your mock_battery project <code>src</code> folder, create a new file named <code>mock_battery_device.rs</code> and give it this content:</p>
<pre><code>use crate::mock_battery::MockBattery;
use embedded_services::power::policy::DeviceId;
use embedded_services::power::policy::action::device::AnyState;
use embedded_services::power::policy::device::{
    Device, DeviceContainer, CommandData, ResponseData//, State
};
// use embedded_services::intrusive_list::Node;


pub struct MockBatteryDevice {
    #[allow(dead_code)] // Prevent unused warning for MockBattery -- not used yet   
    battery: MockBattery,
    device: Device,
}

impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }

    pub fn device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }

    pub async fn run(&amp;self) {
        loop {
            let cmd = self.device.receive().await;

            // Access command using the correct method
            let request = &amp;cmd.command; 

            match request {
                CommandData::ConnectConsumer(_cap) =&gt; {
                    // println!("Received ConnectConsumer for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    // Safe placeholder: detach any existing state
                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::ConnectProvider(_cap) =&gt; {
                    // println!("Received ConnectProvider for {}mA @ {}mV", cap.current_ma, cap.voltage_mv);

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; (),
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }

                CommandData::Disconnect =&gt; {
                    // println!("Received Disconnect");

                    match self.device.device_action().await {
                        AnyState::ConnectedProvider(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        AnyState::ConnectedConsumer(dev) =&gt; {
                            if let Err(_e) = dev.detach().await {
                                // println!("Detach failed: {:?}", e);
                            }
                        }
                        _ =&gt; {
                            // println!("Already disconnected or idle");
                        }
                    }

                    cmd.respond(Ok(ResponseData::Complete));
                }
            }
        }
    }
}

impl DeviceContainer for MockBatteryDevice {
    fn get_power_policy_device(&amp;self) -&gt; &amp;Device {
        &amp;self.device
    }
}
</code></pre>
<p>What we've done here is:</p>
<ul>
<li>
<p>Imported what we need from the ODP repositories for both the SmartBattery definition from <code>embedded-batteries</code> and the battery service components from <code>embedded-services</code> crates as as our own local MockBattery definition.</p>
</li>
<li>
<p>Define and implement our MockBatteryDevice</p>
</li>
<li>
<p>implement a run loop for our MockBatteryDevice</p>
</li>
</ul>
<p>Note also there are some commented-out <code>println!</code> macros. We can't use <code>println!</code> in our embedded context, but we'll deal with that later. For now these comments serve as placeholders.</p>
<h4 id="including-mock_battery_device"><a class="header" href="#including-mock_battery_device">Including mock_battery_device</a></h4>
<p>Just like we had to inform the build of our mock_battery, we need to do likewise with mock_battery_device.  So edit <code>lib.rs</code> and to this:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
</code></pre>
<p><strong>Important</strong>: Note that we also added <code>#![no_std]</code> at the top of this <code>lib.rs</code> file.  This is necessary to insure that our build is not expecting the defaults from std to be available.</p>
<h4 id="updating-the-dependencies"><a class="header" href="#updating-the-dependencies">Updating the dependencies</a></h4>
<p>We now must make some edits to our top-level <code>battery_project/Cargo.toml</code> file to reflect the new dependencies.</p>
<p>Add the references to our embedded-services dependencies to <code>members</code> list of the <code>[workspace]</code> section so it now has all our new members:</p>
<pre><code>members = [
    "mock_battery",
    "embedded-batteries/embedded-batteries",
    "embedded-batteries/embedded-batteries-async",
    "embedded-services/embedded-service",
    "embedded-services/battery-service",
    "embedded-cfu",
    "embedded-usb-pd",
    "embassy/embassy-executor",
    "embassy/embassy-futures",
    "embassy/embassy-sync",
    "embassy/embassy-time",
    "embassy/embassy-time-driver"
]
</code></pre>
<p>and create a new <code>[workspace.depedencies]</code> section in this file as well:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
</code></pre>
<p>This reconciles the name from 'embedded-service' to 'embedded-services'.</p>
<h2 id="-dependency-detour-manual-overrides-required--"><a class="header" href="#-dependency-detour-manual-overrides-required--">üõ†Ô∏èüß© Dependency Detour: Manual Overrides Required üß© üõ†Ô∏è</a></h2>
<p>At this point, you'll encounter a wall of configuration.
If you try to build here you will get an error about an failure to inherit a workspace dependency or else a dependency not found.  This is due to the need to match the configurations for the crates we are importing.  You can use tools like <code>cargo search</code> to show the current version of dependencies, for example, and tackle these one at a time, but in the interest of efficiency, just copy what is shown here, because there is a lot.</p>
<p>Unfortunately, the current structure of the service crates requires us to explicitly patch and align many transitive dependencies to avoid conflicts‚Äîespecially around async runtime and HAL crates.</p>
<p>This may feel excessive, but it‚Äôs a one-time setup step to align everything cleanly for builds targeting either desktop or embedded systems. Once it‚Äôs in place, the rest of the work proceeds smoothly.</p>
<p>Your top-level Cargo.toml at <code>battery_project/Cargo.toml</code> should have a full <code>[workspace.dependencies]</code> section that looks like this:</p>
<pre><code>[workspace.dependencies]
embedded-services = { path = "embedded-services/embedded-service" }
defmt = "1.0"
embassy-executor = { path = "embassy/embassy-executor" }
embassy-futures = { path = "embassy/embassy-futures" }
embassy-sync = { path = "embassy/embassy-sync" }
embassy-time = { path = "embassy/embassy-time" }
embassy-time-driver = { path = "embassy/embassy-time-driver" }
embedded-batteries-async = { path = "embedded-batteries/embedded-batteries-async" }
embedded-cfu-protocol = { path = "embedded-cfu" }
embedded-usb-pd = { path = "embedded-usb-pd" }

embedded-hal = "1.0.0"
embedded-hal-async = "1.0.0"
log = "0.4"
bitfield = "0.17.0"
bitflags = "2.8.0"
bitvec = { version = "1.0.1", default-features = false }
cfg-if = "1.0.0"
chrono = { version = "0.4", default-features = false }
cortex-m = "0.7.6"
cortex-m-rt = "0.7.5"
critical-section = "1.1"
document-features = "0.2.7"                    
embedded-hal-nb = "1.0.0"
embedded-io = "0.6.1"
embedded-io-async = "0.6.1"
embedded-storage = "0.3.0"
embedded-storage-async = "0.3.0"
rand_core = "0.9.3"
heapless = { version = "0.7.16", default-features = false }
fixed = { version = "1.23.1", default-features = false }
postcard = { version = "1.1.1", default-features = false }
serde = { version = "1.0.219", default-features = false, features = ["derive"] }
</code></pre>
<p>After you've done all that,  you should be able to build with</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<p>and get a clean result</p>
<p>Next we will work to put this battery to use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="battery-service-registry"><a class="header" href="#battery-service-registry">Battery Service Registry</a></h1>
<p>So far, we've defined our mock battery and wrapped it in Device wrapper so that it is ready to be included in a Service registry.</p>
<p>To do so meant committing to an embedded target build and a no-std environment compatible with the ODP crates and dependencies.</p>
<p>Now it is time to prepare the code we need to put this MockBatteryDevice to work.</p>
<h3 id="looking-at-the-examples"><a class="header" href="#looking-at-the-examples">Looking at the examples</a></h3>
<p>The <code>embedded-services</code> repository has some examples for us to consider already.  In the <code>embedded-services/examples/std</code> folder, particularly in <code>battery.rs</code> and <code>power_policy.rs</code> we can see how devices are created and then registered, and also how they are executed via per-device tasks.  The system is initialized and a runtime <code>Executor</code> is used to spawn the tasks.</p>
<h2 id="-wiring-up-the-battery-service"><a class="header" href="#-wiring-up-the-battery-service">üîå Wiring Up the Battery Service</a></h2>
<p>We need to create a device <code>Registry</code> as defined by <code>embedded-services</code> to wire our <code>MockBatteryDevice</code> into.</p>
<p>To do this, let's replace our current <code>mock_battery/main.rs</code> with this:</p>
<pre><code>#![no_std]
#![no_main]

use embassy_executor::Spawner;
use embedded_services::init;
use embedded_services::power::policy::{register_device, DeviceId};
use static_cell::StaticCell;
use mock_battery::mock_battery_device::MockBatteryDevice;

use battery_service::{self, device::Device, wrapper::Wrapper};
use mock_battery::mock_battery_controller::MockBatteryController;

#[embassy_executor::main]
async fn async_main(spawner: Spawner) {
    // Required by embedded-services to initialize internals
    init().await;

    // Initialize and register our battery device
    static BATTERY: StaticCell&lt;MockBatteryDevice&gt; = StaticCell::new();
    let battery = BATTERY.init(MockBatteryDevice::new(DeviceId(0)));
    register_device(battery).await.unwrap();
    spawner.must_spawn(battery_run_task(battery));

    static WRAPPER: StaticCell&lt;Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;&gt; = StaticCell::new();


    // Initialize our fuel gauge controller
    static CONTROLLER: StaticCell&lt;MockBatteryController&gt; = StaticCell::new();
    let controller = CONTROLLER.init(MockBatteryController::new());
    
    // Initialize the device used by the battery service wrapper
    static DEVICE: StaticCell&lt;Device&gt; = StaticCell::new();
    let dev = DEVICE.init(Device::new(battery_service::device::DeviceId(1)));

    // Create a wrapper that can process battery service messages
    let wrapper = WRAPPER.init(Wrapper::new(dev, controller));
    // must_spawn will panic if the task fails to spawn, suitable for no_std
    spawner.must_spawn(wrapper_task(wrapper));

    
}

#[embassy_executor::task]
async fn battery_run_task(battery: &amp;'static MockBatteryDevice) {
    battery.run().await;
}


#[embassy_executor::task]
async fn wrapper_task(wrapper: &amp;'static Wrapper&lt;'static, &amp;'static mut MockBatteryController&gt;) {
    loop {
        wrapper.process().await;
    }
}

/// Required by embedded targets for panic handling
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    loop {}
}
</code></pre>
<p>When you execute <code>cargo build --target thumbv7em-none-eabihf</code> you will receive errors, such as
"error: No architecture selected for embassy-executor. Make sure you've enabled one of the <code>arch-*</code> features in your Cargo.toml."</p>
<p>We still have some configuration to do.</p>
<p><code>embassy-executor</code> requires specific selection of the MCU architecture via features.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, remove the line
from the <code>[dependencies]</code> section</p>
<pre><code>embassy-executor = { path = "../embassy/embassy-executor", optional = true }
</code></pre>
<p>and add this section:</p>
<pre><code>[dependencies.embassy-executor]
path = "../embassy/embassy-executor"
features = ["arch-cortex-m", "executor-thread"]
optional = true
</code></pre>
<p>also, add these lines to the <code>[dependencies]</code> section (these references will come up soon):</p>
<pre><code>embassy-time = { path = "../embassy/embassy-time" }
embassy-sync = { path = "../embassy/embassy-sync" }
</code></pre>
<p>and then try again: <code>cargo build --target thumbv7em-none-eabihf</code></p>
<h2 id="the-battery-service"><a class="header" href="#the-battery-service">The Battery Service</a></h2>
<p>Now we have registered our battery device as a device for the embedded-services power policy,
but the <code>battery_service</code> knows how to use a battery specifically, so we need to register our battery as a 'fuel gauge' by that definition.</p>
<h3 id="the-battery-controller"><a class="header" href="#the-battery-controller">The Battery Controller</a></h3>
<p>The battery service <code>Controller</code> is the trait interface used to control a battery connected via the SmartBattery trait interface at a slightly higher level.</p>
<p>Create a new file in <code>mock_battery</code> named <code>mock_battery_controller.rs</code> and give it this content:</p>
<pre><code>use battery_service::controller::{Controller, ControllerEvent};
use battery_service::device::{DynamicBatteryMsgs, StaticBatteryMsgs};
use embassy_time::{Duration, Timer};
use embedded_batteries_async::smart_battery::{
    SmartBattery, ErrorType, 
    ManufactureDate, SpecificationInfoFields, CapacityModeValue, CapacityModeSignedValue,
    BatteryModeFields, BatteryStatusFields, 
    DeciKelvin, MilliVolts
};
use core::convert::Infallible;

pub struct MockBatteryController;

impl MockBatteryController {
    pub fn new() -&gt; Self {
        Self
    }
}

impl ErrorType for MockBatteryController {
    type Error = Infallible;
}

impl SmartBattery for &amp;mut MockBatteryController {
    async fn temperature(&amp;mut self) -&gt; Result&lt;DeciKelvin, Self::Error&gt; {
        Ok(2732) // Stubbed temperature in deci-Kelvin
    }
    // You can stub other SmartBattery methods as needed
    async fn voltage(&amp;mut self) -&gt; Result&lt;MilliVolts, Self::Error&gt; {
        Ok(11000)
    }


    // Stub all other required methods
    async fn remaining_capacity_alarm(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn set_remaining_capacity_alarm(&amp;mut self, _: CapacityModeValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn remaining_time_alarm(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn set_remaining_time_alarm(&amp;mut self, _: u16) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn battery_mode(&amp;mut self) -&gt; Result&lt;BatteryModeFields, Self::Error&gt; {
        Ok(BatteryModeFields::new())
    }

    async fn set_battery_mode(&amp;mut self, _: BatteryModeFields) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate(&amp;mut self) -&gt; Result&lt;CapacityModeSignedValue, Self::Error&gt; {
        Ok(CapacityModeSignedValue::MilliAmpSigned(0))
    }

    async fn set_at_rate(&amp;mut self, _: CapacityModeSignedValue) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn at_rate_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn at_rate_ok(&amp;mut self) -&gt; Result&lt;bool, Self::Error&gt; {
        Ok(true)
    }

    async fn current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_current(&amp;mut self) -&gt; Result&lt;i16, Self::Error&gt; {
        Ok(0)
    }

    async fn max_error(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn absolute_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(0)
    }

    async fn remaining_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn full_charge_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn run_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_empty(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn average_time_to_full(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_current(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn charging_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn battery_status(&amp;mut self) -&gt; Result&lt;BatteryStatusFields, Self::Error&gt; {
        Ok(BatteryStatusFields::new())
    }

    async fn cycle_count(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn design_capacity(&amp;mut self) -&gt; Result&lt;CapacityModeValue, Self::Error&gt; {
        Ok(CapacityModeValue::MilliAmpUnsigned(0))
    }

    async fn design_voltage(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn specification_info(&amp;mut self) -&gt; Result&lt;SpecificationInfoFields, Self::Error&gt; {
        Ok(SpecificationInfoFields::new())
    }

    async fn manufacture_date(&amp;mut self) -&gt; Result&lt;ManufactureDate, Self::Error&gt; {
        let mut date = ManufactureDate::new();
        date.set_day(1);
        date.set_month(1);
        date.set_year(2025 - 1980); // must use offset from 1980

        Ok(date)
    }

    async fn serial_number(&amp;mut self) -&gt; Result&lt;u16, Self::Error&gt; {
        Ok(0)
    }

    async fn manufacturer_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_name(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }

    async fn device_chemistry(&amp;mut self, _: &amp;mut [u8]) -&gt; Result&lt;(), Self::Error&gt; {
        Ok(())
    }    
}

impl Controller for &amp;mut MockBatteryController {
    type ControllerError = Infallible;

    async fn initialize(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    async fn get_static_data(&amp;mut self) -&gt; Result&lt;StaticBatteryMsgs, Self::ControllerError&gt; {
        Ok(StaticBatteryMsgs { ..Default::default() })
    }

    async fn get_dynamic_data(&amp;mut self) -&gt; Result&lt;DynamicBatteryMsgs, Self::ControllerError&gt; {
        Ok(DynamicBatteryMsgs { ..Default::default() })
    }

    async fn get_device_event(&amp;mut self) -&gt; ControllerEvent {
        loop {
            Timer::after(Duration::from_secs(60)).await;
        }
    }

    async fn ping(&amp;mut self) -&gt; Result&lt;(), Self::ControllerError&gt; {
        Ok(())
    }

    fn get_timeout(&amp;self) -&gt; Duration {
        Duration::from_secs(10)
    }

    fn set_timeout(&amp;mut self, _duration: Duration) {
        // Ignored for mock
    }
}
</code></pre>
<p>This just implements the SmartBattery traits with stubs for now.  We will connect it to our mock_battery shortly.  But for now, this gets us going past the next few steps.</p>
<h4 id="add-to-librs"><a class="header" href="#add-to-librs">add to <code>lib.rs</code></a></h4>
<p>Don't forget that we need to include this new file in our <code>lib.rs</code> declarations:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
</code></pre>
<p>Make sure you can build cleanly at this point, and then we will move ahead.</p>
<h3 id="the-fuel-gauge"><a class="header" href="#the-fuel-gauge">The fuel gauge</a></h3>
<p>The battery service has the concept of a 'fuel gauge' that calls into the SmartBattery traits to monitor charge / discharge.</p>
<p>We'll hook that up now.</p>
<p>Add this task to your <code>main.rs</code> file, nearby the other tasks found there:</p>
<pre><code>#[embassy_executor::task]
async fn battery_service_init_task(dev: &amp;'static Device) {
    let reg = battery_service::register_fuel_gauge(dev).await;
    if reg.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register fuel gauge device");
    }
}

</code></pre>
<p>and we'll call upon it just after registering the device, so at the end of your <code>async main</code> function, just after <code>spawner.must_spawn(wrapper_task(wrapper));</code>, add this:</p>
<pre><code> 
    // Register the fuel gauge device with the battery service
    spawner.must_spawn(battery_service_init_task(dev));
</code></pre>
<p>Verify you can still build cleanly</p>
<pre><code>cargo build --target thumbv7em-none-eabihf
</code></pre>
<h3 id="implementing-comms"><a class="header" href="#implementing-comms">Implementing "comms"</a></h3>
<p>The battery service is one of several services that may reside within the Embedded Controller (EC) microcontroller. In a fully integrated system, messages between the EC and other components ‚Äî such as a host CPU or companion chips ‚Äî are typically carried over physical transports like SPI or I¬≤C.</p>
<p>However, within the EC firmware itself, services communicate through an internal message routing layer known as comms. This abstraction allows us to test and exercise service logic without needing external hardware.</p>
<p>At this point, we‚Äôll establish a simple comms setup that allows messages to reach our battery service from other parts of the EC ‚Äî particularly the power policy manager. The overall comms architecture can expand later to handle actual buses, security paging, or multi-core domains, but for now, a minimal local implementation will suffice.</p>
<h4 id="the-espi-comms"><a class="header" href="#the-espi-comms">The "espi" comms</a></h4>
<p>We'll follow a pattern exhibited by the ODP <code>embedded-services/examples/std/src/bin/battery.rs</code>, but trimmed for embedded/no-std use.</p>
<p>Create a file for a module named <code>espi_service.rs</code> inside your <code>mock_battery/src</code> folder and give it this content:</p>
<pre><code>use battery_service::context::{BatteryEvent, BatteryEventInner};
use battery_service::device::DeviceId;
use embassy_sync::blocking_mutex::raw::NoopRawMutex;
use embassy_sync::once_lock::OnceLock;
use embassy_sync::signal::Signal;
use embedded_services::comms::{self, EndpointID, External};
use embedded_services::ec_type::message::BatteryMessage;


pub struct EspiService {
    endpoint: comms::Endpoint,
    _signal: Signal&lt;NoopRawMutex, BatteryMessage&gt;,
}

impl EspiService {
    pub fn new() -&gt; Self {
        Self {
            endpoint: comms::Endpoint::uninit(EndpointID::External(External::Host)),
            _signal: Signal::new(),
        }
    }
}

impl comms::MailboxDelegate for EspiService {
    fn receive(&amp;self, message: &amp;comms::Message) -&gt; Result&lt;(), comms::MailboxDelegateError&gt; {
        let msg = message
            .data
            .get::&lt;BatteryMessage&gt;()
            .ok_or(comms::MailboxDelegateError::MessageNotFound)?;

        match msg {
            BatteryMessage::CycleCount(_count) =&gt; {
                // Do something if needed; placeholder
                Ok(())
            }
            _ =&gt; Err(comms::MailboxDelegateError::InvalidData),
        }
    }
}

static ESPI_SERVICE: OnceLock&lt;EspiService&gt; = OnceLock::new();

pub async fn init() {

    let svc = ESPI_SERVICE.get_or_init(EspiService::new);
    if comms::register_endpoint(svc, &amp;svc.endpoint).await.is_err() {
        // Handle registration failure as needed
        panic!("Failed to register ESPI service endpoint");
    }

}

#[embassy_executor::task]
pub async fn task() {
    let svc = ESPI_SERVICE.get().await;

    let _ = svc.endpoint.send(
        EndpointID::Internal(comms::Internal::Battery),
        &amp;BatteryEvent {
            device_id: DeviceId(1),
            event: BatteryEventInner::DoInit,
        },
    ).await;

    let _ = battery_service::wait_for_battery_response().await;

    loop {
        let _ = svc.endpoint.send(
            EndpointID::Internal(comms::Internal::Battery),
            &amp;BatteryEvent {
                device_id: DeviceId(1),
                event: BatteryEventInner::PollDynamicData,
            },
        ).await;

        let _ = battery_service::wait_for_battery_response().await;

        embassy_time::Timer::after(embassy_time::Duration::from_secs(5)).await;
    }
}
</code></pre>
<p>Before the loop, the DoInit message is sent which will cause <code>Controller::initialize</code> to be invoked via service layer.  The loop runs at 5 second intervals and polls for updates in the dynamic data
(such as the current level of charge).</p>
<p>and, by now I'm sure you know the drill, remember to add this module to your <code>lib.rs</code> file:</p>
<pre><code>#![no_std]
pub mod mock_battery;
pub mod mock_battery_device;
pub mod mock_battery_controller;
pub mod espi_service;
</code></pre>
<p>Now we will attach it in our <code>main.rs</code> file.</p>
<p>Add this <code>use</code> statement to import it:</p>
<pre><code>use mock_battery::espi_service;
</code></pre>
<p>and these lines at the end of your <code>async main</code> to initialize it and spin it up:</p>
<pre><code>    // Start up our comms
    espi_service::init().await;
    spawner.must_spawn(espi_service::task());
</code></pre>
<h3 id="adding-some-logging-support"><a class="header" href="#adding-some-logging-support">Adding some logging support</a></h3>
<p>We are now in a position to get data from our battery.  But how will we know? We need some logging in place first.  Let's hook that up now.</p>
<p>In your <code>mock_battery/Cargo.toml</code>, add or update these values in their respective sections:</p>
<pre><code>[dependencies]
defmt = "1.0"
defmt-rtt = "0.4"
panic-probe = { version = "0.3", features = ["print-defmt"] }

# Add the log shim for libraries using `log` crate
log = { version = "0.4", features = ["release_max_level_debug"], optional = true }
defmt-log = { version = "0.3", optional = true }

[features]
default = ["embedded", "defmt-log", "log"]

[package.metadata.cargo-xbuild]
linker = "rust-lld"

</code></pre>
<p>We can now remove the <code>#![panic_handler] block in </code>main.rs` altogether and replace it with:</p>
<pre><code>/// Required by embedded targets for panic handling
use panic_probe as _; // This provides a defmt-compatible panic handler
</code></pre>
<p>The panic-probe crate, when built with the print-defmt feature, automatically installs the right panic handler for you ‚Äî no need to write one manually.</p>
<p>Using the logging is straightforward.  Examples of log statements would be like:</p>
<pre><code>info!("Starting wrapper task");
warn!("Something unusual");
error!("Something failed: {:?}", err);
</code></pre>
<!-- 
Note - this setup for logging is incomplete and turns out to be much more of a rabbit-hole than I could have imagined.
Additionally, major revisions to memory.x and
some of the cargo settings are needed, plus some
stubs for the cortex-m that need to be put into place that are not documented yet before anything
will build correctly to flash to the hardware. 
This is the current WIP and may require a separate section before continuing here.
-->
<h3 id="getting-the-dynamic-data"><a class="header" href="#getting-the-dynamic-data">Getting the dynamic data</a></h3>
<p>So now that we have logging in place,</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
