<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tests - ODP Documentation Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ODP Documentation Guide</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h1>
<p>In the previous exercises, we have built an implementation of a SmartBattery for our Mock Battery, and shown we can implement it into a service registry where it can be called upon by a service.</p>
<p>The next step is to test our implementation through a series of Unit Tests.
Unit Tests will insure the implementation produces the results we expect.  Early on, we had simply printed some values to the console to verify certain values.  This is not a good method of testing because the print action cannot be part of the final build.  Instead, we want to use a Unit Test harness that will allow us to inspect our otherwise silent build and report the values within it.</p>
<p>This will also allow us to continue to develop additional features of the battery as we simulate its behavior for charge over time.  This approach is commonly known as "Test Driven Development" (TDD) and is a strong pattern to adopt for any development scenario, perhaps even moreso for embedded device development.</p>
<h2 id="types-of-tests-and-where-to-put-them"><a class="header" href="#types-of-tests-and-where-to-put-them">Types of Tests and where to put them</a></h2>
<p>A <strong>Unit Test</strong> typically is scoped to test only the capabilities of a single component or "unit" of code.
An <strong>Integration Test</strong> is a test that either tests different implementations of a single unit structure, or else the integration of more than one component and the interactions between these components.</p>
<p>Code for Integration Tests are typically in a separate .rs file (often within a 'test' directory).  Unit Tests may also be separate, but it is also conventional for Unit Tests to be included in the same Rust code file as the component code itself.
In our Mock Battery case, we will put these first tests within our mock_battery.rs file.
This keeps our tests co-located with the implementation and avoids the need for additional test scaffolding.
Since we're implementing traits intended for broader reuse, but are only concerned with our one MockBattery implementation for now, embedding the tests here is both practical and instructive.</p>
<h3 id="our-first-tests"><a class="header" href="#our-first-tests">Our first tests</a></h3>
<p>So let's get started.  We're going to start with the mock battery itself. This keeps us focused on this basic level of functionality without adding additional complications of the abstraction layers introduced by wrapping it in a Device.  We'll return to this when we start writing directly for an embedded target and want to verify those levels.</p>
<p>At the bottom of <code>mock_battery.rs</code> add this code:</p>
<pre><code>#[cfg(test)]
mod tests {
    use super::*;
    use embedded_batteries::smart_battery::SmartBattery;

    #[test]
    fn test_voltage() {
        let mut battery = MockBattery;
        let voltage = battery.voltage().expect("Voltage should be readable");
        assert_eq!(voltage, 7500); // mV
    }

    #[test]
    fn test_state_of_charge() {
        let mut battery = MockBattery;
        let soc = battery.relative_state_of_charge().expect("SoC should be readable");
        assert_eq!(soc, 88); // percentage
    }

    #[test]
    fn test_temperature() {
        let mut battery = MockBattery;
        let temp = battery.temperature().expect("Temperature should be readable");
        assert_eq!(temp, 2950); // deci-Kelvin
    }

    #[test]
    fn test_manufacturer_name() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 32];
        battery.manufacturer_name(&amp;mut buf).expect("Should get manufacturer name");
        let name = core::str::from_utf8(&amp;buf[..15]).expect("Valid UTF-8");
        assert_eq!(name, "MockBatteryCorp");
    }

    #[test]
    fn test_device_name() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 32];
        battery.device_name(&amp;mut buf).expect("Should get device name");
        let name = core::str::from_utf8(&amp;buf[..8]).expect("Valid UTF-8");
        assert_eq!(name.trim_end_matches(char::from(0)), "MB-4200");
    }

    #[test]
    fn test_device_chemistry() {
        let mut battery = MockBattery;
        let mut buf = [0u8; 16];
        battery.device_chemistry(&amp;mut buf).expect("Should get chemistry name");
        let name = core::str::from_utf8(&amp;buf[..6]).expect("Valid UTF-8");
        assert_eq!(name.trim_end_matches(char::from(0)), "Li-Ion");
    }
}

</code></pre>
<h3 id="running-the-test"><a class="header" href="#running-the-test">Running the test</a></h3>
<p>When you are ready, type <code>cargo test</code> at the <code>battery_project</code> root.</p>
<p>You will see a lot of output because <code>cargo test</code> is going to test all the components of the workspace, including the ODP repository directories we've included.
There may be warning errors in some of these dependencies. But you will also see that all the tests pass, and looking more closely at the output you will see that there are indeed 6 tests reported for mock_battery that all pass.</p>
<blockquote>
<p>üìå <strong>Note about embedded dependencies and unit testing</strong></p>
<p>While <code>cargo test -p mock_battery</code> would normally isolate this crate for testing,
the embedded dependencies it brings in assume certain runtime features (like <code>critical-section</code> and <code>embassy_time</code>) that aren't defined in desktop builds.</p>
<p>These assumptions cause linker errors unless we provide full backend implementations ‚Äî something we‚Äôll do later, when we shift to testing in a proper embedded target.</p>
<p>For now, we can safely run our unit tests by invoking <code>cargo test</code> from the workspace root, and simply ignore unrelated test warnings from other crates.</p>
</blockquote>
<h4 id="fixing-some-of-the-warnings-from-the-dependencies"><a class="header" href="#fixing-some-of-the-warnings-from-the-dependencies">Fixing some of the warnings from the dependencies</a></h4>
<p>It is not uncommon to encounter warnings in tests that are introduced from dependencies.  As one might appreciate, writing tests for a shared package that may be used in multiple different contexts can be challenging, and the focus on testing tends to center on the worthiness of the code in the package more than the viability of those tests being inherited by consuming packages.</p>
<p>You may be seeing warnings in the full test run we have done that originate from one or more of the dependent projects.</p>
<p>This is a common and recognizable problem and the Rust toolchain is aware of it and smart enough to assist.</p>
<p>If there are warnings such as 'unused import', 'unused variable', incorrect field names (with suggestions), or notes about outdated or deprecated syntax, <code>cargo</code> can repair these for you.</p>
<p>So, for example, if you have a 'unused import' warning originating from the <code>embedded-services</code> repository in this workspace, you can try <code>cargo fix --lib -p embedded-services --tests --allow-no-vcs</code>
This will patch any offending test code that may have caused the previous warnings.  If you subsequently run <code>cargo test</code> the warnings should have disappeared.</p>
<h3 id="continuing-with-tdd"><a class="header" href="#continuing-with-tdd">Continuing with TDD</a></h3>
<p>Having gotten that cleared up, we are ready to continue to build out our tests and the corresponding behaviors for our mock battery to behave like a real battery might.</p>
<h4 id="defining-the-time-trait-now"><a class="header" href="#defining-the-time-trait-now">Defining the Time Trait <code>now</code></a></h4>
<p>To simulate charge or discharge over time in our mock battery, we need a way to track elapsed time. We'll use one actual time source here and another later when we are in-system on a target build.</p>
<p>To support this cleanly, we will define a TimeSource trait,
and its implementation for our current test context.</p>
<pre><code>pub trait TimeSource {
    fn now(&amp;self) -&gt; u64; // time in milliseconds
}

#[derive(Default)]
pub struct MockTime {
    time_ms: core::cell::Cell&lt;u64&gt;,
}

impl MockTime {
    pub fn new() -&gt; Self {
        Self { time_ms: core::cell::Cell::new(0) }
    }

    pub fn advance(&amp;self, delta_ms: u64) {
        let now = self.time_ms.get();
        self.time_ms.set(now + delta_ms);
    }
}

impl TimeSource for MockTime {
    fn now(&amp;self) -&gt; u64 {
        self.time_ms.get()
    }
}
</code></pre>
<p>This just defines a time that starts with an initial real time value, and advances the time by a given amount when we call <code>advance</code>. It could just as well start at 0 and be manually advanced for testing, but we'll go ahead and attach a real clock.</p>
<h4 id="adding-a-clock-to-the-mockbattery"><a class="header" href="#adding-a-clock-to-the-mockbattery">Adding a clock to the MockBattery</a></h4>
<p>Let's give our MockBattery a TimeSource trait and a couple of reference values we will use later.  We'll use <code>std:rc::Rc</code> as a real-time clock reference for our testing for now.</p>
<p>üìå <strong>Use of dynamic dispatch</strong></p>
<blockquote>
<p>Note: We're using dynamic dispatch here (<code>dyn TimeSource</code>)
for flexibility in swapping out implementations. In
performance-sensitive code, a generic parameter might be
preferable, but this approach keeps things simple and
testable.</p>
</blockquote>
<pre><code>use std::rc::Rc;

pub struct MockBattery {
    clock: Rc&lt;dyn TimeSource&gt;,
    #[allow(dead_code)]
    start_time: u64,
    #[allow(dead_code)]
    start_soc: u8,
}

impl MockBattery {
    // to create a battery with a self-contained internal clock
    pub fn new() -&gt; Self {
        let clock = Rc::new(MockTime::new());
        let now = clock.now();
        Self {
            clock,
            start_time: now,
            start_soc: 100,
        }
    }
}
impl MockBattery {
    // to create a battery in which time time source is external
    pub fn with_clock(clock: Rc&lt;dyn TimeSource&gt;) -&gt; Self {
        let now = clock.now();
        Self {
            clock,
            start_time: now,
            start_soc: 100,
        }
    }

    pub fn clock(&amp;self) -&gt; &amp;Rc&lt;dyn TimeSource&gt; {
        &amp;self.clock
    }
}

</code></pre>
<h4 id="update-the-battery-instantiation"><a class="header" href="#update-the-battery-instantiation">Update the battery instantiation</a></h4>
<p>We now need to update every place in our first test code where we reference what was originally a static battery structure with a new instantiation.
Find all the lines like this:</p>
<pre><code>let mut battery = MockBattery;
</code></pre>
<p>and replace with:</p>
<pre><code>let mut battery = MockBattery::new();
</code></pre>
<p>And since we've changed MockBattery in this way we also need to fix the reference to it in <code>mock_battery_device.rs</code> or it won't compile.</p>
<p>In <code>mock_battery_device.rs</code> change</p>
<pre><code>impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery: MockBattery,
            device: Device::new(id)
        }
    }
</code></pre>
<p>to</p>
<pre><code>impl MockBatteryDevice {
    pub fn new(id: DeviceId) -&gt; Self {
    Self {
            battery:  MockBattery::new(),
            device: Device::new(id)
        }
    }
</code></pre>
<h3 id="implementing-dynamic-battery-behavior"><a class="header" href="#implementing-dynamic-battery-behavior">Implementing dynamic battery behavior</a></h3>
<p>Now that we have a time reference, we can support concepts like charge/discharge over time for our simulated battery.</p>
<h4 id="relative-state-of-charge"><a class="header" href="#relative-state-of-charge">Relative state of charge</a></h4>
<p>The SmartBattery Specification, which we've implemented statically by providing values for the traits of our MockBattery implementation, defines a function <code>RelativeStateOfCharge</code> that we can use to determine the current battery capacity over time as it is discharged.</p>
<p>We have implemented this in our MockBattery currently, here:</p>
<pre><code>    fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
        Ok(88)
    }
</code></pre>
<p>which will forever report our remaining capacity at 88%.</p>
<p>To make this dynamic and respect the other attributes implemented via our SmartBattery implmentation, we can change this function to the following:</p>
<pre><code>fn relative_state_of_charge(&amp;mut self) -&gt; Result&lt;u8, Self::Error&gt; {
    let cap = match self.full_charge_capacity()? {
        CapacityModeValue::MilliAmpUnsigned(c) =&gt; c as u32,
        _ =&gt; return Ok(100),
    };

    let curr = self.average_current()? as i32;
    let discharge_ma = if curr &lt;= 0 { 1 } else { curr };

    let elapsed_ms = self.clock.now().saturating_sub(self.start_time);
    let elapsed_mah = (elapsed_ms as i64 * discharge_ma as i64) / 3600_000;

    let remaining_mah = cap.saturating_sub(elapsed_mah.max(0) as u32);

    let percent = ((remaining_mah as f64 / cap as f64) * 100.0).round() as u8;
    Ok(percent.min(100))
}
</code></pre>
<p>This will give us a simulated discharge using a simple linear model.  A more sophisticated battery simulation may use a non-linear derivation or consider other factors (e.g. thermal effects) that we don't have available at the current time, but
our real goal is not to make the world's best battery simulation, but rather to learn how to connect <em>real</em> batteries - no simulation needed - in the same way.  So this is fine.</p>
<h4 id="fixing-the-initial-charge-value"><a class="header" href="#fixing-the-initial-charge-value">Fixing the initial charge value</a></h4>
<p>If we ran that test  now, it would fail because our first tests are still checking the original values we used when we constructed our SmartBattery implmentation.  So we need to change the test for this to expect 100 instead of 88, like it has been because we now are expecting a full charge at startup, per our dynamic function above.</p>
<p>So change <code>test_state_of_charge</code> to look like:</p>
<pre><code>    #[test]
    fn test_state_of_charge() {
        let mut battery = MockBattery::new();
        let soc = battery.relative_state_of_charge().expect("SoC should be readable");
        assert_eq!(soc, 100); // fresh battery just instantiated
    }
</code></pre>
<h4 id="testing-decrease-over-time"><a class="header" href="#testing-decrease-over-time">Testing decrease over time</a></h4>
<p>Now let's actually test for a decrease in charge over time with a new test function.</p>
<p>Add this test at teh bottom of the <code>#[cfg(test)]</code> block:</p>
<pre><code>#[test]
fn test_dynamic_soc_decreases_over_time() {
    let clock = std::rc::Rc::new(MockTime::new());
    let mut battery = MockBattery::with_clock(clock.clone());

    // At time 0, should be near 100%
    let soc_initial = battery.relative_state_of_charge().unwrap();
    assert!(soc_initial &gt;= 99, "Initial SoC should be close to 100, got {}", soc_initial);

    // Advance 1 hour (3600_000 ms)
    clock.advance(3600_000);

    // Now SoC should have decreased
    let soc_after_1h = battery.relative_state_of_charge().unwrap();
    assert!(soc_after_1h &lt; soc_initial, "SoC should decrease after 1h");
    assert!(soc_after_1h &lt;= 100, "SoC should be at most 100%");
}

</code></pre>
<p>As you can see, this test gets the initial value of our charge, which should be 100%, then uses our TimeSource to advance time one hour after  the initial charge of 100%, then tests
As you can see, this test gets the initial value of our charge, which should be 100%, then uses our TimeSource to advance time one hour after and verifies that the charge is &lt; 100%</p>
<p>For the next section, we need to stop working on our desktop build and move forward with an embedded target.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../how/ec/battery/10-service_registry.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../how/ec/battery/12-embedded.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../how/ec/battery/10-service_registry.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../how/ec/battery/12-embedded.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
